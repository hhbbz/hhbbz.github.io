<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hhbbz-Blog</title>
  
  <subtitle>hhbbz</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hhbbz.github.io/"/>
  <updated>2019-12-06T09:50:50.642Z</updated>
  <id>https://hhbbz.github.io/</id>
  
  <author>
    <name>hhbbz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java多线程的使用之三板斧</title>
    <link href="https://hhbbz.github.io/2019/12/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8B%E4%B8%89%E6%9D%BF%E6%96%A7/"/>
    <id>https://hhbbz.github.io/2019/12/06/Java多线程的使用之三板斧/</id>
    <published>2019-12-06T07:31:50.000Z</published>
    <updated>2019-12-06T09:50:50.642Z</updated>
    
    <content type="html"><![CDATA[<h1>场景</h1><p>在我们实际开发过程中，往往会遇到执行接口逻辑以及批任务处理的的执行效率问题，在这些场景中，都可以通过使用多线程的方式，把占据长时间的程序中的任务放到后台去处理，更好的发挥计算机的多核cpu的优势。</p><h1>概述</h1><p>这篇文章只介绍开发过程中实用的多线程代码的三种编写方法和实践过程，参数说明、线程安全、多线程之间的调度策略和状态同步这里就不多介绍了，会在后面的文章中加以详细说明。</p><h1>多线程三板斧</h1><ul><li><strong>CompletableFuture</strong> 配合 <strong>TaskExecutor</strong> 异步执行</li><li><strong>ThreadFactory</strong> 、 <strong>TaskExecutor</strong> 配合 service和handler的消费者模式 异步执行</li><li><strong>ForkJoin</strong>将任务切割成子任务，并行执行</li></ul><h2>CompletableFuture 配合 TaskExecutor 异步执行</h2><p>CompletableFuture是java8新增加的类，提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力。</p><p>下面是简单使用CompletableFuture进行异步任务的执行。</p><ol><li>封装一个<strong>TaskExecutor</strong></li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**异步执行的线程池 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TaskExecutor <span class="title">dataAsyncTaskExecutor</span><span class="params">(DataImportProperties importProperties)</span></span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor taskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        taskExecutor.setCorePoolSize(importProperties.getThreadNumber());</span><br><span class="line">        taskExecutor.setMaxPoolSize(<span class="number">50</span>);</span><br><span class="line">        taskExecutor.setThreadGroupName(<span class="string">"data-async-importer"</span>);</span><br><span class="line">        taskExecutor.setThreadNamePrefix(<span class="string">"data-async"</span>);</span><br><span class="line">        taskExecutor.initialize();</span><br><span class="line">        <span class="keyword">return</span> taskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>在上面封装的线程池中使用<strong>CompletableFuture</strong></li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name = <span class="string">"dataAsyncTaskExecutor"</span>)</span><br><span class="line"><span class="keyword">private</span> TaskExecutor taskExecutor;</span><br><span class="line"><span class="comment">//异步任务</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(()-&gt;<span class="number">1</span>,taskExecutor);</span><br><span class="line"><span class="comment">//阻塞异步任务获取结果</span></span><br><span class="line">future.get();</span><br></pre></td></tr></table></figure></p><pre><code>如果使用CompletableFuture过程中不传入自己封装的线程池，CompletableFuture会使用ForkJoinPool.commonPool()，它是一个会被很多任务 共享 的线程池，比如同一 JVM 上的所有 CompletableFuture、并行 Stream 都将共享 commonPool，除此之外，应用代码也能使用它。</code></pre><h2><strong>ThreadFactory</strong> 、 <strong>TaskExecutor</strong> 配合 service和handler的消费者模式 异步执行</h2><p>这种是大家比较常用的异步执行任务的做法。代码比较直观，更容易调试。下面展示一个<strong>多线程异步批次消费队列</strong>的实践代码。</p><ol><li>定义队列数据封装</li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**队列数据 */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**数据的数据标识 */</span></span><br><span class="line">    <span class="keyword">private</span> String dbTableCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>定义队列任务生产端</li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用内存队列作为消息处理服务缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryQueueService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Queue&lt;QueueData&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemoryQueueService</span><span class="params">(Queue&lt;QueueData&gt; queue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//推入队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">publish</span><span class="params">(Map&lt;String, Object&gt; eventData)</span> </span>&#123;</span><br><span class="line">        QueueData queueData = <span class="keyword">new</span> QueueData();</span><br><span class="line">        queueData.setData(eventData);</span><br><span class="line">        queue.offer(queueData);</span><br><span class="line">        <span class="keyword">return</span> queue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>定义队列任务批次消费端handler</li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存队列的消费端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryQueueDataHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> batchSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;QueueData&gt; eventCache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;QueueData&gt; queue;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否运行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> running;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemoryQueueDataHandler</span><span class="params">(Queue&lt;QueueData&gt; queue, <span class="keyword">int</span> batchSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        <span class="keyword">this</span>.batchSize = batchSize;</span><br><span class="line">        eventCache = <span class="keyword">new</span> ArrayList&lt;&gt;(batchSize);</span><br><span class="line">        running = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"内存队列数据监听handler启动."</span>);</span><br><span class="line">        QueueData eventData=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (running || eventData!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//消费</span></span><br><span class="line">            eventData = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (eventData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//事件消息不为空</span></span><br><span class="line">                eventCache.add(eventData);</span><br><span class="line">                <span class="comment">//批量写入</span></span><br><span class="line">                <span class="keyword">if</span> (eventCache.size() &gt;= batchSize) &#123;</span><br><span class="line">                    flushCacheToDb();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!eventCache.isEmpty())&#123;</span><br><span class="line">                <span class="comment">//缓存不为空</span></span><br><span class="line">                flushCacheToDb();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果队列为空,缓存也为空则等待</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//刷新缓存</span></span><br><span class="line">        flushCacheToDb();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheToDb</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String,List&lt;Map&lt;String,Object&gt;&gt;&gt; wData = <span class="keyword">new</span> HashMap&lt;&gt;(batchSize);</span><br><span class="line">        <span class="comment">//构造批次</span></span><br><span class="line">        <span class="keyword">for</span> (QueueData queueData : eventCache) &#123;</span><br><span class="line">            List&lt;Map&lt;String, Object&gt;&gt; cacheQueue = wData.computeIfAbsent(queueData.getDbTableCode(), k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;(batchSize));</span><br><span class="line">            cacheQueue.add(queueData.getData());</span><br><span class="line">            wData.put(queueData.getDbTableCode(),cacheQueue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//批量写入</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; entry : wData.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//TODO 写入逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        eventCache.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunning</span><span class="params">(<span class="keyword">boolean</span> running)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.running = running;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>简单定义<strong>ThreadFactory</strong>、消费端<strong>ExecutorService</strong>、生产端<strong>ConcurrentLinkedQueue</strong>,并新增任务。</li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line">    <span class="keyword">private</span> MemoryQueueService queueService;</span><br><span class="line">    ThreadFactory threadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"event-consume-%d"</span>).build();</span><br><span class="line">    <span class="comment">//后面把异步任务委托给ExecutorService</span></span><br><span class="line">  executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">3</span>, <span class="comment">//核心线程</span></span><br><span class="line">            <span class="number">5</span>, <span class="comment">//最大线程</span></span><br><span class="line">            <span class="number">300</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class="line">            threadFactory</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//存放数据的队列</span></span><br><span class="line">    ConcurrentLinkedQueue&lt;QueueData&gt; queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">//生产端</span></span><br><span class="line">    queueService = <span class="keyword">new</span> MemoryQueueService(queue);</span><br><span class="line">    <span class="comment">//启用5个线程进行消费</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//消费端</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> MemoryQueueDataHandler(dataEngine,queue,dataProperties.getBatchSize()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往队列中缓存数据</span></span><br><span class="line">HashMap&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">queueService.publish(map)</span><br></pre></td></tr></table></figure></p><h2><strong>ForkJoin</strong>将大任务切割成小任务，并行执行</h2><p>支和并框架的目的是以递归的方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体的结果，它是ExecutorService的一个实现，它把子任务分配给线程池（ForkJoinPool）中的工作线程。</p><ol><li>基于ForkJoin封装拆分任务，执行逻辑的抽象类</li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListForkJoinExecution</span>&lt;<span class="title">V</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待处理数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> List&lt;V&gt; values;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单元逻辑执行函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Function&lt;V, R&gt; function;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结果队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ConcurrentLinkedQueue&lt;ListForkJoinExecution&lt;V, R&gt;&gt; resultQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListForkJoinExecution</span><span class="params">(List&lt;V&gt; values, Function&lt;V, R&gt; function)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.values = values;</span><br><span class="line">        <span class="keyword">this</span>.function = function;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(ConcurrentLinkedQueue&lt;ListForkJoinExecution&lt;V, R&gt;&gt; resultQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resultQueue = resultQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> R <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = values.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(len &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> min = len / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 拆分前一半</span></span><br><span class="line">                List&lt;V&gt; headValues = values.subList(<span class="number">0</span> , min);</span><br><span class="line">                ListForkJoinExecution&lt;V,R&gt; a = <span class="keyword">new</span> ListForkJoinExecution(headValues, function);</span><br><span class="line">                a.setResult(resultQueue);</span><br><span class="line">                a.fork();</span><br><span class="line">                resultQueue.offer(a);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 拆分后一半</span></span><br><span class="line">                List&lt;V&gt; endValues = values.subList(min + <span class="number">1</span> , len);</span><br><span class="line">                ListForkJoinExecution&lt;V,R&gt; b = <span class="keyword">new</span> ListForkJoinExecution(endValues, function);</span><br><span class="line">                b.setResult(resultQueue);</span><br><span class="line">                b.fork();</span><br><span class="line">                resultQueue.offer(b);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 本次任务处理一个</span></span><br><span class="line">                R r = function.apply(values.get(min));</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">                List&lt;V&gt; headValues = values.subList(<span class="number">0</span> , <span class="number">1</span>);</span><br><span class="line">                ListForkJoinExecution&lt;V,R&gt; a = <span class="keyword">new</span> ListForkJoinExecution(headValues, function);</span><br><span class="line">                a.setResult(resultQueue);</span><br><span class="line">                a.fork();</span><br><span class="line">                resultQueue.offer(a);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 拆分后一半</span></span><br><span class="line">                List&lt;V&gt; endValues = values.subList(<span class="number">1</span> , <span class="number">2</span>);</span><br><span class="line">                ListForkJoinExecution&lt;V,R&gt; b = <span class="keyword">new</span> ListForkJoinExecution(endValues, function);</span><br><span class="line">                b.setResult(resultQueue);</span><br><span class="line">                b.fork();</span><br><span class="line">                resultQueue.offer(b);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                R r = function.apply(values.get(<span class="number">0</span>));</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>执行forkjoin任务</li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPoolRun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并行处理列表方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task  任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt;   参数对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt;   返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, R&gt; <span class="function">List&lt;R&gt; <span class="title">run</span><span class="params">(ListForkJoinExecution&lt;V, R&gt; task)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> run(<span class="number">8</span>, task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, R&gt; <span class="function">List&lt;R&gt; <span class="title">run</span><span class="params">(<span class="keyword">int</span> poolSize, ListForkJoinExecution&lt;V, R&gt; task)</span></span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool(poolSize);</span><br><span class="line"></span><br><span class="line">        List&lt;R&gt; result = Lists.newArrayList();</span><br><span class="line">        ConcurrentLinkedQueue&lt;ListForkJoinExecution&lt;V, R&gt;&gt; resultQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            task.setResult(resultQueue);</span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            R r = pool.submit(task).get();</span><br><span class="line">            <span class="comment">// 没有结算结果的不追加到结果集中</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result.add(r);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (resultQueue.iterator().hasNext()) &#123;</span><br><span class="line">                ListForkJoinExecution&lt;V, R&gt; poll = resultQueue.poll();</span><br><span class="line">                <span class="keyword">if</span> (poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    R join = poll.join();</span><br><span class="line">                    <span class="comment">// 没有结算结果的不追加到结果集中</span></span><br><span class="line">                    <span class="keyword">if</span> (join != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        result.add(join);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pool.shutdown();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"遍历处理任务异常！"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并执行无返回方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task  任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt;   返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(VoidForkJoinExecution&lt;R&gt; task)</span></span>&#123;</span><br><span class="line">        run(<span class="number">8</span>, task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> poolSize, VoidForkJoinExecution&lt;R&gt; task)</span></span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool(poolSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            pool.submit(task);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!pool.isTerminated())&#123;</span><br><span class="line">                pool.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"遍历处理任务异常！"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;场景&lt;/h1&gt;
&lt;p&gt;在我们实际开发过程中，往往会遇到执行接口逻辑以及批任务处理的的执行效率问题，在这些场景中，都可以通过使用多线程的方式，把占据长时间的程序中的任务放到后台去处理，更好的发挥计算机的多核cpu的优势。&lt;/p&gt;
&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;这篇文章只介绍
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://hhbbz.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ignite踩坑录(3) 数据平衡分布</title>
    <link href="https://hhbbz.github.io/2019/09/23/ignite%E8%B8%A9%E5%9D%91%E5%BD%95-3-%E6%95%B0%E6%8D%AE%E5%B9%B3%E8%A1%A1%E5%88%86%E5%B8%83/"/>
    <id>https://hhbbz.github.io/2019/09/23/ignite踩坑录-3-数据平衡分布/</id>
    <published>2019-09-23T06:49:44.000Z</published>
    <updated>2019-09-25T02:50:43.120Z</updated>
    
    <content type="html"><![CDATA[<h1>为什么需要数据平衡分布</h1><p>在一个集群的环境中，我们往往希望能更好的利用分布式的优势，把数据平衡分布在各个节点中，这样有几个好处：</p><ol><li><p>这样才能缓存/持久化更多的数据。</p></li><li><p>即使其中一个节点down掉，也不影响其他节点的数据和状态。</p></li><li><p>数据在各个节点中平衡分布，使得资源利用率，单节点的拔插效率更高。</p></li></ol><h1>igntie实现分布式存储的配置</h1><p>Ignite提供了三种不同的缓存操作模式，<code>分区</code>、<code>复制</code>和<code>本地</code>。缓存模型可以为每个缓存单独配置，缓存模型是通过<code>CacheMode</code>枚举定义的。</p><h2>分区模式</h2><p><code>分区</code>模式是扩展性最好的分布式缓存模式，这种模式下，所有数据被均等地分布在分区中，所有的分区也被均等地拆分在相关的节点中，实际上就是为缓存的数据创建了一个巨大的<code>内存内分布式存储</code>。这个方式可以在所有节点上只要匹配总可用存储(内存和磁盘)就可以存储尽可能多的数据，因此，可以在集群的所有节点的内存中可以存储TB级的数据。也就是说，只要有足够多的节点，就可以存储足够多的数据。</p><p>与<code>复制</code>模式不同，它更新是很昂贵的，因为集群内的每个节点都需要更新，而分区模式更新就很廉价，因为对于每个键只需要更新一个主节点（可选择一个或者多个备份节点），不过读取变得较为昂贵，因为只有特定节点才持有缓存的数据。</p><p>为了避免额外的数据移动，总是访问恰好缓存有要访问的数据的节点是很重要的，这个方法叫做<code>关联并置</code>，当工作在分区化缓存时强烈建议使用。</p><pre><code>分区化缓存适合于数据量很大而更新频繁的场合。</code></pre><h2>基线拓扑</h2><p>基线拓扑是一组Ignite服务端节点，目的是同时在内存以及原生持久化中存储数据。基线拓扑中的节点在功能方面不受限制，并且作为数据和计算的容器，在行为上也和普通的服务端节点一样。可以实现在各个节点的磁盘中平衡存放持久化数据。</p><p>在开启持久化之后，集群默认未激活，因此需要先激活集群，再对基线拓扑进行操作。</p><h2>注意事项</h2><ul><li>基线拓扑是实现分布式存储持久化数据的必要，而partition的缓存模式只是决定了内存数据在各个节点中的分布存放。</li><li>第一次启动集群时，要等所有节点都单独启动完成之后，再激活集群，才能把集群中所有节点加入到基线拓扑中。</li><li>可以通过<code>control.sh</code>来堆基线拓扑进行操作，添加节点/删除节点。也可通过代码来进行操作:</li></ul><blockquote><blockquote></blockquote></blockquote><pre><code>Ignite ignite = Ignition.start();ignite.cluster().active(true);Collection&lt;ClusterNode&gt; nodes = ignite.cluster().forServers().nodes();ignite.cluster().setBaselineTopology(nodes);</code></pre><h1>ignite数据平衡分布的实践场景</h1><p>内存缓存模式<code>CacheMode</code>使用<code>分区</code>，保证数据在各个节点的内存中缓存起来。</p><ul><li><p>第一次环境部署，所有节点要单独启动，所有节点启动完成之后调用激活集群接口，ignite自动将所有节点集群，并且初始化基线拓扑，把所有节点都在基线拓扑变为上线状态。</p></li><li><p>集群中所有节点挂掉，即所有节点在基线拓扑中处于下线状态，这时候启动其中一个节点会自动从原先的基线拓扑中变为上线状态，后续其他节点也是，然后触发数据平衡。</p></li><li><p>集群中单个节点挂掉，即在基线拓扑中处于下线状态，那直接启动这个节点就行，会自动从原先的基线拓扑中上线然后数据平衡</p></li><li><p>要把新节点加入到已激活的集群，并且加入到集群中的基线拓扑中的话，要调用激活集群接口（接口ip是当前节点或者是集群中任意一个节点的都可以），或者使用<code>./control.sh --baseline add</code>命令加入集群的基线拓扑后，集群会把部分数据分布到新节点中去</p></li><li><p>要把下线节点从集群中删去，并确认不再需要这个节点，也不需要这个节点里面的数据，则把当前节点shutdown掉，然后重新调用激活集群接口即可，同时该节点也无法持有旧数据重新加入集群中。（危险操作）</p></li></ul><h1>日志示例</h1><h2>加入新节点前</h2><p><img src="/2019/09/23/ignite踩坑录-3-数据平衡分布/001.png" title="图片"></p><h2>加入新节点</h2><p><img src="/2019/09/23/ignite踩坑录-3-数据平衡分布/002.png" title="图片"></p><h2>加入新节点后，尚未激活的集群</h2><p><img src="/2019/09/23/ignite踩坑录-3-数据平衡分布/003.png" title="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;为什么需要数据平衡分布&lt;/h1&gt;
&lt;p&gt;在一个集群的环境中，我们往往希望能更好的利用分布式的优势，把数据平衡分布在各个节点中，这样有几个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这样才能缓存/持久化更多的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;即使其中一个节点down
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://hhbbz.github.io/tags/Java/"/>
    
      <category term="Ignite" scheme="https://hhbbz.github.io/tags/Ignite/"/>
    
      <category term="分布式" scheme="https://hhbbz.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ignite踩坑录(2) 节点集群</title>
    <link href="https://hhbbz.github.io/2019/07/13/ignite%E8%B8%A9%E5%9D%91%E5%BD%95-2-%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4/"/>
    <id>https://hhbbz.github.io/2019/07/13/ignite踩坑录-2-节点集群/</id>
    <published>2019-07-13T03:26:25.000Z</published>
    <updated>2019-09-25T02:50:44.318Z</updated>
    
    <content type="html"><![CDATA[<h1>Ignite的天然支持分布式</h1><p>Ignite具有非常先进的集群能力，包括逻辑集群组和自动发现。Ignite是一个以内存为中心的分布式数据库，通过DiscoverySpi节点可以彼此发现对方，而且提供了TcpDiscoverySpi作为DiscoverySpi的默认实现，它使用TCP/IP来作为节点发现的实现，可以配置成基于组播的或者基于静态IP的。所以在同一个网络内的ignite节点都会天然的自动的互相发现。如下图所示</p><p><img src="/2019/07/13/ignite踩坑录-2-节点集群/001.png" title="图片"></p><blockquote><p>第一坑：如果服务器中无法使用root账户，或者不是使用root账号进行ignite的启动的话，ignite节点之间是无法自动互相发现的，这时候需要使用TcpDiscoveryVmIpFinder来指定url和端口，去进行集群处理。</p></blockquote><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IgniteConfiguration cfg = <span class="keyword">new</span> IgniteConfiguration();</span><br><span class="line">TcpDiscoverySpi spi = <span class="keyword">new</span> TcpDiscoverySpi();</span><br><span class="line">TcpDiscoveryVmIpFinder ipFinder = <span class="keyword">new</span> TcpDiscoveryVmIpFinder();</span><br><span class="line"><span class="comment">// Set initial IP addresses.</span></span><br><span class="line"><span class="comment">// Note that you can optionally specify a port or a port range.</span></span><br><span class="line">ipFinder.setAddresses(igniteProperties().getClusterAddrList());</span><br><span class="line">spi.setIpFinder(ipFinder);</span><br><span class="line"><span class="comment">// Override default discovery SPI.</span></span><br><span class="line">cfg.setDiscoverySpi(spi);</span><br></pre></td></tr></table></figure></p><h2>Ignite节点之间的数据平衡</h2><blockquote><p>第二坑：通过上面TcpDiscoveryVmIpFinder这种指定集群的发现方式，我们会发现持久化的数据全部都存在了指定地址列表的节点中，当前机器自身的节点是不会有持久化的数据保存进来的。即数据无法平衡分布在各个节点中。</p></blockquote><p>原因在官方文档中有写：</p><blockquote><p>TcpDiscoveryVmIpFinder默认用的是非共享模式，如果希望启动一个服务端节点，那么在该模式中的IP地址列表同时也要包含本地节点的一个IP地址。它允许节点不等待其它节点加入集群，而是成为第一个集群节点并正常运行</p></blockquote><p>所以我们的解决方案是：给每一个集群节点都配上<strong>基线拓扑</strong>。</p><h3>基线拓扑主要概念</h3><ol><li>如果启用了原生持久化，Ignite引入了一个基线拓扑的概念，它表示集群中将数据持久化到磁盘的一组服务端节点。</li><li>基线拓扑是一组Ignite服务端节点，目的是同时在内存以及原生持久化中存储数据。基线拓扑中的节点在功能方面不受限制，并且作为数据和计算的容器，在行为上也和普通的服务端节点一样。</li></ol><p>简单来说就是，基线拓扑可以让集群中的每个节点都有持久化存储的能力。</p><p>配置基线拓扑的代码也非常简单：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Ignite ignite = Ignition.start();</span><br><span class="line"><span class="keyword">if</span>(!ignite.cluster().active())&#123;</span><br><span class="line">    ignite.cluster().active(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用基线拓扑进行ignite集群</span></span><br><span class="line">Collection&lt;ClusterNode&gt; nodes = ignite.cluster().forServers().nodes();</span><br><span class="line"></span><br><span class="line">ignite.cluster().setBaselineTopology(nodes);</span><br></pre></td></tr></table></figure></p><p>使用基线拓扑之后，持久化数据就能在集群的各个节点中平衡分布了。</p><h1>Ignite的集群部署方式</h1><p>Ignite的部署模式非常的灵活，在实际的场景中可以针对实际需要采用不同的部署方式，下面做简单的总结和对比：</p><h2>独立式Ignite集群</h2><p>这种情况下，集群的部署完全独立于应用，这个集群可以用于分布式计算，分布式缓存，分布式服务等，这时应用以客户端模式接入集群进行相关的操作，大体是如下的部署模式：</p><p><img src="/2019/07/13/ignite踩坑录-2-节点集群/002.png" title="图片"></p><ul><li>优点：对已有的应用运行环境影响小，并且这个集群可以共享，为多个应用提供服务，对整个应用来说，额外增加了很多的计算和负载能力。</li><li>缺点：需要单独的一组机器，相对成本要高些，如果缓存操作并发不高或者计算不饱和，存在资源利用率低的情况。整体架构也变得复杂，维护成本也要高些。</li></ul><h2>嵌入式Ignite集群</h2><p>这种情况下，可以将必要的jar包嵌入已有应用的内部，利用Ignite的发现机制，自动建立集群，大体是如下的部署模式：</p><p><img src="/2019/07/13/ignite踩坑录-2-节点集群/003.png" title="图片"></p><ul><li>优点：无需额外增加机器，成本最低，Ignite可以和应用无缝集成，所有节点都为服务端节点，可以充分利用Ignite的丰富功能。这个模式可扩展性最好，简单增加节点即可快速扩充整个系统的计算和负载能力。</li><li>缺点：Ignite占用了服务器的部分资源，对应用整体性能有影响，可能需要进行有针对性的优化，应用更新时，集群可能需要重启，这时如果Ignite需要加载大量的数据，重启的时间可能变长，甚至无法忍受。</li></ul><h2>混合式Ignite集群</h2><p>这种情况下，将上述2种模式混合在一起，即同时增加机器部署独立集群，同时又将Ignite嵌入应用内部以服务端模式运行，通过逻辑集群组进行资源的分配，整体上形成更大的集群，大体是如下的部署模式：</p><p><img src="/2019/07/13/ignite踩坑录-2-节点集群/004.png" title="图片"></p><p>这种模式更为灵活，调优后能做到成本、功能、性能的平衡，综合效果最佳。这时可以将缓存的数据通过集群组部署到应用外部的节点上，这样可以避免频繁的冷启动导致缓存数据频繁的长时间加载，对于计算，也能够动态地充分利用所有计算节点的资源。</p><p><a href="https://my.oschina.net/liyuj/blog/651036" target="_blank" rel="noopener">Ignite的集群部署方式段落来源于</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Ignite的天然支持分布式&lt;/h1&gt;
&lt;p&gt;Ignite具有非常先进的集群能力，包括逻辑集群组和自动发现。
Ignite是一个以内存为中心的分布式数据库，通过DiscoverySpi节点可以彼此发现对方，而且提供了TcpDiscoverySpi作为DiscoverySp
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://hhbbz.github.io/tags/Java/"/>
    
      <category term="Ignite" scheme="https://hhbbz.github.io/tags/Ignite/"/>
    
      <category term="分布式" scheme="https://hhbbz.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Ignite踩坑录(1) 简介与持久化</title>
    <link href="https://hhbbz.github.io/2019/05/19/Ignite%E8%B8%A9%E5%9D%91%E5%BD%95-1-%E7%AE%80%E4%BB%8B%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://hhbbz.github.io/2019/05/19/Ignite踩坑录-1-简介与持久化/</id>
    <published>2019-05-19T06:07:35.000Z</published>
    <updated>2019-09-25T02:50:45.381Z</updated>
    
    <content type="html"><![CDATA[<h1>Ignite是什么</h1><ol><li>一个以内存为中心的分布式数据库、缓存和处理平台，可以在PB级数据中，以内存级的速度进行事务性、分析性以及流式负载的处理。</li><li>支持磁盘、第三方存储持久化数据。</li><li>在内存和磁盘上是同时支持ACID的，是一个强一致的系统，Ignite可以在整个拓扑的多台服务器上保持事务。</li><li>完整的SQL和键值支持。</li><li>数据的并置计算。</li><li>是一个弹性的、可水平扩展的分布式系统，它支持按需地添加和删除节点，Ignite还可以存储数据的多个副本，这样可以使集群从部分故障中恢复。</li></ol><h1>ignite服务端和客户端</h1><p>Ignite有一个可选的概念，就是客户端节点和服务端节点，服务端节点参与缓存、计算执行、流式处理等等，而原生的客户端节点提供了远程连接服务端的能力。Ignite原生客户端可以使用完整的Ignite API集合，包括近缓存、事务、计算、流、服务等等。所有的Ignite节点默认都是以服务端模式启动的，客户端模式需要显式地启用。可以通过IgniteConfiguration.setClientMode(...)属性配置一个节点，或者为客户端，或者为服务端。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IgniteConfiguration cfg = <span class="keyword">new</span> IgniteConfiguration();</span><br><span class="line"><span class="comment">// Enable client mode.</span></span><br><span class="line">cfg.setClientMode(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// Start Ignite in client mode.</span></span><br><span class="line">Ignite ignite = Ignition.start(cfg);</span><br></pre></td></tr></table></figure></p><p>Ignite的唯一特点是所有节点都是平等的。没有master节点或者server节点，也没有worker节点或者client节点，按照Ignite的观点所有节点都是平等的。但是，可以将节点配置成主节点，工作节点，或者客户端以及数据节点</p><h1>用Java来实现第一个Ignite应用</h1><p>如果不需要对IgniteConfiguration进行设置的话，我们直接以默认的参数进行启动就行，也就是一行代码：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ignite ignite = Ignition.start();</span><br></pre></td></tr></table></figure></p><p>这样就会以服务端节点的形式去启动一个ignite节点，然后加入到集群中。</p><blockquote><p>第一坑：如果以客户端/瘦客户端形式去启动，会无法根据业务去动态构建缓存，并且会因为ignite服务端节点中没有我们应用的代码，然后因为业务的配置出现classNotFoundException，所以这里我采用在应用中启动ignite服务端节点的做法。</p></blockquote><p>然后我们需要对这个ignite节点进行构建缓存,来进行缓存操作。</p><p>Person.class</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造cacheConfig,可根据业务需要去动态进行构建</span></span><br><span class="line">CacheConfiguration ccf = <span class="keyword">new</span> CacheConfiguration();</span><br><span class="line"><span class="comment">//注意这里最好设置一个统一的schema</span></span><br><span class="line">ccf.setSqlSchema(<span class="string">"public"</span>);</span><br><span class="line">ccf.setName(<span class="string">"cacheName"</span>);</span><br><span class="line">ccf.setCacheMode(PARTITIONED);</span><br><span class="line">ccf.setAtomicityMode(CacheAtomicityMode.ATOMIC);</span><br><span class="line">ccf.setBackups(<span class="number">1</span>);</span><br><span class="line">ignite.getOrCreateCache(ccf)</span><br></pre></td></tr></table></figure></p><blockquote><p>第二坑：如果不开启第三方持久化，并且没有配置QueryEntity的话，ignite不会进行自动建sql表，从而也就支持不了sql查询。如果开启持久化的话，最好给一个默认的schema去让ignite建表，如图：</p></blockquote><p><img src="/2019/05/19/Ignite踩坑录-1-简介与持久化/002.png" title="图片"></p><blockquote><p>第三坑：缓存配置一旦在集群中构建，便无法对其进行更新，如果确实有更新缓存配置的需要，只能通过destoryCache(),再createCache()的方法实现。</p></blockquote><p>下面列举构建一个开启第三方持久化的缓存配置例子：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="comment">//构造cacheConfig</span></span><br><span class="line">        CacheConfiguration ccf = <span class="keyword">new</span> CacheConfiguration();</span><br><span class="line">        ccf.setSqlSchema(<span class="string">"public"</span>);</span><br><span class="line">        ccf.setName(<span class="string">"person"</span>);</span><br><span class="line">        ccf.setCacheMode(PARTITIONED);</span><br><span class="line">        ccf.setAtomicityMode(CacheAtomicityMode.ATOMIC);</span><br><span class="line">       ccf.setWriteBehindEnabled(<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">// 持久化后写每批次写入数量</span></span><br><span class="line">       ccf.setWriteBehindBatchSize(<span class="number">10</span>);</span><br><span class="line">       <span class="comment">//触发持久化后写的新增数据数量</span></span><br><span class="line">       ccf.setWriteBehindFlushSize(<span class="number">10</span>);</span><br><span class="line">       <span class="comment">//持久化后写刷新频率，即每过多少毫秒就持久化一次</span></span><br><span class="line">       ccf.setWriteBehindFlushFrequency(<span class="number">10000</span>);</span><br><span class="line">       <span class="comment">//持久化后写使用线程数量</span></span><br><span class="line">       ccf.setWriteBehindFlushThreadCount(<span class="number">10</span>);</span><br><span class="line">       ccf.setReadThrough(<span class="keyword">true</span>);</span><br><span class="line">       ccf.setWriteThrough(<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">//构造持久化类</span></span><br><span class="line">       CacheJdbcPojoStoreFactory storeFactory = <span class="keyword">new</span> CacheJdbcPojoStoreFactory();</span><br><span class="line">       storeFactory.setDataSource(<span class="keyword">this</span>.dataSource);</span><br><span class="line">       storeFactory.setDialect(<span class="keyword">new</span> BasicJdbcDialect());</span><br><span class="line"></span><br><span class="line">       LinkedHashMap&lt;String,String&gt; fieldMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造字段列表</span></span><br><span class="line">       JdbcTypeField[] jdbcTypeFields = <span class="keyword">new</span> JdbcTypeField[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;jdbcTypeFields.length;i++)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//注意字段不要java的date类型，否则存不上数据库</span></span><br><span class="line">            <span class="comment">//4是数据库字段类型的编码</span></span><br><span class="line">           jdbcTypeFields[i] = <span class="keyword">new</span> JdbcTypeField(<span class="number">4</span></span><br><span class="line">                   ,<span class="string">"fieldName"</span></span><br><span class="line">                   ,Integer.class</span><br><span class="line">                   ,<span class="string">"fieldName"</span>);</span><br><span class="line">           fieldMap.put(<span class="string">"fieldName"</span>,<span class="string">"Integer"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">       <span class="comment">//构造jdbc字段映射</span></span><br><span class="line">       JdbcType jdbcType = <span class="keyword">new</span> JdbcType();</span><br><span class="line">       jdbcType.setCacheName(<span class="string">"person"</span>);</span><br><span class="line">       jdbcType.setKeyType(Integer.class);</span><br><span class="line">       jdbcType.setValueType(Person.class);</span><br><span class="line"><span class="comment">//        jdbcType.setDatabaseSchema(SQL_SCHEMA);</span></span><br><span class="line">       jdbcType.setDatabaseTable(<span class="string">"person"</span>);</span><br><span class="line">       jdbcType.setKeyFields(<span class="keyword">new</span> JdbcTypeField(<span class="number">4</span></span><br><span class="line">                   ,<span class="string">"fieldName"</span></span><br><span class="line">                   ,Integer.class</span><br><span class="line">                   ,<span class="string">"fieldName"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       jdbcType.setValueFields(jdbcTypeFields);</span><br><span class="line">       storeFactory.setTypes(jdbcType);</span><br><span class="line">        ccf.setBackups(<span class="number">1</span>);</span><br><span class="line">       ccf.setCacheStoreFactory(storeFactory);</span><br><span class="line">        <span class="comment">//会在ignite自动建表，并对持久化支持</span></span><br><span class="line">       QueryEntity queryEntity = <span class="keyword">new</span> QueryEntity();</span><br><span class="line">       queryEntity.setTableName(tableName);</span><br><span class="line">       queryEntity.setKeyType(<span class="string">"java.lang.Integer"</span>);</span><br><span class="line">       queryEntity.setValueType(<span class="string">"model.person"</span>);</span><br><span class="line">       queryEntity.setKeyFieldName(<span class="string">"id"</span>);</span><br><span class="line">       queryEntity.setKeyFields(Collections.singleton(<span class="string">"id"</span>));</span><br><span class="line">       queryEntity.setFields(fieldMap);</span><br><span class="line">       ccf.setQueryEntities(Collections.singleton(queryEntity));</span><br><span class="line">       ignite.getOrCreateCache(ccf);</span><br></pre></td></tr></table></figure></p><p>然后就可以使用构建的缓存进行操作啦</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行select语句查询并获取返回结果</span></span><br><span class="line">Map&lt;String, Object&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// Getting a reference to an underlying cache created for table.</span></span><br><span class="line">IgniteCache&lt;Integer, Person&gt; cache = igniteEngine.getOrCreateCacheByCacheName(<span class="string">"person"</span>);</span><br><span class="line"><span class="comment">// Querying data from the cluster using a distributed JOIN.</span></span><br><span class="line">FieldsQueryCursor&lt;List&lt;?&gt;&gt; cursor = cache.query(<span class="keyword">new</span> SqlFieldsQuery(<span class="string">"select * from person"</span>).setSchema(<span class="string">"public"</span>));</span><br><span class="line">Iterator&lt;List&lt;?&gt;&gt; iterator = cursor.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    List&lt;?&gt; row = iterator.next();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; cursor.getColumnsCount(); i++) &#123;</span><br><span class="line">        result.put(cursor.getFieldName(i).toLowerCase(), row.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行kv操作</span></span><br><span class="line">IgniteCache&lt;Integer, Person&gt; cache = igniteEngine.getOrCreateCacheByCacheName(<span class="string">"person"</span>);</span><br><span class="line">Person person = cache.get(<span class="number">1</span>);</span><br><span class="line">person.setName(<span class="string">"hhbbz"</span>);</span><br><span class="line">cache.put(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行insert/update语句</span></span><br><span class="line">IgniteCache&lt;String, Map&lt;String, Object&gt;&gt; cache = igniteEngine.getOrCreateCacheByCacheName(<span class="string">"person"</span>));</span><br><span class="line"><span class="comment">//执行sql</span></span><br><span class="line">cache.query(<span class="keyword">new</span> SqlFieldsQuery(builder.toString()).setSchema(<span class="string">"public"</span>)).getAll();</span><br></pre></td></tr></table></figure></p><h1>后写缓存持久化的坑</h1><h2>后写缓存是什么</h2><p>在一个简单的通写模式中每个缓存的put和remove操作都会涉及一个持久化存储的请求，因此整个缓存更新的持续时间可能是相对比较长的。另外，密集的缓存更新频率也会导致非常高的存储负载。</p><p>对于这种情况，Ignite提供了一个选项来执行异步化的持久化存储更新，也叫做后写，这个方式的主要概念是累加更新操作然后作为一个批量操作异步化地刷入持久化存储中。真实的数据持久化可以被基于时间的事件触发（数据输入的最大时间受到队列的限制），也可以被队列的大小触发（当队列大小达到一个限值），或者通过两者的组合触发，这时任何事件都会触发刷新。</p><blockquote><p>更新顺序</p></blockquote><blockquote><p>对于后写的方式只有数据的最后一次更新会被写入底层存储。如果键为key1的缓存数据分别依次地更新为值value1、value2和value3，那么只有(key1,value3)对这一个存储请求会被传播到持久化存储。</p></blockquote><blockquote><p>更新性能</p></blockquote><blockquote><p>批量的存储操作通常比按顺序的单一存储操作更有效率，因此可以通过开启后写模式的批量操作来利用这个特性。简单类型（put和remove）的简单顺序更新操作可以被组合成一个批量操作。比如，连续地往缓存中加入(key1,value1),(key2,value2),(key3,value3)可以通过一个单一的CacheStore.putAll(...)操作批量处理。</p></blockquote><h2>这也是我遇到的第四个坑：</h2><p>交代一下背景：</p><p>我整个项目中全部使用sql去对ignite进行缓存操作。当我使用CacheJdbcPojoStoreFactory做第三方存储持久化的时候，在大批量数据操作时，持久化总是会卡顿，很慢，并且会阻塞正常的内存操作。虽然官方文档说后写缓存是异步化的持久化存储更新，但是我也没懂为什么会阻塞我正常的内存操作。</p><p>于是研究了几天后，经过各种猜测和反复实践，笔者所猜测的原因是：</p><blockquote><p>在持久化过程中，涉及到更新操作时候，ignite会在第三方存储表中先进行select，再进行update，这样的话，在大批量数据操作时，会造成大量的数据库死锁从而导致性能下降，使得阻塞持久化过程，这是异步持久化的阻塞。</p></blockquote><p>那么为什么会阻塞正常的内存操作的？</p><p>笔者所猜测的原因是：</p><blockquote><p>当上一次持久化的数据还没全部插入到库表中时，就会阻塞ignite的内存操作了。举个例子就是，比如上一轮持久化的数据中，有“19岁”这个数据，这时候“19岁”这一条数据只存在内存中，还没保存到库表里，因为后写是批量的，假如我后写的batchsize是1000，那么这时候就已经构造好了1000条数据的批量insert/update语句，如果刚好“19岁”这条数据就在这1000条构造好update语句的数据里面，此时又在内存中把“19岁”update成“20岁”，并且再次触发持久化，那就得等待后写的批量轮询逻辑把“19岁”这个数据持久化到库表中为止，也因为这样，刚好就能解释为什么有些持久化update很快，有些却会卡住，都是取决于持久化update的那条数据是不是处于后写的batchsize的批量数据中。</p></blockquote><p>当然也可能是上面说的更新顺序的原因。</p><h1>总结</h1><p>总的来说，我是对ignite的持久化不太满意的，也有可能是因为我实践不当吧，如果有什么错误的操作或者判断，欢迎邮箱指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Ignite是什么&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;一个以内存为中心的分布式数据库、缓存和处理平台，可以在PB级数据中，以内存级的速度进行事务性、分析性以及流式负载的处理。&lt;/li&gt;
&lt;li&gt;支持磁盘、第三方存储持久化数据。&lt;/li&gt;
&lt;li&gt;在内存和磁盘上是同时支持ACID
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://hhbbz.github.io/tags/Java/"/>
    
      <category term="Ignite" scheme="https://hhbbz.github.io/tags/Ignite/"/>
    
      <category term="分布式" scheme="https://hhbbz.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>jdbcTemplate高效率获取表结构，数据库元数据信息</title>
    <link href="https://hhbbz.github.io/2019/03/31/jdbcTemplate%E9%AB%98%E6%95%88%E7%8E%87%E8%8E%B7%E5%8F%96%E8%A1%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%83%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF/"/>
    <id>https://hhbbz.github.io/2019/03/31/jdbcTemplate高效率获取表结构，数据库元数据信息/</id>
    <published>2019-03-31T03:44:12.000Z</published>
    <updated>2019-03-31T07:40:32.307Z</updated>
    
    <content type="html"><![CDATA[<h1>场景</h1><p>在项目中需要通过表名来获取数据库中元数据相关信息，比如表名，字段名，长度等使用spring自带的jdbcTemplate 可以通过SqlRowSetMetaData 可以获取到部分元数据，但是不能获取备注信息（comment中的内容）</p><h1>最简单的解决方案</h1><p>使用jdbcTemplate的queryForRowSet方法。</p><p>该方法很简单</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SqlRowSet sqlRowSet ;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sqlRowSet = <span class="keyword">this</span>.jdbcTemplate.queryForRowSet(sql.toString());</span><br><span class="line">    <span class="comment">//获取字段列</span></span><br><span class="line">    SqlRowSetMetaData rowSetMetaData = sqlRowSet.getMetaData();</span><br><span class="line">    <span class="comment">//获取列总数</span></span><br><span class="line">    <span class="keyword">int</span> columnCount = rowSetMetaData.getColumnCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">        rowSetMetaData.getColumnName(i);</span><br><span class="line">        rowSetMetaData.getColumnType(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>但是此方案存在严重的效率问题，10W的结果集数据，37个字段，24核cpu，基本没30s都返回不过来，占用内存也极高。</p></blockquote><p>进行debug跟进去看，看到jdbcTemplate调用jdbc返回ResultSet只用了10秒左右，之后就一直耗在extractData方法里。该方法是用默认的RowMapper，先取得MetaData然后根据这个去生成Map。</p><h1>对比方法</h1><ol><li><p>使用纯jdbc对比，手工码代码，直接调用Map的put方法逐个生成Map并填充数据。同样的sql，耗时8秒左右，其中根据ResultSet生成List&lt;Map&lt;String, Object&gt;&gt;的过程不超过10s。</p></li><li><p>改用jdbcTemplate的public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper)方法，T填入Map&lt;String, Object&gt;，这样就跟queryForList方法返回值一样了，然后自己实现RowMapper，直接用Map的put方法填充数据。实验结果跟直接用纯jdbc效率相同。</p></li><li><p>使用纯jdbc，自己写一个实体类，把resultSet里的数据循环填入对象放到List里。耗时也差不多8s，不过还是会省一点内存的。但是性能提升有限。</p></li></ol><h1>最优解决方案</h1><p>只需要通过jdbcTemplate获取jdbc Connection即可获取全部信息。</p><p>代码示例如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sql = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sql.append(<span class="string">"SELECT *"</span>);</span><br><span class="line">sql.append(<span class="string">" FROM "</span>).append(tableCode);</span><br><span class="line">ResultSet tabs;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    DatabaseMetaData dbMetaData = <span class="keyword">this</span>.jdbcTemplate.getDataSource().getConnection().getMetaData();</span><br><span class="line">    String[] types = &#123;<span class="string">"TABLE"</span>&#125;;</span><br><span class="line">    tabs = dbMetaData.getTables(<span class="keyword">null</span>, <span class="keyword">null</span>, tableCode, types);</span><br><span class="line">    <span class="keyword">while</span> (tabs.next()) &#123;</span><br><span class="line">        String tableName = tabs.getString(<span class="string">"TABLE_NAME"</span>);</span><br><span class="line">        <span class="comment">//表对应的schema</span></span><br><span class="line">        String tableSchema = tabs.getString(<span class="string">"TABLE_SCHEM"</span>);</span><br><span class="line">        ResultSet resultSet = dbMetaData.getColumns(<span class="keyword">null</span>, schema, tableName, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            String name = resultSet.getString(<span class="string">"COLUMN_NAME"</span>);</span><br><span class="line">            String type = resultSet.getString(<span class="string">"TYPE_NAME"</span>);</span><br><span class="line">            String colRemarks = resultSet.getString(<span class="string">"REMARKS"</span>);</span><br><span class="line">            <span class="keyword">int</span> size = resultSet.getInt(<span class="string">"COLUMN_SIZE"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//业务逻辑</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>经过测试，同样的10w+数据，37个字段，加上我写的业务逻辑也只需要700ms的响应时间，效率可谓是大大提升。</p></blockquote><p>我觉得该方法效率得到提升的原因在于，它没有对全表进行扫描，不关乎结果集的多少，只在乎表结构，所以可以极大的提高响应效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;场景&lt;/h1&gt;
&lt;p&gt;在项目中需要通过表名来获取数据库中元数据相关信息，比如表名，字段名，长度等
使用spring自带的jdbcTemplate 可以通过SqlRowSetMetaData 可以获取到部分元数据，但是不能获取备注信息（comment中的内容）&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://hhbbz.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://hhbbz.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>升级ES6.x遇到的坑和解决方案</title>
    <link href="https://hhbbz.github.io/2019/03/10/%E5%8D%87%E7%BA%A7ES6-x%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://hhbbz.github.io/2019/03/10/升级ES6-x遇到的坑和解决方案/</id>
    <published>2019-03-10T07:36:10.000Z</published>
    <updated>2019-03-10T08:30:02.981Z</updated>
    
    <content type="html"><![CDATA[<h1>问题描述</h1><p>这星期公司要把es5.x升级到es6.x，因为是一个大版本的升级，所以坑肯定是不可避免的，详细的变更可以通过链接了解。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.6/es-release-notes.html" target="_blank" rel="noopener">ES各版本变更信息</a>。</p><p>这里我主要讲对我有较大影响的两个地方：</p><ol><li><p>ES官方建议通过Java Low Level REST Client来访问Elasticsearch，不建议通过TransportClient来访问。</p></li><li><p>ES6.x起，同个_index不再支持多个_type.</p></li><li><p>ES6.x起，可以支持使用sql进行查询。</p></li></ol><h1>使用REST Client</h1><p>ES官方已不建议通过TransportClient来访问Elasticsearch，使用TransportClient 5.5.3版在建立连接时会报 NoNodeAvailableException 问题，并且ES官方已经不再维护TransportClient。如果已经使用并且有提示报错，可用以下方法绕过：</p><ul><li>建议换成<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-low.html" target="_blank" rel="noopener">Java Low Level REST Client</a>来访问Elasticsearch。</li><li>在Java maven项目的POM配置文件中，使用 x-pack-transport-5.3.3 版client进行访问，并且POM配置文件中的elasticsearch版本也必须为5.3.3版，不建议通过该方案来绕着实现，不保证能完全兼</li></ul><p>Java Low Level REST Client示例代码</p><ul><li>{USER NAME}：替换为访问ES实例对应用户名。</li><li>{PASSWORD}：替换为访问ES实例指定用户对应密码。</li><li>{HOST}:替换为ES实例基本信息界面中的内网或外网地址。</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestClientTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> RequestOptions COMMON_OPTIONS;</span><br><span class="line">        <span class="keyword">final</span> CredentialsProvider credentialsProvider = <span class="keyword">new</span> BasicCredentialsProvider();</span><br><span class="line">        <span class="comment">//设置用户名密码</span></span><br><span class="line">        credentialsProvider.setCredentials(AuthScope.ANY,</span><br><span class="line">                <span class="keyword">new</span> UsernamePasswordCredentials(<span class="string">"&#123;USER NAME&#125;"</span>, <span class="string">"&#123;PASSWORD&#125;"</span>));</span><br><span class="line">        RestClient restClient = RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"&#123;HOST&#125;"</span>, <span class="number">9200</span>))</span><br><span class="line">                .setHttpClientConfigCallback(<span class="keyword">new</span> RestClientBuilder.HttpClientConfigCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> HttpAsyncClientBuilder <span class="title">customizeHttpClient</span><span class="params">(HttpAsyncClientBuilder httpClientBuilder)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).build();</span><br><span class="line">        <span class="comment">//如果需要构造Authorization，在下面request.setOptions();</span></span><br><span class="line">        RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder();</span><br><span class="line">        builder.setHttpAsyncResponseConsumerFactory(</span><br><span class="line">            <span class="keyword">new</span> HttpAsyncResponseConsumerFactory</span><br><span class="line">                .HeapBufferedResponseConsumerFactory(<span class="number">104857600</span>));</span><br><span class="line">        builder.addHeader(<span class="string">"Authorization"</span>, <span class="string">"Bearer "</span> + <span class="string">"123456"</span>);</span><br><span class="line">        COMMON_OPTIONS = builder.build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//index a document</span></span><br><span class="line">            HttpEntity entity = <span class="keyword">new</span> NStringEntity(<span class="string">"&#123;\n\"user\" : \"hhbbz\"\n&#125;"</span>, ContentType.APPLICATION_JSON);</span><br><span class="line">            Response indexResponse = restClient.performRequest(</span><br><span class="line">                    <span class="string">"PUT"</span>,</span><br><span class="line">                    <span class="string">"/school/user/123"</span>,</span><br><span class="line">                    Collections.&lt;String, String&gt;emptyMap(),</span><br><span class="line">                    entity);</span><br><span class="line">            <span class="comment">//search a document</span></span><br><span class="line">            Response response = restClient.performRequest(<span class="string">"GET"</span>, <span class="string">"/school/user/123"</span>,</span><br><span class="line">                    Collections.singletonMap(<span class="string">"pretty"</span>, <span class="string">"true"</span>));</span><br><span class="line">            System.out.println(EntityUtils.toString(response.getEntity()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一般来说REST Client的相关api是不足以满足我们日常使用ES的操作的，所以我们需要使用RestHighLevelClient进行更多样化的操作。可以参考下面文档进行使用。</p><p><a href="https://my.oschina.net/GinkGo/blog/1853345#h1_1" target="_blank" rel="noopener">RestHighLevelClient中文文档</a></p><p><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html" target="_blank" rel="noopener">RestHighLevelClient英文官方文档</a></p><h1>一个_index不能有多个_type</h1><h2>原因分析</h2><p>官方给出了一些说法，这里也总结下，无非就是以下几点：</p><ol><li><p>将 index , doc_type 类比为 RDBMS 的 db , table 这个出发点本身就是不对的。</p></li><li><p>除了造成初学者的困惑，另外一个原因就是，在传统db中，不同的表中可以有相同命名但是不同数据类型、不同含义的字段，但是到了es中，这就麻烦了。</p></li></ol><p>假设你有一个索引名叫做blog，其中 type 为 <strong>user</strong> 的 <strong>deleted</strong> 字段类型为boolean，又想在type为 <strong>articles</strong> 的 <strong>deleted</strong> 创建字段类型为date，那么你就麻烦了，ES是不允许这样做的。究其原因是因为，在 Lucene 底层实现上，同一索引的不同type中的相同字段，存储结构都是相同的。</p><p>最重要的是，在同一索引中存储具有少量或不共有字段的不同实体，会导致数据稀疏，并干扰Lucene高效压缩文档的能力。</p><h2>兼容方案</h2><p>官方有给出兼容的方案，就是通过reindex的方式来将现有数据中的_type字段数据转移到type字段中存储。</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"source"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"old"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dest"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"new"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"script"</span>: &#123;</span><br><span class="line">    <span class="attr">"inline"</span>: <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    ctx._id = ctx._type + "</span>-<span class="string">" + ctx._id;</span></span><br><span class="line"><span class="string">    ctx._source.type = ctx._type;</span></span><br><span class="line"><span class="string">    ctx._type = "</span>doc<span class="string">";</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这会将特殊的“_type”字段移动到“type”，然后您可以在后续过滤，聚合等中使用它。</p><h2>后续开发解决方案</h2><p>建议在文档中手动添加一个字段为 type，在查询的时候匹配即可，至于_type字段的内容，给个默认值就行。</p><h1>SQL查询的支持</h1><p>在ES6.x中，我们可以使用SQL来进行查询数据，ES引擎内部会把SQL转换成DSL的。</p><p>DSL示例代码：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /_xpack/sql?format=json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: <span class="string">"SELECT * FROM library ORDER BY page_count DESC LIMIT 5"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回值</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="attr">"columns"</span>: [</span><br><span class="line">         &#123;<span class="attr">"name"</span>: <span class="string">"author"</span>,       <span class="attr">"type"</span>: <span class="string">"text"</span>&#125;,</span><br><span class="line">         &#123;<span class="attr">"name"</span>: <span class="string">"name"</span>,         <span class="attr">"type"</span>: <span class="string">"text"</span>&#125;,</span><br><span class="line">         &#123;<span class="attr">"name"</span>: <span class="string">"page_count"</span>,   <span class="attr">"type"</span>: <span class="string">"short"</span>&#125;,</span><br><span class="line">         &#123;<span class="attr">"name"</span>: <span class="string">"release_date"</span>, <span class="attr">"type"</span>: <span class="string">"date"</span>&#125;</span><br><span class="line">     ],</span><br><span class="line">     <span class="attr">"rows"</span>: [</span><br><span class="line">         [<span class="string">"Peter F. Hamilton"</span>,  <span class="string">"Pandora's Star"</span>,       <span class="number">768</span>, <span class="string">"2004-03-02T00:00:00.000Z"</span>],</span><br><span class="line">         [<span class="string">"Vernor Vinge"</span>,       <span class="string">"A Fire Upon the Deep"</span>, <span class="number">613</span>, <span class="string">"1992-06-01T00:00:00.000Z"</span>],</span><br><span class="line">         [<span class="string">"Frank Herbert"</span>,      <span class="string">"Dune"</span>,                 <span class="number">604</span>, <span class="string">"1965-06-01T00:00:00.000Z"</span>],</span><br><span class="line">         [<span class="string">"Alastair Reynolds"</span>,  <span class="string">"Revelation Space"</span>,     <span class="number">585</span>, <span class="string">"2000-03-15T00:00:00.000Z"</span>],</span><br><span class="line">         [<span class="string">"James S.A. Corey"</span>,   <span class="string">"Leviathan Wakes"</span>,      <span class="number">561</span>, <span class="string">"2011-06-02T00:00:00.000Z"</span>]</span><br><span class="line">     ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>REST Client示例代码：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"SELECT * FROM school"</span>;</span><br><span class="line">Request request = <span class="keyword">new</span> Request(<span class="string">"POST"</span>, <span class="string">"/_xpack/sql?format=json"</span>);</span><br><span class="line">HttpEntity entity = <span class="keyword">new</span> NStringEntity(<span class="string">"&#123;\"query\": \""</span> + sql + <span class="string">"\"&#125;"</span>, ContentType.APPLICATION_JSON);</span><br><span class="line">request.setEntity(entity);</span><br><span class="line">Response response = restClient.performRequest(request);</span><br><span class="line">System.out.println(EntityUtils.toString(response.getEntity()));</span><br></pre></td></tr></table></figure></p><p>支持的SQL函数只有链接里面这一些，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.6/sql-syntax-show-functions.html" target="_blank" rel="noopener">ES支持的SQL函数</a></p><p>具体的有关SQL的支持，可以通过查看官方文档来进行了解：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.6/xpack-sql.html" target="_blank" rel="noopener">ES对SQL的支持</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;问题描述&lt;/h1&gt;
&lt;p&gt;这星期公司要把es5.x升级到es6.x，因为是一个大版本的升级，所以坑肯定是不可避免的，详细的变更可以通过链接了解。&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://hhbbz.github.io/tags/Java/"/>
    
      <category term="Elasticsearch" scheme="https://hhbbz.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor初步使用</title>
    <link href="https://hhbbz.github.io/2019/02/17/Disruptor%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/"/>
    <id>https://hhbbz.github.io/2019/02/17/Disruptor初步使用/</id>
    <published>2019-02-17T05:17:03.000Z</published>
    <updated>2019-02-17T05:54:55.587Z</updated>
    
    <content type="html"><![CDATA[<h1>背景介绍</h1><p>最近在作一个用于调用第三方服务以及充当数据仓储的服务，对于数据的存储和获取都要有很好的响应。整体架构使用的是spring flux作接口层的异步调用，可以高效率的进行数据获取；使用Disruptor作为内存队列，将存储数据批量写入。</p><h1>为什么选择Disruptor</h1><p>Disruptor是用于一个JVM中多个线程之间的消息队列，作用与ArrayBlockingQueue有相似之处，但是Disruptor通过精巧的无锁设计实现了在高并发情形下的高性能。从功能、性能都远好于ArrayBlockingQueue，当多个线程之间传递大量数据或对性能要求较高时，可以考虑使用Disruptor作为ArrayBlockingQueue的替代者。</p><h2>为什么Disruptor会那么快</h2><p>Disruptor通过以下设计来解决队列速度慢的问题： - 环形数组结构</p><p>为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。 - 元素位置定位</p><p>数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。 - 无锁设计</p><p>每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。</p><h1>Disruptor的使用</h1><p>代码实现的功能：每10ms向disruptor中插入一个元素，消费者读取数据，并打印到终端。详细逻辑请细读代码。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> disruptor代码样例。每10ms向disruptor中插入一个元素，消费者读取数据，并打印到终端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.*;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.dsl.Disruptor;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.dsl.ProducerType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisruptorMain</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 队列中的元素</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.value= value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者的线程工厂</span></span><br><span class="line">        ThreadFactory threadFactory = <span class="keyword">new</span> ThreadFactory()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"simpleThread"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RingBuffer生产工厂,初始化RingBuffer的时候使用</span></span><br><span class="line">        EventFactory&lt;Element&gt; factory = <span class="keyword">new</span> EventFactory&lt;Element&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Element <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Element();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理Event的handler</span></span><br><span class="line">        EventHandler&lt;Element&gt; handler = <span class="keyword">new</span> EventHandler&lt;Element&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Element element, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Element: "</span> + element.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞策略</span></span><br><span class="line">        BlockingWaitStrategy strategy = <span class="keyword">new</span> BlockingWaitStrategy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定RingBuffer的大小</span></span><br><span class="line">        <span class="keyword">int</span> bufferSize = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建disruptor，采用单生产者模式</span></span><br><span class="line">        Disruptor&lt;Element&gt; disruptor = <span class="keyword">new</span> Disruptor(factory, bufferSize, threadFactory, ProducerType.SINGLE, strategy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置EventHandler</span></span><br><span class="line">        disruptor.handleEventsWith(handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动disruptor的线程</span></span><br><span class="line">        disruptor.start();</span><br><span class="line"></span><br><span class="line">        RingBuffer&lt;Element&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; <span class="keyword">true</span>; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取下一个可用位置的下标</span></span><br><span class="line">            <span class="keyword">long</span> sequence = ringBuffer.next();  </span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 返回可用位置的元素</span></span><br><span class="line">                Element event = ringBuffer.get(sequence); </span><br><span class="line">                <span class="comment">// 设置该位置元素的值</span></span><br><span class="line">                event.set(l); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                ringBuffer.publish(sequence);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>总结</h1><p>Disruptor通过精巧的无锁设计实现了在高并发情形下的高性能。</p><p>在美团内部，很多高并发场景借鉴了Disruptor的设计，减少竞争的强度。其设计思想可以扩展到分布式场景，通过无锁设计，来提升服务性能。</p><p>使用Disruptor比使用ArrayBlockingQueue略微复杂，为方便读者上手，增加代码样例。</p><p><a href="https://tech.meituan.com/2016/11/18/disruptor.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;背景介绍&lt;/h1&gt;
&lt;p&gt;最近在作一个用于调用第三方服务以及充当数据仓储的服务，对于数据的存储和获取都要有很好的响应。
整体架构使用的是spring flux作接口层的异步调用，可以高效率的进行数据获取；使用Disruptor作为内存队列，将存储数据批量写入。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://hhbbz.github.io/tags/Java/"/>
    
      <category term="MQ" scheme="https://hhbbz.github.io/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>ES5.x常用查询（javaAPI）</title>
    <link href="https://hhbbz.github.io/2018/11/04/ES5.x%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2%EF%BC%88javaAPI%EF%BC%89/"/>
    <id>https://hhbbz.github.io/2018/11/04/ES5.x常用查询（javaAPI）/</id>
    <published>2018-11-04T06:01:59.000Z</published>
    <updated>2019-03-10T07:38:44.959Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>java Elastic 客户端基本使用</p><h2>引入jar</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'org.elasticsearch:elasticsearch:5.5.0'</span></span><br><span class="line"></span><br><span class="line">compile <span class="string">'org.elasticsearch.client:transport:5.5.0</span></span><br></pre></td></tr></table></figure></p><h2>client基本使用</h2><h3>得到client</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Settings settings = Settings.builder().put(<span class="string">"cluster.name"</span>, <span class="string">"hbz-6-test"</span>).build();</span><br><span class="line">TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">client.addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br></pre></td></tr></table></figure></p><h3>关闭资源</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.close();</span><br></pre></td></tr></table></figure></p><pre><code>搜索关键字全部要小写</code></pre><h3>get得到指定index type id的数据</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareGet</span><span class="params">(TransportClient client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        GetResponse response = client.prepareGet(<span class="string">"mytest"</span>, <span class="string">"test"</span>, <span class="string">"p1"</span>).get();</span><br><span class="line">        System.out.println(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>output:</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_index"</span>:<span class="string">"mytest"</span>,</span><br><span class="line">    <span class="attr">"_type"</span>:<span class="string">"test"</span>,</span><br><span class="line">    <span class="attr">"_id"</span>:<span class="string">"p1"</span>,</span><br><span class="line">    <span class="attr">"_version"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"found"</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"_source"</span>:&#123;</span><br><span class="line">        <span class="attr">"name"</span>:<span class="string">"mac Book 笔记本"</span>,</span><br><span class="line">        <span class="attr">"price"</span>:<span class="number">1233</span>,</span><br><span class="line">        <span class="attr">"description"</span>:<span class="string">"这是笔记本"</span>,</span><br><span class="line">        <span class="attr">"cats"</span>:[</span><br><span class="line">            <span class="string">"3c"</span>,</span><br><span class="line">            <span class="string">"computer"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>insert添加数据</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(TransportClient client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; resource = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        resource.put(<span class="string">"name"</span>,<span class="string">"mac Note"</span>);</span><br><span class="line">        resource.put(<span class="string">"price"</span>,<span class="number">8877</span>);</span><br><span class="line">        resource.put(<span class="string">"description"</span>,<span class="string">"mac Note 新款"</span>);</span><br><span class="line">        IndexRequestBuilder index = client.prepareIndex(<span class="string">"mytest"</span>, <span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">        IndexResponse insertResponse = index.setSource(resource).execute().get();</span><br><span class="line"></span><br><span class="line">        System.out.println(insertResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>output:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IndexResponse[index=mytest,type=test,id=AV8CZmTgGnilLCUrybiV,version=<span class="number">1</span>,result=created</span><br><span class="line">,shards=&#123;<span class="string">"total"</span>:<span class="number">2</span>,<span class="string">"successful"</span>:<span class="number">1</span>,<span class="string">"failed"</span>:<span class="number">0</span>&#125;]</span><br></pre></td></tr></table></figure></p><h3>delete删除数据</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(TransportClient client)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BulkByScrollResponse response = DeleteByQueryAction.INSTANCE.newRequestBuilder(client)</span><br><span class="line">                .filter(QueryBuilders.matchQuery(<span class="string">"name"</span>, <span class="string">"mac"</span>)) <span class="comment">//搜索</span></span><br><span class="line">                .source(<span class="string">"mytest"</span>) <span class="comment">//index</span></span><br><span class="line">                .get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> deleted = response.getDeleted();</span><br><span class="line">       System.out.println(<span class="string">"删除个数: "</span>+deleted);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>update 修改数据</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(TransportClient client)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        data.put(<span class="string">"name"</span>,<span class="string">"new mac node"</span>);</span><br><span class="line"></span><br><span class="line">        UpdateRequest updateRequest =  <span class="keyword">new</span> UpdateRequest();</span><br><span class="line">        updateRequest.index(<span class="string">"mytest"</span>);</span><br><span class="line">        updateRequest.type(<span class="string">"test"</span>);</span><br><span class="line">        updateRequest.id(<span class="string">"AV8CfcSLGnilLCUryoEl"</span>);</span><br><span class="line"></span><br><span class="line">        updateRequest.doc(data);</span><br><span class="line"></span><br><span class="line">        UpdateResponse response = client.update(updateRequest).get();</span><br><span class="line">        System.out.println(response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>output:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UpdateResponse[index=mytest,type=test,id=AV8CfcSLGnilLCUryoEl,version=<span class="number">2</span>,result=updated,shards=ShardInfo&#123;total=<span class="number">2</span>, successful=<span class="number">1</span>, failures=[]&#125;]</span><br></pre></td></tr></table></figure></p><h3>MultiGet查询多个index</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">multiIndex</span><span class="params">(TransportClient client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MultiGetResponse multiGetItemResponses = client.prepareMultiGet()</span><br><span class="line">                .add(<span class="string">"mytest"</span>,<span class="string">"test"</span>,<span class="string">"AV8CfcSLGnilLCUryoEl"</span>) <span class="comment">//多个index</span></span><br><span class="line">                .add(<span class="string">"instestdb_business_log-2017.09"</span>,<span class="string">"instestdb_business_log"</span>,<span class="string">"AV7KHPtGDF9uyeK_lXln"</span>) <span class="comment">//多个index</span></span><br><span class="line">                .get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(MultiGetItemResponse itemResponses : multiGetItemResponses) &#123;</span><br><span class="line">            GetResponse response = itemResponses.getResponse();</span><br><span class="line">            <span class="keyword">if</span>(response.isExists()) &#123; </span><br><span class="line">                String json = response.getSourceAsString(); <span class="comment">//获取到_source field</span></span><br><span class="line">                System.out.println(json);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3>Bulk API 一次请求多个添加和删除</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BulkRequest</span><span class="params">(TransportClient client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BulkRequestBuilder bulkRequest = client.prepareBulk();</span><br><span class="line"></span><br><span class="line">        IndexRequestBuilder index1 = client.prepareIndex(<span class="string">"mytest"</span>, <span class="string">"test"</span>);</span><br><span class="line">        IndexRequestBuilder index2 = client.prepareIndex(<span class="string">"mytest"</span>, <span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; resource = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        resource.put(<span class="string">"name"</span>,<span class="string">"华硕"</span>);</span><br><span class="line">        resource.put(<span class="string">"price"</span>,<span class="number">5577</span>);</span><br><span class="line">        resource.put(<span class="string">"description"</span>,<span class="string">"华硕z460"</span>);</span><br><span class="line"></span><br><span class="line">        index1.setSource(resource);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; resource1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        resource1.put(<span class="string">"name"</span>,<span class="string">"小米2"</span>);</span><br><span class="line">        resource1.put(<span class="string">"price"</span>,<span class="number">4577</span>);</span><br><span class="line">        resource1.put(<span class="string">"description"</span>,<span class="string">"新机超薄"</span>);</span><br><span class="line"></span><br><span class="line">        index1.setSource(resource);</span><br><span class="line">        index2.setSource(resource1);</span><br><span class="line"></span><br><span class="line">        bulkRequest.add(index1);</span><br><span class="line">        bulkRequest.add(index2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        BulkResponse bulkResponse = bulkRequest.get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(bulkResponse.hasFailures()) &#123;</span><br><span class="line">            System.out.println(bulkResponse.buildFailureMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bulkResponse.forEach(response -&gt;&#123;</span><br><span class="line">            System.out.println(response.getId());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2>query dsl 使用</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.elasticsearch.index.query.QueryBuilders.*;</span><br><span class="line"></span><br><span class="line"> Settings settings = Settings.builder()</span><br><span class="line">                .put(<span class="string">"cluster.name"</span>, <span class="string">"hbz-6-test"</span>).build();</span><br><span class="line">        TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">        client.addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line">        allquery(client); <span class="comment">//具体的query dsl查询</span></span><br><span class="line"></span><br><span class="line">        client.close();</span><br></pre></td></tr></table></figure></p><h3>Match All Query 查询所有的数据</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allquery</span><span class="params">(TransportClient client)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        QueryBuilder qb = matchAllQuery();</span><br><span class="line">        SearchResponse response = client.prepareSearch(<span class="string">"mytest"</span>).setTypes(<span class="string">"test"</span>).setSize(<span class="number">3</span>).setQuery(qb).get();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"length: "</span>+response.getHits().getHits().length );</span><br><span class="line">        <span class="keyword">if</span>(response.getHits().getTotalHits() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(hit.getSourceAsString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3>Match Query 查询单一条件的数据</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myMatchQuery</span><span class="params">(TransportClient client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        QueryBuilder qb = matchQuery(<span class="string">"name"</span>,<span class="string">"mac"</span>);</span><br><span class="line"></span><br><span class="line">        SearchResponse response = client.prepareSearch(<span class="string">"mytest"</span>).setTypes(<span class="string">"test"</span>).setQuery(qb).get();</span><br><span class="line">        System.out.println(<span class="string">"length: "</span>+response.getHits().getHits().length );</span><br><span class="line">        <span class="keyword">if</span>(response.getHits().getTotalHits() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">                System.out.println(hit.getScore()+<span class="string">" --&gt; "</span>+hit.getSourceAsString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>MultiMatchQuery 在多个字段中查询一个关键字</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueryBuilder qb = multiMatchQuery(<span class="string">"mac"</span>,<span class="string">"description"</span>,<span class="string">"name"</span>); <span class="comment">//mac是要搜索的词 description，name 都是字段</span></span><br></pre></td></tr></table></figure></p><h3>Common Terms Query 搜索term</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myCommonTermsQuery</span><span class="params">(TransportClient client )</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        QueryBuilder qb = commonTermsQuery(<span class="string">"description"</span>,<span class="string">"mac"</span>);</span><br><span class="line">        print(qb,client);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3>Simple Query String Query 简单字符串查询可以使用正则</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mySimpleQueryString</span><span class="params">(TransportClient client )</span> </span>&#123;</span><br><span class="line">        QueryBuilder qb = queryStringQuery(<span class="string">"mac*^2"</span>).field(<span class="string">"name"</span>);</span><br><span class="line">        print(qb,client);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3>term 搜索关键词一个</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myTermQuery</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">        QueryBuilder qb = termQuery(<span class="string">"name"</span>,<span class="string">"mac2"</span>);</span><br><span class="line">        print(qb,client);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3>terms 搜索关键词多个</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QueryBuilder qb = termsQuery(<span class="string">"name_str"</span>,<span class="string">"小米"</span>,<span class="string">"戴尔"</span>);</span><br><span class="line">print2(qb,client);</span><br></pre></td></tr></table></figure></p><h3>range query 范围搜索</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myRangeQuery</span><span class="params">(TransportClient client)</span></span>&#123;</span><br><span class="line">        QueryBuilder qb = rangeQuery(<span class="string">"price"</span>).from(<span class="number">3399</span>)</span><br><span class="line">                .to(<span class="number">6399</span>)</span><br><span class="line">                .includeLower(<span class="keyword">true</span>)</span><br><span class="line">                .includeUpper(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        print2(qb,client);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QueryBuilder qb = rangeQuery(<span class="string">"price"</span>).gte(<span class="number">3399</span>).lt(<span class="number">6399</span>);</span><br></pre></td></tr></table></figure></p><h3>Exists Query 查找字段是否存在 存在则返回所有的数据，不存在返回0</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myExistsQuery</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">        QueryBuilder qb = existsQuery(<span class="string">"name_str"</span>);</span><br><span class="line">        print2(qb,client);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3>Wildcard Query 通配符查询</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueryBuilder qb = wildcardQuery(<span class="string">"user"</span>, <span class="string">"k?mc*"</span>);</span><br></pre></td></tr></table></figure></p><h3>Regexp Query支持正则表达式的查询</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">QueryBuilder qb = regexpQuery(<span class="string">"name.first"</span>, <span class="string">"s.*y"</span>);</span><br></pre></td></tr></table></figure></p><h3>Fuzzy Query 模糊查询</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">QueryBuilder qb = fuzzyQuery(</span><br><span class="line">    <span class="string">"name"</span>,</span><br><span class="line">    <span class="string">"kimzhy"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h3>ids Query 根据id 查询</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QueryBuilder qb = idsQuery(<span class="string">"my_type"</span>, <span class="string">"type2"</span>)</span><br><span class="line">    .addIds(<span class="string">"1"</span>, <span class="string">"4"</span>, <span class="string">"100"</span>);</span><br><span class="line"></span><br><span class="line">QueryBuilder qb = idsQuery() </span><br><span class="line">    .addIds(<span class="string">"AV8HhVC8FiG-4m4G2rYp"</span>,<span class="string">"AV8HhVB6FiG-4m4G2rYm"</span>);</span><br></pre></td></tr></table></figure></p><h2>复合查询</h2><h3>Contant Score Query 指定score</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueryBuilder qb = constantScoreQuery(matchQuery(<span class="string">"name_str"</span>, <span class="string">"联想"</span>)).boost(<span class="number">3.0f</span>);</span><br></pre></td></tr></table></figure></p><h3>Bool Query must mustNot should 查询</h3><p>所有的 must 子句必须匹配, 并且所有的 must_not 子句必须不匹配, 但是多少 should 子句应该匹配呢? 默认的,不需要匹配任何 should 子句,一种情况例外:如果没有must子句,就必须至少匹 配一个should子句。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myBoolQuery</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">        QueryBuilder qb = boolQuery().must(termQuery(<span class="string">"name_str"</span>,<span class="string">"小米"</span>))</span><br><span class="line">                .filter(matchQuery(<span class="string">"price"</span>,<span class="number">3599</span>))</span><br><span class="line">                .filter(matchQuery(<span class="string">"description"</span>,<span class="string">"lihao"</span>));</span><br><span class="line">        print2(qb, client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QueryBuilder qb = boolQuery()</span><br><span class="line">    .must(termQuery(<span class="string">"content"</span>, <span class="string">"test1"</span>))</span><br><span class="line">    .must(termQuery(<span class="string">"content"</span>, <span class="string">"test4"</span>))</span><br><span class="line">    .mustNot(termQuery(<span class="string">"content"</span>, <span class="string">"test2"</span>))</span><br><span class="line">    .should(termQuery(<span class="string">"content"</span>, <span class="string">"test3"</span>))  </span><br><span class="line">    .filter(termQuery(<span class="string">"content"</span>, <span class="string">"test5"</span>));</span><br></pre></td></tr></table></figure></p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET mttest-2017.10.41/web1/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"choosehospital/index"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"response"</span>: <span class="string">"500"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>indices query查询多个index</h3><p>用来查询多个index,对于指定内的index,执行指定的内部query;对于指定外的index,执行no_match_query设定的条件</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(QueryBuilder qb, TransportClient client)</span> </span>&#123;</span><br><span class="line">        SearchResponse response = client.prepareSearch(<span class="string">"mytest"</span>).setTypes(<span class="string">"test"</span>).setQuery(qb).get();</span><br><span class="line">        System.out.println(<span class="string">"length: "</span> + response.getHits().getHits().length);</span><br><span class="line">        <span class="keyword">if</span> (response.getHits().getTotalHits() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">                System.out.println(hit.getScore() + <span class="string">" --&gt; "</span> + hit.getSourceAsString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">(QueryBuilder qb, TransportClient client)</span> </span>&#123;</span><br><span class="line">        SearchResponse response = client.prepareSearch(<span class="string">"mytest_1"</span>).setTypes(<span class="string">"test"</span>).setQuery(qb).get();</span><br><span class="line">        System.out.println(<span class="string">"length: "</span> + response.getHits().getHits().length);</span><br><span class="line">        <span class="keyword">if</span> (response.getHits().getTotalHits() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">                System.out.println(hit.getScore() + <span class="string">" --&gt; "</span> + hit.getSourceAsString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2>scroll分页</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ...arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//链接服务器</span></span><br><span class="line">        Settings  settings = Settings.builder()</span><br><span class="line">                .put(<span class="string">"cluster.name"</span>,<span class="string">"hbz-6-test"</span>).build();</span><br><span class="line"></span><br><span class="line">        TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">        client.addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置搜索条件</span></span><br><span class="line">        QueryBuilder qb = termQuery(<span class="string">"name_str"</span>,<span class="string">"笔记本"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照price 降序  每次查询2条  第一次不需要设置sroll  scrollid</span></span><br><span class="line">        SearchResponse scrollResp = client.prepareSearch(<span class="string">"mytest_1"</span>).setTypes(<span class="string">"test"</span>)</span><br><span class="line">                .addSort(<span class="string">"price"</span>, SortOrder.DESC)</span><br><span class="line">                .setScroll(<span class="keyword">new</span> TimeValue(<span class="number">30000</span>))</span><br><span class="line">                .setQuery(qb)</span><br><span class="line">                .setSize(<span class="number">2</span>).get();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"length: "</span> + scrollResp.getHits().getHits().length);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"第 "</span> +count+ <span class="string">" 次"</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">for</span> (SearchHit hit : scrollResp.getHits().getHits())&#123;</span><br><span class="line">                System.out.println(hit.getScore() + <span class="string">" --&gt; "</span> +hit.getSourceAsString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"scrollid:  "</span>+scrollResp.getScrollId());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置sroll id</span></span><br><span class="line">            scrollResp =client.prepareSearchScroll(scrollResp.getScrollId()).setScroll(<span class="keyword">new</span> TimeValue(<span class="number">60000</span>)).execute().actionGet();</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (scrollResp.getHits().getHits().length !=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        client.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3>prepareMultiSearch多个条件查询</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiSearchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ...arg)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Settings settings = Settings.builder().put(<span class="string">"cluster.name"</span>, <span class="string">"hbz-6-test"</span>).build();</span><br><span class="line"></span><br><span class="line">        TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">        client.addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       QueryBuilder query1 = termQuery(<span class="string">"name_str"</span>,<span class="string">"小米"</span>);</span><br><span class="line">       QueryBuilder query2 = termQuery(<span class="string">"name_str"</span>,<span class="string">"戴尔"</span>);</span><br><span class="line"></span><br><span class="line">        SearchRequestBuilder srb1 = client.prepareSearch(<span class="string">"mytest_1"</span>).setTypes(<span class="string">"test"</span>).setQuery(query1);</span><br><span class="line">        SearchRequestBuilder srb2 = client.prepareSearch(<span class="string">"mytest_1"</span>).setTypes(<span class="string">"test"</span>).setQuery(query2);</span><br><span class="line"></span><br><span class="line">        MultiSearchResponse sr = client.prepareMultiSearch().add(srb1).add(srb2).get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> nbHits =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(MultiSearchResponse.Item item : sr.getResponses()) &#123;</span><br><span class="line">            SearchResponse response = item.getResponse();</span><br><span class="line">            nbHits += response.getHits().getTotalHits();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(response.getHits().getHits().length &gt;<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">                    System.out.println(hit.getScore()+<span class="string">"  -----&gt;  "</span>+hit.getSourceAsString());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(nbHits);</span><br><span class="line"></span><br><span class="line">        client.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>聚合</h2><h3>概述</h3><p>ES 的聚合框架提供对查询得到的数据进行分组和汇总统计，以提供复杂的统计分析功能。</p><p>ES支持在一次聚合查询中，可以同时得到聚合的具体结果并再次进行聚合，也就是聚合是可以嵌套的。</p><p>这非常有用,你可以通过一次操作得到多次聚合的结果,从而避免多次请求,减少网络和服务器的负担。</p><h3>聚合的类型</h3><ol><li><p>Bucketing（桶）聚合：划分不同的“桶”，将数据分配到不同的“桶” 里，然后再进行聚合，非常类似sql 中的group 语句的含义。</p></li><li><p>Metric(指标)聚合：指标聚合主要针对number类型的数据，在一组文档中，保持对要聚合的指标的跟踪和计算，需要ES做比较多的计算工作。</p></li><li><p>Pipeline(管道)聚合：用来聚合其它聚合输出的结果以及相关指标</p></li></ol><h3>聚合的基本语法</h3><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"aggregations" : &#123;                      //定义聚合对象,也可用 "aggs"</span><br><span class="line">    "&lt;aggregation_name&gt;" : &#123;            //聚合的名称,用户自定义   </span><br><span class="line">        "&lt;aggregation_type&gt;" : &#123;         //聚合类型,比如 "histogram" "avg"</span><br><span class="line">            &lt;aggregation_body&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        [,"meta" : &#123;  [&lt;meta_data_body&gt;] &#125; ]?</span><br><span class="line">        [,"aggregations" : &#123; [&lt;sub_aggregation&gt;]+ &#125; ]?</span><br><span class="line">    &#125;</span><br><span class="line">    [,"&lt;aggregation_name_2&gt;" : &#123; ... &#125; ]*  ////定义额外的多个平级聚合,只有Bucketing类型才有意义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>GET mytest_1/test/_search</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"avg_price"</span> : &#123; <span class="attr">"avg"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"price"</span> &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>output:</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"aggregations"</span>: &#123;</span><br><span class="line">    <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">      <span class="attr">"value"</span>: <span class="number">4954.555555555556</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2>Metric 使用</h2><h3>求平均值</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ...arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Settings settings = Settings.builder().put(<span class="string">"cluster.name"</span>, <span class="string">"hbz-6-test"</span>).build();</span><br><span class="line"></span><br><span class="line">        TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">        client.addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>),<span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        avg(client);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        client.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">avg</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">        SearchRequestBuilder search = client.prepareSearch(<span class="string">"mytest_1"</span>).setTypes(<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">        SearchResponse sr = search.addAggregation(AggregationBuilders.avg(<span class="string">"avg_price"</span>).field(<span class="string">"price"</span>)).execute().actionGet();</span><br><span class="line"></span><br><span class="line">        Avg result = sr.getAggregations().get(<span class="string">"avg_price"</span>);</span><br><span class="line">        System.out.println(result.getValue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>POST mytest_1/test/_search?size=0</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"avg_price"</span> : &#123;</span><br><span class="line">          <span class="attr">"avg"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"price"</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>POST mytest_1/test/_search?size=0</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">        <span class="attr">"all_cats"</span>:&#123;</span><br><span class="line">            <span class="attr">"terms"</span>:&#123;</span><br><span class="line">                <span class="attr">"field"</span>:<span class="string">"tag.keyword"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">                <span class="attr">"avg_price"</span>:&#123;</span><br><span class="line">                    <span class="attr">"avg"</span>:&#123;</span><br><span class="line">                        <span class="attr">"field"</span>:<span class="string">"price"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>output:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">"aggregations": &#123;</span><br><span class="line">    "all_cats": &#123;</span><br><span class="line">      "doc_count_error_upper_bound": 0,</span><br><span class="line">      "sum_other_doc_count": 0,</span><br><span class="line">      "buckets": [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"笔记本"</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">8</span>,</span><br><span class="line">          <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">5124</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"联想"</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">4</span>,</span><br><span class="line">          <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">5649</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"小米"</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">4399</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"惠普"</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">2399</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"戴尔"</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">7199</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3>分类求取平均值</h3><p>PUT mytest_1/_mapping/test</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"tag"</span>: &#123; </span><br><span class="line">      <span class="attr">"type"</span>:     <span class="string">"text"</span>,</span><br><span class="line">      <span class="attr">"fielddata"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">avg1</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">        SearchRequestBuilder search = client.prepareSearch(<span class="string">"mytest_1"</span>).setSize(<span class="number">0</span>).setTypes(<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">        TermsAggregationBuilder tag = AggregationBuilders.terms(<span class="string">"tags"</span>).field(<span class="string">"tag.keyword"</span>);</span><br><span class="line">        AvgAggregationBuilder price = AggregationBuilders.avg(<span class="string">"avg_price"</span>).field(<span class="string">"price"</span>);</span><br><span class="line">        tag.subAggregation(price);</span><br><span class="line"></span><br><span class="line">        SearchResponse sr = search.addAggregation(tag).execute().actionGet();</span><br><span class="line"></span><br><span class="line">        System.out.println(sr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3>Cardinality 去除重复数据</h3><p>用来对单个数据进行汇总,计算不重复的值的数量。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Settings settings = Settings.builder().put(<span class="string">"cluster.name"</span>, <span class="string">"hbz-6-test"</span>).build();</span><br><span class="line"></span><br><span class="line">        TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">        client.addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cardinality(client);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        client.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cardinality</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SearchRequestBuilder search = client.prepareSearch(<span class="string">"mytest_1"</span>).setTypes(<span class="string">"test"</span>);</span><br><span class="line">        SearchResponse sr = search.addAggregation(AggregationBuilders.cardinality(<span class="string">"type_count"</span>).field(<span class="string">"price"</span>)).execute().actionGet();</span><br><span class="line"></span><br><span class="line">        Cardinality result = sr.getAggregations().get(<span class="string">"type_count"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"type_count: "</span>+result.getValue());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>POST mytest_1/test/_search?size=0</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"type_count"</span> : &#123;</span><br><span class="line">            <span class="attr">"cardinality"</span> : &#123;</span><br><span class="line">                <span class="attr">"field"</span> : <span class="string">"price"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>output:</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span>: <span class="number">7</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aggregations"</span>: &#123;</span><br><span class="line">    <span class="attr">"type_count"</span>: &#123;</span><br><span class="line">      <span class="attr">"value"</span>: <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>Stats 聚合操作 count min max avg sum</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stats</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">        SearchRequestBuilder search = client.prepareSearch(<span class="string">"mytest_1"</span>).setTypes(<span class="string">"test"</span>);</span><br><span class="line">        SearchResponse sr =  search.addAggregation(AggregationBuilders.stats(<span class="string">"price_stats"</span>).field(<span class="string">"price"</span>)).execute().actionGet();</span><br><span class="line"></span><br><span class="line">       Stats stats = sr.getAggregations().get(<span class="string">"price_stats"</span>);</span><br><span class="line">        System.out.println(stats.getAvgAsString());</span><br><span class="line">        System.out.println(stats.getMaxAsString());</span><br><span class="line">        System.out.println(stats.getMinAsString());</span><br><span class="line">        System.out.println(stats.getSumAsString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>POST mytest_1/test/_search?size=0</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"price_stats"</span> : &#123; <span class="attr">"extended_stats"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"price"</span> &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>output:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">"aggregations": &#123;</span><br><span class="line">    "price_stats": &#123;</span><br><span class="line">      "count": 8,</span><br><span class="line">      "min": 2399,</span><br><span class="line">      "max": 7199,</span><br><span class="line">      "avg": 5124,</span><br><span class="line">      "sum": 40992,</span><br><span class="line">      "sum_of_squares": 231958008,</span><br><span class="line">      "variance": 2739375,</span><br><span class="line">      "std_deviation": 1655.1057368035433,</span><br><span class="line">      "std_deviation_bounds": &#123;</span><br><span class="line">        "upper": 8434.211473607087,</span><br><span class="line">        "lower": 1813.7885263929134</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3>Percentiles 百分比 查看一个百分比对应的值</h3><p>这是一个多值的指标聚集,用来计算聚合文档中,在某个百分比或某个区间,所对应的观测值,</p><ol><li><p>缺省的percentile的区间是[ 1, 5, 25, 50, 75, 95, 99 ]。</p></li><li><p>观测值通常都是近似的,有很多不同的算法来计算。</p></li></ol><p>​例如:第九十五个百分值是大于所观察到的值的95%的值。</p><p>POST mytest_1/test/_search?size=0</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"price_percent"</span> : &#123;</span><br><span class="line">            <span class="attr">"percentiles"</span> : &#123;</span><br><span class="line">                <span class="attr">"field"</span> : <span class="string">"price"</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>POST mytest_1/test/_search?size=0</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"price_percent"</span> : &#123;</span><br><span class="line">            <span class="attr">"percentiles"</span> : &#123;</span><br><span class="line">                <span class="attr">"field"</span> : <span class="string">"price"</span> ,</span><br><span class="line">                <span class="attr">"percents"</span> : [<span class="number">0.1</span>,<span class="number">50</span>,<span class="number">95</span>, <span class="number">99</span>, <span class="number">100</span>]  //自定义百分比区间</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>output:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"aggregations": &#123;</span><br><span class="line">    "price_percent": &#123;</span><br><span class="line">      "values": &#123;</span><br><span class="line">        "1.0": 2468.9999999999995,</span><br><span class="line">        "5.0": 2749,</span><br><span class="line">        "25.0": 3549,</span><br><span class="line">        "50.0": 5799,</span><br><span class="line">        "75.0": 6399,</span><br><span class="line">        "95.0": 6918.999999999999,</span><br><span class="line">        "99.0": 7143</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">percentile</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">        SearchRequestBuilder search = client.prepareSearch(<span class="string">"mytest_1"</span>).setTypes(<span class="string">"test"</span>);</span><br><span class="line">        SearchResponse sr =  search.addAggregation(AggregationBuilders.percentiles(<span class="string">"price_percent"</span>).field(<span class="string">"price"</span>)).execute().actionGet();</span><br><span class="line"></span><br><span class="line">       Percentiles percentile = sr.getAggregations().get(<span class="string">"price_percent"</span>);</span><br><span class="line"></span><br><span class="line">       System.out.println(percentile.percentileAsString(<span class="number">80</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义百分比区间</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">percentile2</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">        SearchRequestBuilder search = client.prepareSearch(<span class="string">"mytest_1"</span>).setTypes(<span class="string">"test"</span>);</span><br><span class="line">        SearchResponse sr =  search.addAggregation(AggregationBuilders.percentiles(<span class="string">"price_percent"</span>).percentiles(<span class="number">0.1</span>,<span class="number">50</span>,<span class="number">95</span>, <span class="number">99</span>, <span class="number">100</span>).field(<span class="string">"price"</span>)).execute().actionGet();</span><br><span class="line"></span><br><span class="line">        System.out.println(sr);</span><br><span class="line">        Percentiles percentile = sr.getAggregations().get(<span class="string">"price_percent"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(percentile.percentileAsString(<span class="number">80</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3>Value Count 计算聚合值的数量</h3><p>POST mytest_1/test/_search?size=0</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"types_count"</span> : &#123; <span class="attr">"value_count"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"price"</span> &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>out:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"aggregations": &#123;</span><br><span class="line">    "types_count": &#123;</span><br><span class="line">      "value": 8</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">valueCount</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">        SearchRequestBuilder search = client.prepareSearch(<span class="string">"mytest_1"</span>).setTypes(<span class="string">"test"</span>);</span><br><span class="line">        SearchResponse sr =search.addAggregation(AggregationBuilders.count(<span class="string">"value_count"</span>).field(<span class="string">"price"</span>)).execute().actionGet();</span><br><span class="line">       ValueCount valueCount = sr.getAggregations().get(<span class="string">"value_count"</span>);</span><br><span class="line">       System.out.println(valueCount.getValue());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3>TOP hits</h3><p>用来取符合条件的前n条数据。 包含的选项有:from、size、sort。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">topHits</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">        SearchRequestBuilder search = client.prepareSearch(<span class="string">"mytest_1"</span>).setTypes(<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">        TopHitsAggregationBuilder addtion = AggregationBuilders.topHits(<span class="string">"top_price_hits"</span>).sort(<span class="string">"price"</span>, SortOrder.DESC).fieldDataField(<span class="string">"price"</span>)</span><br><span class="line">                .size(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        SearchResponse sr =search.addAggregation(addtion).execute().actionGet();</span><br><span class="line">       TopHits topHits = sr.getAggregations().get(<span class="string">"top_price_hits"</span>);</span><br><span class="line">       System.out.println();</span><br><span class="line">        SearchHit[] hits = topHits.getHits().internalHits();</span><br><span class="line">        <span class="keyword">for</span>(SearchHit searchHit : hits) &#123;</span><br><span class="line">            System.out.println(searchHit.getSourceAsString());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2>bucket 使用</h2><h3>Histogram</h3><p>条形图聚合，根据文档中的谋改革字段来分组。一个文档属于某个通，计算过程大致如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rem = value % interval</span><br><span class="line"><span class="keyword">if</span> (rem &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    rem += interval</span><br><span class="line">&#125;</span><br><span class="line">bucket_key = value - rem</span><br></pre></td></tr></table></figure></p><p>可配置的参数:</p><ol><li>field:字段,必须为数值类型</li><li>interval:分桶间距</li><li>min_doc_count:最少文档数,桶过滤,只有不少于这么多文档的桶才会返回</li><li>extended_bounds:范围扩展</li><li>order:对桶排序,如果 histogram 聚合有一个权值聚合类型的“直接”子聚合,那么排序可以使用 子聚合中的结果</li><li>offset:桶边界位移,默认从0开始</li><li>keyed:hash结构返回,默认以数组形式返回每一个桶</li><li>missing:配置缺省默认值</li></ol><p>POST mytest_1/test/_search?size=0</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"prices"</span> : &#123;</span><br><span class="line">            <span class="attr">"histogram"</span> : &#123;</span><br><span class="line">                <span class="attr">"field"</span> : <span class="string">"price"</span>,</span><br><span class="line">                <span class="attr">"interval"</span> : <span class="number">2000</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>out:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">"aggregations": &#123;</span><br><span class="line">    "prices": &#123;</span><br><span class="line">      "buckets": [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">2000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">3</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">4000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">6000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">histogram</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">        SearchRequestBuilder search = client.prepareSearch(<span class="string">"mytest_1"</span>).setTypes(<span class="string">"test"</span>).setSize(<span class="number">0</span>);</span><br><span class="line">        HistogramAggregationBuilder addtion = AggregationBuilders.histogram(<span class="string">"prices"</span>).interval(<span class="number">2000</span>).field(<span class="string">"price"</span>);</span><br><span class="line"></span><br><span class="line">        SearchResponse sr = search.addAggregation(addtion).execute().actionGet();</span><br><span class="line"></span><br><span class="line">       Histogram histogram = sr.getAggregations().get(<span class="string">"prices"</span>);</span><br><span class="line">       histogram.getBuckets().forEach(bucket-&gt;&#123;</span><br><span class="line">           System.out.println(bucket.getKeyAsString()+<span class="string">" ----&gt;  "</span>+bucket.getDocCount());</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2>Range</h2><p>范围聚合，是对某个字段的值，按照设定的范围进行分组。</p><p>POST mytest_1/test/_search?size=0</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"price_ranges"</span> : &#123;</span><br><span class="line">            <span class="attr">"range"</span> : &#123;</span><br><span class="line">                <span class="attr">"field"</span> : <span class="string">"price"</span>,</span><br><span class="line">                <span class="attr">"ranges"</span> : [</span><br><span class="line">                    &#123; <span class="attr">"to"</span> : <span class="number">3000</span> &#125;,</span><br><span class="line">                    &#123; <span class="attr">"from"</span> : <span class="number">3000</span>, <span class="attr">"to"</span> : <span class="number">5000</span> &#125;,</span><br><span class="line">                    &#123; <span class="attr">"from"</span> : <span class="number">5000</span> &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>out:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">"aggregations": &#123;</span><br><span class="line">    "price_ranges": &#123;</span><br><span class="line">      "buckets": [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"*-3000.0"</span>,</span><br><span class="line">          <span class="attr">"to"</span>: <span class="number">3000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"3000.0-5000.0"</span>,</span><br><span class="line">          <span class="attr">"from"</span>: <span class="number">3000</span>,</span><br><span class="line">          <span class="attr">"to"</span>: <span class="number">5000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"5000.0-*"</span>,</span><br><span class="line">          <span class="attr">"from"</span>: <span class="number">5000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">range</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">        SearchRequestBuilder search = client.prepareSearch(<span class="string">"mytest_1"</span>).setTypes(<span class="string">"test"</span>).setSize(<span class="number">0</span>);</span><br><span class="line">        AggregationBuilder addtion = AggregationBuilders.range(<span class="string">"price_ranges"</span>).field(<span class="string">"price"</span>)</span><br><span class="line">                .addUnboundedTo(<span class="number">3000</span>)</span><br><span class="line">                .addRange(<span class="number">3000</span>,<span class="number">5000</span>)</span><br><span class="line">                .addUnboundedFrom(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        SearchResponse sr = search.addAggregation(addtion).execute().actionGet();</span><br><span class="line"></span><br><span class="line">       Range histogram = sr.getAggregations().get(<span class="string">"price_ranges"</span>);</span><br><span class="line">       histogram.getBuckets().forEach(bucket-&gt;&#123;</span><br><span class="line">           String key = bucket.getKeyAsString();</span><br><span class="line">           String from = bucket.getFromAsString();</span><br><span class="line">           String to = bucket.getToAsString();</span><br><span class="line">           <span class="keyword">long</span> count = bucket.getDocCount();</span><br><span class="line">           System.out.println(<span class="string">"key : "</span>+key+<span class="string">"\t form: "</span>+from+<span class="string">"\t to:"</span>+to+<span class="string">"\t count:"</span>+count);</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2>Terms</h2><p>词元聚合，以指定的字段内的每一个不重复的term来分组，并计算每个组内文档的个数。</p><p>POST mytest_1/test/_search?size=0</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"all_cats"</span> : &#123;</span><br><span class="line">          <span class="attr">"terms"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"tag.keyword"</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>Filters 过滤</h2><p>多过滤聚合，用多个过滤条件，来对当前文档进行过滤的聚合，每个过滤都包含所有满足它的文档，</p><p>多个bucket中可能重复。</p><p>POST mytest_1/test/_search?size=0</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">    <span class="attr">"messages"</span> : &#123;</span><br><span class="line">      <span class="attr">"filters"</span> : &#123;</span><br><span class="line">        <span class="attr">"filters"</span> : &#123;</span><br><span class="line">          <span class="attr">"filter1"</span> :   &#123; <span class="attr">"match"</span> : &#123; <span class="attr">"tag"</span> : <span class="string">"小米"</span>   &#125;&#125;,</span><br><span class="line">          <span class="attr">"filter2"</span> : &#123; <span class="attr">"match"</span> : &#123; <span class="attr">"tag"</span> : <span class="string">"戴尔"</span> &#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>out:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"aggregations": &#123;</span><br><span class="line">    "messages": &#123;</span><br><span class="line">      "buckets": &#123;</span><br><span class="line">        "filter1": &#123;</span><br><span class="line">          "doc_count": 2</span><br><span class="line">        &#125;,</span><br><span class="line">        "filter2": &#123;</span><br><span class="line">          "doc_count": 1</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">filters</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">        SearchRequestBuilder search = client.prepareSearch(<span class="string">"mytest_1"</span>).setTypes(<span class="string">"test"</span>).setSize(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        AggregationBuilder aggregation = AggregationBuilders.filters(<span class="string">"filters"</span>,</span><br><span class="line">                <span class="keyword">new</span> FiltersAggregator.KeyedFilter(<span class="string">"xiaomi"</span>,matchQuery(<span class="string">"tag"</span>,<span class="string">"小米"</span>)),</span><br><span class="line">                <span class="keyword">new</span> FiltersAggregator.KeyedFilter(<span class="string">"daier"</span>,matchQuery(<span class="string">"tag"</span>,<span class="string">"戴尔"</span>))</span><br><span class="line">        );</span><br><span class="line">        SearchResponse sr = search.addAggregation(aggregation).execute().actionGet();</span><br><span class="line">        System.out.println(sr);</span><br><span class="line">        Filters agg =sr.getAggregations().get(<span class="string">"filters"</span>);</span><br><span class="line">        agg.getBuckets().forEach(entry-&gt;&#123;</span><br><span class="line">            String key = entry.getKeyAsString();            <span class="comment">// bucket key</span></span><br><span class="line">            <span class="keyword">long</span> docCount = entry.getDocCount();</span><br><span class="line">            System.out.println(<span class="string">"key : "</span>+key+<span class="string">"\t docCount: "</span>+docCount);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2>分词</h2><h3>分词安装</h3><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/tree/v5.5.0" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik/tree/v5.5.0</a></p><h3>测试分词</h3><p>GET _analyze</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"analyzer"</span>: <span class="string">"ik_smart"</span>,</span><br><span class="line">  <span class="attr">"text"</span>: [<span class="string">"中华人民共和国"</span>]</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>bool</h2><ul><li><p>bool 过滤 :可以用来合并多个过滤条件查询结果的布尔逻辑,它包含一下操作符:</p></li><li><p>must:多个查询条件的完全匹配,相当于 and。</p></li><li><p>must_not: 多个查询条件的相反匹配,相当于 not。</p></li><li><p>should: 至少有一个查询条件匹配, 相当于 or。</p></li></ul><h1>参考文档</h1><p><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/_structuring_aggregations.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/_structuring_aggregations.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;简介&lt;/h1&gt;
&lt;p&gt;java Elastic 客户端基本使用&lt;/p&gt;
&lt;h2&gt;引入jar&lt;/h2&gt;
&lt;p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://hhbbz.github.io/tags/Java/"/>
    
      <category term="Elasticsearch" scheme="https://hhbbz.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>关于ES字符串类型Text和keyword</title>
    <link href="https://hhbbz.github.io/2018/10/19/ES%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8BText%E5%92%8Ckeyword/"/>
    <id>https://hhbbz.github.io/2018/10/19/ES字符串类型Text和keyword/</id>
    <published>2018-10-19T08:30:15.000Z</published>
    <updated>2018-10-19T08:56:35.172Z</updated>
    
    <content type="html"><![CDATA[<h1>问题描述</h1><p>今天在做es的聚合查询的时候，遇到了一个问题。</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"error"</span>: &#123;</span><br><span class="line">    <span class="attr">"root_cause"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"illegal_argument_exception"</span>,</span><br><span class="line">        <span class="attr">"reason"</span>: <span class="string">"Fielddata is disabled on text fields by default. Set fielddata=true on [interests] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory."</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"search_phase_execution_exception"</span>,</span><br><span class="line">    <span class="attr">"reason"</span>: <span class="string">"all shards failed"</span>,</span><br><span class="line">    <span class="attr">"phase"</span>: <span class="string">"query"</span>,</span><br><span class="line">    <span class="attr">"grouped"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"failed_shards"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"shard"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"index"</span>: <span class="string">"megacorp"</span>,</span><br><span class="line">        <span class="attr">"node"</span>: <span class="string">"-Md3f007Q3G6HtdnkXoRiA"</span>,</span><br><span class="line">        <span class="attr">"reason"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"illegal_argument_exception"</span>,</span><br><span class="line">          <span class="attr">"reason"</span>: <span class="string">"Fielddata is disabled on text fields by default. Set fielddata=true on [interests] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory."</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"caused_by"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"illegal_argument_exception"</span>,</span><br><span class="line">      <span class="attr">"reason"</span>: <span class="string">"Fielddata is disabled on text fields by default. Set fielddata=true on [interests] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory."</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="number">400</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>搜了一下应该是5.x后对排序，聚合这些操作用单独的数据结构(fielddata)缓存到内存里了，需要单独开启。</p><h1>解决方法</h1><p>遇到这个错误是因为你尝试对一个text类型的字段做排序，而text类型的字段是要分词的。 一来词典很大，性能会很差；二来排序结果是词典里的词，而并非整个text的内容。 出于这2点原因，ES5.x以后对于text类型默认禁用了fielddata，防止对text字段一些错误的操作（排序，聚合，script)而给heap造成很大的压力。如果一定有对该字段按照文本字母序做排序的需求，可以将该字段定义为multi-filed。于是我选择了将字段定义为keyword。keyword字段是通过doc values排序的，内存消耗远小于fielddata。</p><h1>Text和keyword的区别</h1><p>ElasticSearch 5.0以后，string类型有重大变更，移除了string类型，string字段被拆分成两种新的数据类型: text用于全文搜索的,而keyword用于关键词搜索。ElasticSearch字符串将默认被同时映射成text和keyword类型，将会自动创建下面的动态映射(dynamic mappings):</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">"foo"</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"fields"</span>: &#123;</span><br><span class="line"></span><br><span class="line">            <span class="attr">"keyword"</span>: &#123;</span><br><span class="line"></span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"keyword"</span>,</span><br><span class="line"></span><br><span class="line">                <span class="attr">"ignore_above"</span>: <span class="number">256</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就是造成部分字段还会自动生成一个与之对应的“.keyword”字段的原因。</p><p>Text：</p><ul><li><p>会分词，然后进行索引</p></li><li><p>支持模糊、精确查询</p></li><li><p>不支持聚合</p></li></ul><p>keyword：</p><ul><li><p>不进行分词，直接索引</p></li><li><p>支持模糊、精确查询</p></li><li><p>支持聚合</p></li></ul><h1>结论</h1><p>keyword类型满足目前系统的需求，且能保证接口统一，所以建议将查询、聚合中涉及的字符串类型，在mapping中设置为“keyword”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;问题描述&lt;/h1&gt;
&lt;p&gt;今天在做es的聚合查询的时候，遇到了一个问题。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://hhbbz.github.io/tags/Java/"/>
    
      <category term="Elasticsearch" scheme="https://hhbbz.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务的四种解决方案</title>
    <link href="https://hhbbz.github.io/2018/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://hhbbz.github.io/2018/09/06/分布式事务的四种解决方案/</id>
    <published>2018-09-06T10:50:40.000Z</published>
    <updated>2018-09-06T11:07:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1>简述</h1><p>分布式事务指事务的操作位于不同的节点上，需要保证事务的 AICD 特性。</p><p>例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。</p><h1>解决方案</h1><p>在分布式系统中，要实现分布式事务，无外乎那几种解决方案。</p><h2>一、两阶段提交（2PC）</h2><p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p><h3>1. 运行过程</h3><h4>1.1 准备阶段</h4><p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</p><p><img src="/2018/09/06/分布式事务的四种解决方案/1.jpg" title="图片"></p><h4>1.2 提交阶段</h4><p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p><p>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p><p><img src="/2018/09/06/分布式事务的四种解决方案/2.jpg" title="图片"></p><h3>2. 存在的问题</h3><p><strong>2.1 同步阻塞</strong>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</p><p><strong>2.2 单点问题</strong>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。</p><p><strong>2.3 数据不一致</strong>在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p><p><strong>2.4 太过保守</strong>任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p><h2>二、补偿事务（TCC）</h2><p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p><ul><li><p>Try 阶段主要是对业务系统做检测及资源预留</p></li><li><p>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</p></li><li><p>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</p></li></ul><p>举个例子，假入 Bob 要向 Smith 转账，思路大概是：我们有一个本地方法，里面依次调用</p><ol><li>首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。</li><li>在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。</li><li>如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</li></ol><p><strong>优点：</strong> 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些</p><p><strong>缺点：</strong> 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。</p><h2>三、本地消息表（异步确保）</h2><p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。</p><ol><li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li><li>之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li><li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li></ol><p><img src="/2018/09/06/分布式事务的四种解决方案/3.jpg" title="图片"></p><p><strong>优点：</strong> 一种非常经典的实现，避免了分布式事务，实现了最终一致性。</p><p><strong>缺点：</strong> 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</p><h2>四、MQ 事务消息</h2><p>有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。</p><p>以阿里的 RocketMQ 中间件为例，其思路大致为：</p><p>第一阶段Prepared消息，会拿到消息的地址。第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。</p><p>也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p><p><img src="/2018/09/06/分布式事务的四种解决方案/4.png" title="图片"></p><p><strong>优点：</strong> 实现了最终一致性，不需要依赖本地数据库事务。</p><p><strong>缺点：</strong> 实现难度大，主流MQ不支持，RocketMQ事务消息部分代码也未开源。</p><h1>总结</h1><p>通过本文我们总结并对比了几种分布式分解方案的优缺点，分布式事务本身是一个技术难题，是没有一种完美的方案应对所有场景的，具体还是要根据业务场景去抉择吧。笔者上家公司是试用阿里RocketMQ去实现的分布式事务，现在也有除了很多分布式事务的协调器，比如LCN等，大家可以多去尝试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;简述&lt;/h1&gt;
&lt;p&gt;分布式事务指事务的操作位于不同的节点上，需要保证事务的 AICD 特性。&lt;/p&gt;
&lt;p&gt;例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。&lt;/p&gt;
&lt;h1&gt;解决方案&lt;/h1&gt;
&lt;p&gt;在分布式系统中，要实现分布式事务，无外乎那几种解决
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="MQ" scheme="https://hhbbz.github.io/tags/MQ/"/>
    
      <category term="分布式" scheme="https://hhbbz.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch初体验</title>
    <link href="https://hhbbz.github.io/2018/08/20/Elasticsearch%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://hhbbz.github.io/2018/08/20/Elasticsearch初体验/</id>
    <published>2018-08-20T11:08:54.000Z</published>
    <updated>2018-08-20T12:17:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>Elasticsearch 是一款稳定高效的分布式搜索和分析引擎，它的底层基于 Lucene，并提供了友好的 RESTful API 来对数据进行操作，还有比较重要的一点是， Elasticsearch 开箱即可用，上手也比较容易。目前 Elasticsearch 在搭建企业级搜索（如日志搜索、商品搜索等）平台中很广泛，官网也提供了不少案例，比如：</p><pre><code>* GitHub 使用 Elasticsearch 检索超过 800 万的代码库* eBay 使用 Elasticsearch 搜索海量的商品数据* Netflix 使用 Elasticsearch 来实现高效的消息传递系统</code></pre><p>本文主要介绍 Elasticsearch 的基本概念及入门使用。</p><h1>安装</h1><p>在安装 Elasticsearch 之前，请确保你的计算机已经安装了 Java。目前 Elasticsearch 的最新版是 5.2，需要安装 Java 8，如果你用的是老版本的 Elasticsearch，如 2.x 版，可用 Java 7，但还是推荐使用 Java 8。</p><p>可以使用如下的命令检查 Java 的版本：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> java -version</span><br></pre></td></tr></table></figure></p><p>接着，下载最新版本的 Elasticsearch，可使用 wget 下载，如下：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.2.2.tar.gz</span><br></pre></td></tr></table></figure></p><p>Windows 用户也可以下载 .zip 格式的安装包。</p><p>下载完后进行解压：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tar -zxvf elasticsearch-5.2.2.tar.gz</span><br></pre></td></tr></table></figure></p><h2>运行</h2><p>首先，Elasticsearch不允许通过root管理员运行，所以我们要新建一个非管理员用户。</p><ol><li>useradd yourname ：新建账户</li><li>passwd yourname ：设置密码</li><li>su yourname：切换到新建账户</li></ol><p>然后，我们进入到刚刚解压出来的目录中：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd elasticsearch-5.2.2</span><br></pre></td></tr></table></figure></p><p>接着，使用如下命令启动 Elasticsearch：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bin/elasticsearch -d</span><br></pre></td></tr></table></figure></p><p>此时，如果正常的话，你可以在终端看到类似如下的输出：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[2018-08-19T23:25:09,961][INFO ][o.e.n.Node               ] [] initializing ...</span><br><span class="line">[2018-08-19T23:25:10,073][INFO ][o.e.e.NodeEnvironment    ] [yO11WLM] using [1] data paths, mounts [[/ (/dev/disk0s2)]], net usable_space [141.1gb], net total_space [232.9gb], spins? [unknown], types [hfs]</span><br><span class="line">[2018-08-19T23:25:10,074][INFO ][o.e.e.NodeEnvironment    ] [yO11WLM] heap size [1.9gb], compressed ordinary object pointers [true]</span><br><span class="line">[2018-08-19T23:25:10,095][INFO ][o.e.n.Node               ] node name [yO11WLM] derived from node ID [yO11WLMOQDuAOpZbYZYjzw]; set [node.name] to override</span><br><span class="line">[2018-08-19T23:25:10,100][INFO ][o.e.n.Node               ] version[5.2.2], pid[7607], build[db0d481/2017-02-09T22:05:32.386Z], OS[Mac OS X/10.11.5/x86_64], JVM[Oracle Corporation/Java HotSpot(TM) 64-Bit Server VM/1.8.0_102/25.102-b14]</span><br><span class="line">[2018-08-19T23:25:11,363][INFO ][o.e.p.PluginsService     ] [yO11WLM] loaded module [aggs-matrix-stats]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>上面的命令是在前台运行的，如果想在后台以守护进程模式运行，可以加 -d 参数。Elasticsearch 启动后，也启动了两个端口 9200 和 9300：</p><p>9200 端口：HTTP RESTful 接口的通讯端口9300 端口：TCP 通讯端口，用于集群间节点通信和与 Java 客户端通信的端口</p><p>现在，让我们做一些测试。在浏览器访问链接 http://localhost:9200/ ，或使用 curl 命令：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl 'http://localhost:9200/?pretty'</span><br></pre></td></tr></table></figure></p><p>我们可以看到类似如下的输出：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"yO11WLM"</span>,</span><br><span class="line">  <span class="attr">"cluster_name"</span> : <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"cluster_uuid"</span> : <span class="string">"yC8BGwzlSnu_zGbKL918Xg"</span>,</span><br><span class="line">  <span class="attr">"version"</span> : &#123;</span><br><span class="line">    <span class="attr">"number"</span> : <span class="string">"5.2.1"</span>,</span><br><span class="line">    <span class="attr">"build_hash"</span> : <span class="string">"db0d481"</span>,</span><br><span class="line">    <span class="attr">"build_date"</span> : <span class="string">"2017-02-09T22:05:32.386Z"</span>,</span><br><span class="line">    <span class="attr">"build_snapshot"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"lucene_version"</span> : <span class="string">"6.4.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>概念</h1><p>在进一步使用 Elasticsearch 之前，让我们先了解几个关键概念。</p><p>在逻辑层面：</p><ul><li>Index (索引)：这里的 Index 是名词，一个 Index 就像是传统关系数据库的 Database，它是 Elasticsearch 用来存储数据的逻辑区域</li><li>Document (文档)：Elasticsearch 使用 JSON 文档来表示一个对象，就像是关系数据库中一个 Table 中的一行数据</li><li>Type (类型)：文档归属于一种 Type，就像是关系数据库中的一个 Table。(目前官方不推荐使用)</li><li>Field (字段)：每个文档包含多个字段，类似关系数据库中一个 Table 的列</li></ul><p>我们用一个表格来做类比，如下：</p><table><thead><tr><th style="text-align:left">Elasticsearch</th><th style="text-align:left">MySQL</th></tr></thead><tbody><tr><td style="text-align:left">Index</td><td style="text-align:left">Database</td></tr><tr><td style="text-align:left">Type</td><td style="text-align:left">Table</td></tr><tr><td style="text-align:left">Document</td><td style="text-align:left">Row</td></tr><tr><td style="text-align:left">Field</td><td style="text-align:left">Column</td></tr></tbody></table><p>在物理层面：</p><ul><li>Node (节点)：node 是一个运行着的 Elasticsearch 实例，一个 node 就是一个单独的 server</li><li>Cluster (集群)：cluster 是多个 node 的集合</li><li>Shard (分片)：数据分片，一个 index 可能会存在于多个 shard</li></ul><h1>使用</h1><p>接下来，我们看看如何建立索引、创建文档等，就好比在 MySQL 中进行诸如创建数据库，插入数据等操作。</p><h2>添加文档</h2><p>下面，我们将创建一个存储电影信息的 Document：</p><ul><li>Index 的名称为 movie</li><li>Type 为 adventure</li><li>Document 有两个字段：name 和 actors</li></ul><p>我们使用 Elasticsearch 提供的 RESTful API 来执行上述操作，如图所示：</p><p><img src="/2018/08/20/Elasticsearch初体验/1.png" title="图片"></p><ul><li>用 url 表示一个资源，比如 /movie/adventure/1 就表示一个 index 为 movie，type 为 adventure，id 为 1 的 document</li><li>用 http 方法操作资源，如使用 GET 获取资源，使用 POST、PUT 新增或更新资源，使用 DELETE 删除资源等</li></ul><p>我们可以使用 curl 命令来执行上述操作：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -i -X PUT "localhost:9200/movie/adventure/1" -d '&#123;"name": "Life of Pi", "actors": ["Suraj", "Irrfan"]&#125;'</span><br></pre></td></tr></table></figure></p><p>不过，本文推荐使用 httpie，类似 curl，但比 curl 更好用，将上面的命令换成 httpie，如下：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http put :9200/movie/adventure/1 name="Life of Pi" actors:='["Suraj", "Irrfan"]'</span><br></pre></td></tr></table></figure></p><p>上面的命令结果如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Location: /movie/adventure/1</span><br><span class="line">content-encoding: gzip</span><br><span class="line">content-type: application/json; charset=UTF-8</span><br><span class="line">transfer-encoding: chunked</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"_index"</span>: <span class="string">"movie"</span>,</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">        <span class="attr">"failed"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"_type"</span>: <span class="string">"adventure"</span>,</span><br><span class="line">    <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"created"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"result"</span>: <span class="string">"created"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，我们已经成功创建了一个 <strong>_index</strong> 为 movie，<strong>_type</strong> 为 adventure，<strong>_id</strong> 为 1 的文档。</p><p>我们通过 GET 请求来查看这个文档的信息：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http :9200/movie/adventure/1</span><br></pre></td></tr></table></figure></p><p>结果如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">content-encoding: gzip</span><br><span class="line">content-type: application/json; charset=UTF-8</span><br><span class="line">transfer-encoding: chunked</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"_index"</span>: <span class="string">"movie"</span>,</span><br><span class="line">    <span class="attr">"_source"</span>: &#123;</span><br><span class="line">        <span class="attr">"actors"</span>: [</span><br><span class="line">            <span class="string">"Suraj"</span>,</span><br><span class="line">            <span class="string">"Irrfan"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Life of Pi"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"_type"</span>: <span class="string">"adventure"</span>,</span><br><span class="line">    <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"found"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，原始的文档数据存在了 <strong>_source</strong> 字段中。</p><p>如果我们的数据没有 id，也可以让 Elasticsearch 自动为我们生成，此时要使用 POST 请求，形式如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /movie/adventure/</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Life of Pi"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>更新整个文档</h2><p>当我们使用 PUT 方法指明文档的 <strong>_index</strong>, <strong>_type</strong> 和 <strong>_id</strong>时，如果 <strong>_id</strong> 已存在，则新文档会替换旧文档，此时文档的 <strong>_version</strong> 会增加 1，并且 <strong>_created</strong> 字段为 false。比如：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http put :9200/movie/adventure/1 name="Life of Pi"</span><br></pre></td></tr></table></figure></p><p>结果如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">content-encoding: gzip</span><br><span class="line">content-type: application/json; charset=UTF-8</span><br><span class="line">transfer-encoding: chunked</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"_index"</span>: <span class="string">"movie"</span>,</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">        <span class="attr">"failed"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"_type"</span>: <span class="string">"adventure"</span>,</span><br><span class="line">    <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"created"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"result"</span>: <span class="string">"updated"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 GET 请求查看新文档的数据：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http :9200/movie/adventure/1</span><br></pre></td></tr></table></figure></p><p>结果如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">content-encoding: gzip</span><br><span class="line">content-type: application/json; charset=UTF-8</span><br><span class="line">transfer-encoding: chunked</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"_index"</span>: <span class="string">"movie"</span>,</span><br><span class="line">    <span class="attr">"_source"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Life of Pi"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"_type"</span>: <span class="string">"adventure"</span>,</span><br><span class="line">    <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"found"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，actors 这个字段已经不存在了，文档的 <strong>_version</strong> 变成了 2。因此，为了避免在误操作的情况下，原文档被替换，我们可以使用 <strong>_create</strong> 这个 API，表示只在文档不存在的情况下才创建新文档（返回 201 Created），如果文档存在则不做任何操作（返回 409 Conflict），命令如下：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http put :9200/movie/adventure/1/_create name="Life of Pi"</span><br></pre></td></tr></table></figure></p><p>由于文档 id 存在，会返回 409 Conflict。</p><h2>局部更新</h2><p>在有些情况下，我们只想更新文档的局部，而不是整个文档，这时我们可以使用 <strong>_update</strong> 这个 API。</p><p>现在，待更新的文档信息如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"_index"</span>: <span class="string">"movie"</span>,</span><br><span class="line">    <span class="attr">"_source"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Life of Pi"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"_type"</span>: <span class="string">"adventure"</span>,</span><br><span class="line">    <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"found"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最简单的 update 请求接受一个局部文档参数 <strong>doc</strong>，它会合并到现有文档中：将对象合并在一起，存在的标量字段被覆盖，新字段被添加。</p><p>形式如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /movie/adventure/1/_update</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"doc"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"life of pi"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于有嵌套字段，我们可以这样使用 http（这里需要注意使用 POST 方法）：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> echo '&#123;"doc": &#123;"actors": ["Suraj", "Irrfan"]&#125;&#125;' | http post :9200/movie/adventure/1/_update</span><br></pre></td></tr></table></figure></p><p>上面的命令中，我们添加了一个新的字段：actors，结果如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">content-encoding: gzip</span><br><span class="line">content-type: application/json; charset=UTF-8</span><br><span class="line">transfer-encoding: chunked</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"_index"</span>: <span class="string">"movie"</span>,</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">        <span class="attr">"failed"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"_type"</span>: <span class="string">"adventure"</span>,</span><br><span class="line">    <span class="attr">"_version"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"result"</span>: <span class="string">"updated"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，_version 增加了 1，result 的结果是 updated。</p><h2>检索文档</h2><h3>检索某个文档</h3><p>要检索某个文档很简单，我们只需使用 GET 请求并指出文档的 index, type, id 就可以了，比如：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http :9200/movie/adventure/1/</span><br></pre></td></tr></table></figure></p><p>响应内容会包含文档的元信息，文档的原始数据存在 <strong>_source</strong> 字段中。</p><p>我们也可以直接检索出文档的 <strong>_source</strong> 字段，如下：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http :9200/movie/adventure/1/_source</span><br></pre></td></tr></table></figure></p><h3>检索所有文档</h3><p>我们可以使用 <strong>_search</strong> 这个 API 检索出所有的文档，命令如下：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http :9200/movie/adventure/_search</span><br></pre></td></tr></table></figure></p><p>返回结果如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">        <span class="attr">"failed"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"hits"</span>: &#123;</span><br><span class="line">        <span class="attr">"hits"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">                <span class="attr">"_index"</span>: <span class="string">"movie"</span>,</span><br><span class="line">                <span class="attr">"_score"</span>: <span class="number">1.0</span>,</span><br><span class="line">                <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                    <span class="attr">"actors"</span>: [</span><br><span class="line">                        <span class="string">"Suraj"</span>,</span><br><span class="line">                        <span class="string">"Irrfan"</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">"name"</span>: <span class="string">"Life of Pi"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"_type"</span>: <span class="string">"adventure"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"max_score"</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"took"</span>: <span class="number">299</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，<strong>hits</strong> 这个 object 包含了 hits 数组，total 等字段，其中，hits 数组包含了所有的文档，这里只有一个文档，total 表明了文档的数量，默认情况下会返回前 10 个结果。我们也可以设定 <strong>From/Size</strong> 参数来获取某一范围的文档，可参考这里，比如：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http :9200/movie/adventure/_search?from=1&amp;size=5</span><br></pre></td></tr></table></figure></p><p>当不指定 from 和 size 时，会使用默认值，其中 from 的默认值是 0，size 的默认值是 10。</p><h3>检索某些字段</h3><p>有时候，我们只需检索文档的个别字段，这时可以使用 <strong>_source</strong> 参数，多个字段可以使用逗号分隔，如下所示：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http :9200/movie/adventure/1?_source=name</span><br><span class="line"><span class="meta">$</span> http :9200/movie/adventure/1?_source=name,actors</span><br></pre></td></tr></table></figure></p><h3>query string 搜索</h3><p>query string 搜索以 <strong>q=field:value</strong> 的形式进行查询，比如查询 name 字段含有 life 的电影：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http :9200/movie/adventure/_search?q=name:life</span><br></pre></td></tr></table></figure></p><h3>DSL 搜索</h3><p>上面的 query string 搜索比较轻量级，只适用于简单的场合。Elasticsearch 提供了更为强大的 DSL（Domain Specific Language）查询语言，适用于复杂的搜索场景，比如全文搜索。我们可以将上面的 query string 搜索转换为 DSL 搜索，如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /movie/adventure/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123;</span><br><span class="line">            <span class="attr">"name"</span> : <span class="string">"life"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果使用 httpie，可以这样：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> echo '&#123;"query": &#123;"match": &#123;"name": "life"&#125;&#125;&#125;' | http get :9200/movie/adventure/_search</span><br></pre></td></tr></table></figure></p><p>如果使用 curl，可以这样：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -X GET "127.0.0.1:9200/movie/adventure/_search" -d '&#123;"query": &#123;"match": &#123;"name": "life"&#125;&#125;&#125;'</span><br></pre></td></tr></table></figure></p><h2>文档是否存在</h2><p>使用 HEAD 方法查看文档是否存在：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http head :9200/movie/adventure/1</span><br></pre></td></tr></table></figure></p><p>如果文档存在则返回 200，否则返回 404。</p><h2>删除文档</h2><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http delete :9200/movie/adventure/1</span><br></pre></td></tr></table></figure></p><h1>小结</h1><ul><li>Elasticsearch 通过简单的 RESTful API 来隐藏 Lucene 的复杂性，从而让全文搜索变得简单</li><li>在创建文档时，我们可以用 POST 方法指定将文档添加到某个 <strong>_index/_type</strong> 下，来让 Elasticsearch自动生成唯一的 <strong>_id</strong>；而用 PUT 方法指定将文档的 <strong>_index/_type/_id</strong></li></ul><h1>参考资料</h1><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html" target="_blank" rel="noopener">Elasticsearch Reference</a></li><li><a href="https://legacy.gitbook.com/book/looly/elasticsearch-the-definitive-guide-cn/details" target="_blank" rel="noopener">Elasticsearch 权威指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;简介&lt;/h1&gt;
&lt;p&gt;Elasticsearch 是一款稳定高效的分布式搜索和分析引擎，它的底层基于 Lucene，并提供了友好的 RESTful API 来对数据进行操作，还有比较重要的一点是， Elasticsearch 开箱即可用，上手也比较容易。
目前 Elast
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Linux" scheme="https://hhbbz.github.io/tags/Linux/"/>
    
      <category term="Elasticsearch" scheme="https://hhbbz.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal线程安全机制与坑</title>
    <link href="https://hhbbz.github.io/2018/08/12/ThreadLocal%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%9D%91/"/>
    <id>https://hhbbz.github.io/2018/08/12/ThreadLocal线程安全机制与坑/</id>
    <published>2018-08-12T01:42:22.000Z</published>
    <updated>2019-12-06T08:13:14.142Z</updated>
    
    <content type="html"><![CDATA[<p>Java 多线程类库对于共享数据的读写控制主要采用锁机制保证线程安全，本文所要探究的 ThreadLocal 则采用了一种完全不同的策略。ThreadLocal 不是用来解决共享数据的并发访问问题的，它让每个线程都将目标数据复制一份作为线程私有，后续对于该数据的操作都是在各自私有的副本上进行，线程之间彼此相互隔离，也就不存在竞争问题。</p><p>下面的例子演示了 ThreadLocal 的典型应用场景，在 jdk 1.8 之前，如果我们希望对日期和时间进行格式化操作，则需要使用 SimpleDateFormat 类，而我们知道它是是非线程安全的，在多线程并发执行时会出现一些奇怪的问题，而对于该类使用的最佳实践则是采用 ThreadLocal 进行包装，以保证每个线程都有一份属于自己的 SimpleDateFormat 对象，如下所示：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;SimpleDateFormat&gt; sdf = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1>一. 线程安全机制</h1><p>那么 ThreadLocal 是怎么做到让修饰的对象能够在每个线程中各持有一份呢？我们先来简单的概括一下：在 ThreadLocal 中定义了一个静态内部类 ThreadLocalMap，可以将其理解为一个特有的 Map 类型，而在 Thread 类中声明了一个 ThreadLocalMap 类型的属性 threadLocals，所以针对每个 Thread 对象，也就是每个线程来说都包含了一个 ThreadLocalMap 对象，即每个线程都有一个属于自己的内存数据库，而数据库中存储的就是我们用 ThreadLocal 修饰的对象，这里的 key 就是对应的 ThreadLocal 对象，而 value 就是我们记录在 ThreadLocal 中的值。当希望获取该对象时，我们首先需要拿到当前线程对应的 Thread 对象，然后获取到该对象对应的 threadLocals 属性，也就拿到了线程私有的内存数据库，最后以 ThreadLocal 对象为 key 获取到其修饰的目标值。整个过程还是有点绕的，可以借助下面这幅图进行理解。</p><p><img src="/2018/08/12/ThreadLocal线程安全机制与坑/1.png" title="图片"></p><h2>1.1 内存数据库 ThreadLocalMap</h2><p>接下来看一下相应的源码实现，首先来看一下内部定义的 ThreadLocalMap 静态内部类：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弱引用的key，继承自 WeakReference</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** ThreadLocal 修饰的对象 */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 初始化大小，必须是二次幂 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">/** 承载键值对的表，长度必须是二次幂 */</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    <span class="comment">/** 记录键值对表的大小 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 再散列阈值 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        Entry[] parentTable = parentMap.table;</span><br><span class="line">        <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">        setThreshold(len);</span><br><span class="line">        table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            Entry e = parentTable[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Object value = key.childValue(e.value);</span><br><span class="line">                    Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                    <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    table[h] = c;</span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略相应的方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ThreadLocalMap 是一个定制化的 Map 实现，这里可以简单将其理解为一般的 Map，用作键值存储的内存数据库，至于为什么要专门实现而不是复用已有的 HashMap，我们在后面进行说明。</p><h2>1.2 ThreadLocal 方法实现</h2><p>了解了 ThreadLocalMap 的定义，我们再来看一下 ThreadLocal 的实现。对于 ThreadLocal 来说，对外暴露的方法主要有 get、set，以及 remove 三个，下面逐一来看：</p><ul><li>获取线程私有值：get()</li></ul><p>与一般的 Map 取值操作不同，这里的 get() 并没有要求提供查询的 key，也正如前面所说的，这里的 key 就是调用 get() 方法的对象自身：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对象的 threadLocals 属性</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 以 ThreadLocal 对象为 key 获取目标线程私有值</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果当前线程对应的内存数据库 map 对象还未创建，则会调用 setInitialValue() 方法执行创建，如果在构造 ThreadLocal 对象时覆盖实现了 initialValue() 方法，则会调用该方法获取构造的初始化值并记录到创建的 map 对象中：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用模板方法 initialValue 获取指定的初始值</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 以当前 ThreadLocal 对象为 key 记录初始值</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 创建 map 并记录初始值</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>添加线程私有值：set(T value)</li></ul><p>再来看一下 set 方法，因为 key 就是当前 ThreadLocal 对象，所以 set 方法也不需要指定 key：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对象的 threadLocals 属性</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 以当前 ThreadLocal 对象为 key 记录线程私有值</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>和 get 方法的流程大致一样，都是操作当前线程私有的内存数据库 ThreadLocalMap，并记录目标值。</p><ul><li>删除线程私有值：remove()</li></ul><p>remove 方法以当前 ThreadLocal 为 key，从当前线程内存数据库 ThreadLocalMap 中删除目标值，具体逻辑比较简单：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 以当前 ThreadLocal 对象为 key</span></span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ThreadLocal 对外暴露的功能虽然有点小神奇，但是具体对应到内部实现并没有什么复杂的逻辑，如果我们把每个线程持有的专属 ThreadLocalMap 对象理解为当前线程的私有数据库，那么也就不难理解 ThreadLocal 的运行机制，每个线程自己维护自己的数据，彼此相互隔离，不存在竞争，也就没有线程安全问题可言。</p><h1>二. 真的就高枕无忧了吗？</h1><p>虽然对于每个线程来说数据是隔离的，但这也不表示任何对象丢到 ThreadLocal 中就万事大吉了，思考一下下面几种情况：</p><pre><code>1. 如果记录在 ThreadLocal 中的是一个线程共享的外部对象呢？2. 引入线程池，情况又会有什么变化？3. 如果 ThreadLocal 被 static 关键字修饰呢？</code></pre><p>先来看 <strong>第一个问题</strong> ，如果我们记录的是一个外部线程共享的对象，虽然我们以当前线程私有的 ThreadLocal 对象作为 key 对其进行了存储，但是恶魔终究是恶魔，共享的本质并不会因此而改变，这种情况下的访问还是需要进行同步控制，最好的方法就是从源头屏蔽掉这类问题。我们来举个例子：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalWithSharedInstance</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list 是一个事实共享的实例，即使被 ThreadLocal 修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;List&lt;String&gt;&gt; threadLocal = ThreadLocal.withInitial(() -&gt; list);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            List&lt;String&gt; li = threadLocal.get();</span><br><span class="line">            li.add(Thread.currentThread().getName() + <span class="string">"_"</span> + RandomUtils.nextInt(<span class="number">0</span>, <span class="number">10</span>));</span><br><span class="line">            threadLocal.set(li);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"[Thread-"</span> + Thread.currentThread().getName() + <span class="string">"], list="</span> + threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread ta = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadLocalWithSharedInstance(), <span class="string">"a"</span>);</span><br><span class="line">        Thread tb = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadLocalWithSharedInstance(), <span class="string">"b"</span>);</span><br><span class="line">        Thread tc = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadLocalWithSharedInstance(), <span class="string">"c"</span>);</span><br><span class="line">        ta.start(); ta.join();</span><br><span class="line">        tb.start(); tb.join();</span><br><span class="line">        tc.start(); tc.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上程序最终的输出如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Thread-a], list=[a_2, a_7, a_4, a_5, a_7]</span><br><span class="line">[Thread-b], list=[a_2, a_7, a_4, a_5, a_7, b_3, b_3, b_4, b_7, b_7]</span><br><span class="line">[Thread-c], list=[a_2, a_7, a_4, a_5, a_7, b_3, b_3, b_4, b_7, b_7, c_8, c_3, c_4, c_7, c_5]</span><br></pre></td></tr></table></figure></p><p>可以看到虽然使用了 ThreadLocal 修饰，但是 list 还是以共享的方式在多个线程之间被访问，如果不加同步控制，则会存在线程安全问题。</p><p>再来看 <strong>第二个问题</strong> ，相对问题一来说引入线程池就更加可怕，因为大部分时候我们都不会意识到问题的存在，直到代码暴露出奇怪的现象，这个时候并没有违背线程私有的本质，只是一个线程被复用来处理多个业务，而这个被线程私有的对象也会在多个业务之间被 “共享”。例如：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalWithThreadPool</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;List&lt;String&gt;&gt; threadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"thread-"</span> + Thread.currentThread().getId() + <span class="string">" init thread local"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            List&lt;String&gt; li = threadLocal.get();</span><br><span class="line">            li.add(Thread.currentThread().getId() + <span class="string">"_"</span> + RandomUtils.nextInt(<span class="number">0</span>, <span class="number">10</span>));</span><br><span class="line">            threadLocal.set(li);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"[Thread-"</span> + Thread.currentThread().getId() + <span class="string">"], list="</span> + threadLocal.get());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cpu core size : "</span> + NCPU);</span><br><span class="line">        List&lt;Callable&lt;Boolean&gt;&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;(NCPU * <span class="number">2</span>);</span><br><span class="line">        ThreadLocalWithThreadPool tl = <span class="keyword">new</span> ThreadLocalWithThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU * <span class="number">2</span>; i++) &#123;</span><br><span class="line">            tasks.add(tl);</span><br><span class="line">        &#125;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        List&lt;Future&lt;Boolean&gt;&gt; futures = es.invokeAll(tasks);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Future&lt;Boolean&gt; future : futures) &#123;</span><br><span class="line">            future.get();</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上程序的最终输出如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cpu core size : 8</span><br><span class="line">thread-12 init thread local</span><br><span class="line">thread-11 init thread local</span><br><span class="line">[Thread-12], list=[12_8, 12_8, 12_4, 12_0, 12_1]</span><br><span class="line">[Thread-11], list=[11_3, 11_3, 11_4, 11_8, 11_4]</span><br><span class="line">[Thread-12], list=[12_8, 12_8, 12_4, 12_0, 12_1, 12_6, 12_7, 12_8, 12_8, 12_8]</span><br><span class="line">[Thread-11], list=[11_3, 11_3, 11_4, 11_8, 11_4, 11_0, 11_2, 11_1, 11_7, 11_9]</span><br><span class="line">[Thread-12], list=[12_8, 12_8, 12_4, 12_0, 12_1, 12_6, 12_7, 12_8, 12_8, 12_8, 12_8, 12_2, 12_8, 12_0, 12_6]</span><br><span class="line">[Thread-11], list=[11_3, 11_3, 11_4, 11_8, 11_4, 11_0, 11_2, 11_1, 11_7, 11_9, 11_0, 11_6, 11_1, 11_2, 11_9]</span><br><span class="line">[Thread-12], list=[12_8, 12_8, 12_4, 12_0, 12_1, 12_6, 12_7, 12_8, 12_8, 12_8, 12_8, 12_2, 12_8, 12_0, 12_6, 12_6, 12_3, 12_3, 12_1, 12_1]</span><br><span class="line">[Thread-11], list=[11_3, 11_3, 11_4, 11_8, 11_4, 11_0, 11_2, 11_1, 11_7, 11_9, 11_0, 11_6, 11_1, 11_2, 11_9, 11_7, 11_5, 11_0, 11_6, 11_9]</span><br><span class="line">[Thread-12], list=[12_8, 12_8, 12_4, 12_0, 12_1, 12_6, 12_7, 12_8, 12_8, 12_8, 12_8, 12_2, 12_8, 12_0, 12_6, 12_6, 12_3, 12_3, 12_1, 12_1, 12_0, 12_0, 12_1, 12_9, 12_5]</span><br><span class="line">[Thread-11], list=[11_3, 11_3, 11_4, 11_8, 11_4, 11_0, 11_2, 11_1, 11_7, 11_9, 11_0, 11_6, 11_1, 11_2, 11_9, 11_7, 11_5, 11_0, 11_6, 11_9, 11_2, 11_7, 11_0, 11_8, 11_0]</span><br><span class="line">[Thread-12], list=[12_8, 12_8, 12_4, 12_0, 12_1, 12_6, 12_7, 12_8, 12_8, 12_8, 12_8, 12_2, 12_8, 12_0, 12_6, 12_6, 12_3, 12_3, 12_1, 12_1, 12_0, 12_0, 12_1, 12_9, 12_5, 12_3, 12_6, 12_6, 12_0, 12_9]</span><br><span class="line">[Thread-11], list=[11_3, 11_3, 11_4, 11_8, 11_4, 11_0, 11_2, 11_1, 11_7, 11_9, 11_0, 11_6, 11_1, 11_2, 11_9, 11_7, 11_5, 11_0, 11_6, 11_9, 11_2, 11_7, 11_0, 11_8, 11_0, 11_0, 11_9, 11_2, 11_7, 11_2]</span><br><span class="line">[Thread-12], list=[12_8, 12_8, 12_4, 12_0, 12_1, 12_6, 12_7, 12_8, 12_8, 12_8, 12_8, 12_2, 12_8, 12_0, 12_6, 12_6, 12_3, 12_3, 12_1, 12_1, 12_0, 12_0, 12_1, 12_9, 12_5, 12_3, 12_6, 12_6, 12_0, 12_9, 12_5, 12_7, 12_7, 12_9, 12_7]</span><br><span class="line">[Thread-11], list=[11_3, 11_3, 11_4, 11_8, 11_4, 11_0, 11_2, 11_1, 11_7, 11_9, 11_0, 11_6, 11_1, 11_2, 11_9, 11_7, 11_5, 11_0, 11_6, 11_9, 11_2, 11_7, 11_0, 11_8, 11_0, 11_0, 11_9, 11_2, 11_7, 11_2, 11_4, 11_9, 11_7, 11_5, 11_5]</span><br><span class="line">[Thread-12], list=[12_8, 12_8, 12_4, 12_0, 12_1, 12_6, 12_7, 12_8, 12_8, 12_8, 12_8, 12_2, 12_8, 12_0, 12_6, 12_6, 12_3, 12_3, 12_1, 12_1, 12_0, 12_0, 12_1, 12_9, 12_5, 12_3, 12_6, 12_6, 12_0, 12_9, 12_5, 12_7, 12_7, 12_9, 12_7, 12_6, 12_1, 12_7, 12_8, 12_7]</span><br><span class="line">[Thread-11], list=[11_3, 11_3, 11_4, 11_8, 11_4, 11_0, 11_2, 11_1, 11_7, 11_9, 11_0, 11_6, 11_1, 11_2, 11_9, 11_7, 11_5, 11_0, 11_6, 11_9, 11_2, 11_7, 11_0, 11_8, 11_0, 11_0, 11_9, 11_2, 11_7, 11_2, 11_4, 11_9, 11_7, 11_5, 11_5, 11_8, 11_5, 11_0, 11_2, 11_2]</span><br></pre></td></tr></table></figure></p><p>在我的 8 核处理器上，我用一个大小为 2 的线程池进行了模拟，可以看到初始化方法被调用了两次，所有线程的操作都是复用这两个线程。回忆一下前文所说的，ThreadLocal 的本质就是每个线程维护一个线程私有的内存数据库来记录线程私有的对象，但是在线程池情况下线程是会被复用的，也就是说线程私有的内存数据库也会被复用，如果在一个线程被使用完准备回放到线程池中之前，我们没有对记录在数据库中的数据执行清理，那么这部分数据就会被下一个复用该线程的业务看到，从而间接的共享了该部分数据。</p><p>最后我们再来看一下 <strong>第三个问题</strong> ，我们尝试将 ThreadLocal 对象用 static 关键字进行修饰：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalWithStaticEmbellish</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;List&lt;String&gt;&gt; threadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"thread-"</span> + Thread.currentThread().getName() + <span class="string">" init thread local"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            List&lt;String&gt; li = threadLocal.get();</span><br><span class="line">            li.add(Thread.currentThread().getId() + <span class="string">"_"</span> + RandomUtils.nextInt(<span class="number">0</span>, <span class="number">10</span>));</span><br><span class="line">            threadLocal.set(li);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"[Thread-"</span> + Thread.currentThread().getName() + <span class="string">"], list="</span> + threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ThreadLocalWithStaticEmbellish tl = <span class="keyword">new</span> ThreadLocalWithStaticEmbellish();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(tl, String.valueOf((<span class="keyword">char</span>) (i + <span class="number">97</span>)));</span><br><span class="line">            thread.start(); thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上程序的最终输出如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">thread-a init thread local</span><br><span class="line">[Thread-a], list=[11_4, 11_4, 11_4, 11_8, 11_0]</span><br><span class="line">thread-b init thread local</span><br><span class="line">[Thread-b], list=[12_0, 12_9, 12_0, 12_3, 12_3]</span><br><span class="line">thread-c init thread local</span><br><span class="line">[Thread-c], list=[13_6, 13_7, 13_5, 13_2, 13_0]</span><br><span class="line">thread-d init thread local</span><br><span class="line">[Thread-d], list=[14_1, 14_5, 14_5, 14_9, 14_2]</span><br><span class="line">thread-e init thread local</span><br><span class="line">[Thread-e], list=[15_4, 15_2, 15_6, 15_0, 15_8]</span><br><span class="line">thread-f init thread local</span><br><span class="line">[Thread-f], list=[16_7, 16_3, 16_8, 16_0, 16_0]</span><br><span class="line">thread-g init thread local</span><br><span class="line">[Thread-g], list=[17_6, 17_3, 17_8, 17_7, 17_1]</span><br><span class="line">thread-h init thread local</span><br><span class="line">[Thread-h], list=[18_0, 18_4, 18_5, 18_9, 18_3]</span><br><span class="line">thread-i init thread local</span><br><span class="line">[Thread-i], list=[19_7, 19_3, 19_7, 19_2, 19_0]</span><br></pre></td></tr></table></figure></p><p>由程序运行结果可以看到 static 修饰并没有引出什么问题，实际上这也是很容易理解的，ThreadLocal 采用 static 修饰仅仅是让数据库中记录的 key 是一样的，但是每个线程的内存数据库还是私有的，并没有被共享，就像不同的公司都有自己的用户信息表，即使一些公司之间的用户 ID 是一样的，但是对应的用户数据却是完全隔离的。</p><p>以上例子演示了一开始抛出的三个问题，其中问题一和问题二都是 ThreadLocal 使用过程中的小地雷。例子举的不一定恰当，实际中可能也不一定会如示例中这样去使用 ThreadLocal，主要还是为了传达一些意识。如果明白了 ThreadLocal 的内部实现细节，就能够很自然的绕过这些小地雷。</p><h1>三. 真的会内存泄露吗？</h1><p>关于 ThreadLocal 导致内存泄露的问题，曾经有一段时间在网上争得沸沸扬扬，那么到底会不会导致内存泄露呢？这里先给出答案:</p><pre><code>如果使用不恰当，存在内存泄露的可能性。</code></pre><p>我们来分析一下内存泄露的条件和原因，在最开始看 ThreadLocal 源码的时候，我就有一个疑问，<strong>ThreadLocal 为什么要专门实现 ThreadLocalMap，而不是采用已有的 HashMap 代替</strong>？后来分析具体实现时看到执行存储时的 key 为当前 ThreadLocal 对象，不需要专门指定 key 能够在一定程度上简化使用，但这并不足以为此专门去实现 ThreadLocalMap。继续阅读我发现 ThreadLocalMap 在实现 Entry 的时候有些奇怪，居然继承了 WeakReference：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从而让 key 成为一个弱引用，我们知道弱引用对象拥有非常短暂的生命周期，在垃圾收集器线程扫描其所管辖的内存区域过程中，一旦发现了弱引用对象，不管当前内存空间是否足够都会回收它的内存。也就是说这样的设计会很容易导致 ThreadLocal 对象被回收，线程所执行任务的时间长度是不固定的，这样的设计能够方便垃圾收集器回收线程私有的变量。</p><p>所以作者这样设计的目的是为了防止内存泄露，那怎么就变成了被很多文章所分析的是内存泄漏的导火索呢？这些文章的共同观点就是 key 被回收了，但是 value 是一个强引用没有被回收，这些 value 就变成了一个个的僵尸。这样的分析没有错，value 确实存在，且和线程是同生命周期的，但是如下策略可以保证尽量避免内存泄露：</p><pre><code>1. ThreadLocal 在每次执行 get 和 set 操作的时候都会去清理 key 为 null 的 value 值2. value 与线程同生命周期，线程死亡之时，也是 value 被 GC 之日</code></pre><p>策略一没啥好说的，看看源码就知道，我们来举例验证一下策略二：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalWithMemoryLeak</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">My50MB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">50</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.finalize();</span><br><span class="line">            System.out.println(<span class="string">"gc my 50 mb"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.finalize();</span><br><span class="line">            System.out.println(<span class="string">"gc my thread local"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyThreadLocal&lt;My50MB&gt; threadLocal = <span class="keyword">new</span> MyThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread-"</span> + Thread.currentThread().getId() + <span class="string">" is running"</span>);</span><br><span class="line">        threadLocal.set(<span class="keyword">new</span> My50MB());</span><br><span class="line">        threadLocal = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService es = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;Boolean&gt; future = es.submit(<span class="keyword">new</span> ThreadLocalWithMemoryLeak());</span><br><span class="line">        future.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// gc my thread local</span></span><br><span class="line">        System.out.println(<span class="string">"do gc"</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sleep 60s</span></span><br><span class="line">        System.out.println(<span class="string">"sleep 60s"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// gc my 50 mb</span></span><br><span class="line">        System.out.println(<span class="string">"do gc"</span>);</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上程序的最终输出如下</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-11 is running</span><br><span class="line">do gc</span><br><span class="line">gc my thread local</span><br><span class="line">sleep 60s</span><br><span class="line">do gc</span><br><span class="line">gc my 50 mb</span><br></pre></td></tr></table></figure></p><p>可以看到 value 最终还是被 GC 了，虽然第一次 GC 的时候没有被回收，这也验证 value 和线程是同生命周期的，之所以示例中等待 60 秒是因为 Executors.newCachedThreadPool() 中的线程默认生命周期是 60 秒，如果生命周期内该线程没有被再次复用则会死亡，我们这里就是要等待线程死亡，一但线程死亡，value 也就被 GC 了。所以 <strong>出现内存泄露的前提必须是持有 value 的线程一直存活</strong> ，这在使用线程池时是很正常的，在这种情况下 value 一直不会被 GC，因为线程对象与 value 之间维护的是强引用。此外就是 <strong>后续线程执行的业务一直没有调用 ThreadLocal 的 get 或 set 方法，导致不会主动去删除 key 为 null 的 value 对象</strong> ，在满足这两个条件下 value 对象一直常驻内存，所以存在内存泄露的可能性。</p><p>那么我们应该怎么避免呢？前面我们分析过线程池情况下使用 ThreadLocal 存在小地雷，这里的内存泄露一般也都是发生在线程池的情况下，所以在使用 ThreadLocal 时，对于不再有效的 value 主动调用一下 remove 方法来进行清除，从而消除隐患，这也算是最佳实践吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 多线程类库对于共享数据的读写控制主要采用锁机制保证线程安全，本文所要探究的 ThreadLocal 则采用了一种完全不同的策略。ThreadLocal 不是用来解决共享数据的并发访问问题的，它让每个线程都将目标数据复制一份作为线程私有，后续对于该数据的操作都是在各
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://hhbbz.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CompletableFuture终极指南</title>
    <link href="https://hhbbz.github.io/2018/08/04/CompletableFuture%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/"/>
    <id>https://hhbbz.github.io/2018/08/04/CompletableFuture终极指南/</id>
    <published>2018-08-04T03:37:00.000Z</published>
    <updated>2018-08-06T02:01:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、简介</h1><p>java.util.concurrent.CompletableFuture继承于java.util.concurrent.Future，它本身具备Future的所有特性，并且基于JDK1.8的流式编程以及Lambda表达式等实现一元操作符、异步性以及事件驱动编程模型，它的灵活性和更强大的功能是Future无法比拟的。它提供了一共有50多种Api，这些Api的注释比较少，命名也比较生涩，下面将会分类讲解它们的使用方式。CompletableFuture吸收了所有ListenableFuture(Guava)和SettableFuture的优点。此外，内置的lambda表达式使它更接近于Scala/Akka futures。CompletableFuture有两个主要的方面优于Future – 异步回调/转换，这能使得任何线程在任何时刻都可以设置CompletableFuture的值。</p><h1>二、使用流程简述</h1><p>首先，简单地创建新的CompletableFuture并且给你的客户端：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">ask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端代码调用ask().get()，它将永远阻塞，直到CompletableFuture回调，下面是一种回调方式：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">future.complete(<span class="string">"42"</span>);</span><br></pre></td></tr></table></figure></p><p>此时此刻所有客户端 <strong><em>Future(CompletableFuture).get()</em></strong> 将得到字符串的结果。注意的是： <strong><em>CompletableFuture.complete()</em></strong> 只能调用一次，后续调用将被忽略。但也有一个后门叫做 <strong><em>CompletableFuture.obtrudeValue()</em></strong> 覆盖Future之前的值，请小心使用。有时你想处理 <strong><em>CompletableFuture.complete()</em></strong> 调用过程抛出的异常，如果你想进一步传递异常，可以用 <strong><em>CompletableFuture.completeExceptionally(ex)</em></strong> (或者用 <strong><em>obtrudeException(ex)</em></strong> 这样更强大的方法覆盖前面的异常)。 completeExceptionally()也能解锁所有等待的客户端。前面说到get()（永久阻塞等待），其实还有 <strong><em>get（long timeout，TimeUnit unit）</em></strong> 可以设置超时时间（超时会抛出异常），也有 <strong><em>CompletableFuture.join( )</em></strong>（join方法在错误处理方面有着细微的变动。但总体上，它和get方法是一样的）。然后也有 <strong><em>CompletableFuture.getNow(valueIfAbsent)</em></strong> ，这个方法没有阻塞，但是如果Future还没完成将返回默认值，这使得当构建那种我们不想等太久的健壮系统时非常有用。最后的方法静态 <strong><em>completedFuture(value)</em></strong> 来返回已经完成Future的对象，当测试或者写一些适配器层时可能非常有用。</p><h1>三、CompletableFuture主要Api详述</h1><h2>声明</h2><p>如果CompletableFuture的方法没有参数Executor并且以…Async结尾，它将会使用 <strong><em>ForkJoinPool.commonPool()</em></strong> (在JDK8中的通用线程池，基于Fork/join线程池和任务窃取实现），这适用于CompletableFuture类中的大多数的方法。所以下面分析的时候可能会直接跳过命名为…Async的方法。</p><h2>创建和获取CompletableFuture</h2><p>使用 <strong><em>new</em></strong> 关键字新建CompletableFuture实例并不是唯一的选择，CompletableFuture提供了静态工厂方法用于创建自身的实例：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span>;</span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>runAsync()易于理解，注意它需要Runnable，因此它返回CompletableFuture&lt;Void&gt;作为Runnable不返回任何值。如果你需要处理异步操作并返回结果，使用Supplier&lt;U&gt;，它是一个函数式接口，接口如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以这样使用Supplier&lt;U&gt;：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...long running...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"42"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, executor);</span><br></pre></td></tr></table></figure></p><p>换成Lambda表达式：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">finalCompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//...long running...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"42"</span>;</span><br><span class="line">&#125;, executor)；</span><br></pre></td></tr></table></figure></p><h2>转换–CompletableFuture.thenApply()</h2><p>apply一般翻译为’作用于’，但是在CompletableFuture中，***thenApply()***起到转换结果的作用，总结来说就是叠加多个CompletableFuture的功能，把多个CompletableFuture组合在一起，跨线程池进行异步调用，调用的过程就是结果转换的过程。先看下这些方法：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn, Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>其中Function&lt;? super T,? extends U&gt;是函数式接口，此接口如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">    ...<span class="comment">//省略其他流式方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用例子：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; f1 =  = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"42"</span>;</span><br><span class="line">&#125;, executor)；</span><br><span class="line">CompletableFuture&lt;Integer&gt; f2 = f1.thenApply(Integer::parseInt);</span><br><span class="line">CompletableFuture&lt;Double&gt; f3 = f2.thenApply(r -&gt; r * r * Math.PI);</span><br></pre></td></tr></table></figure></p><p>或者直接使用流式编程：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Double&gt; f3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"42"</span>;</span><br><span class="line">&#125;, executor).thenApply(Integer::parseInt).thenApply(r -&gt; r * r * Math.PI);</span><br></pre></td></tr></table></figure></p><h2>终端运行(消费)–CompletableFuture.thenRun()/CompletableFuture.thenAccept()</h2><p>CompletableFuture有两种典型的”最终”阶段方法，其实就是Lambda的终端方法，使用的是Consumer接口(消费操作的接口)。当CompletableFuture的结果已经准备好，thenAccept()执行最终消费操作，thenRun()执行Runnable，没有返回值（或者说返回结果为Void）。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; block)</span></span>;</span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; block)</span></span>;</span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; block,Executor executor)</span></span>;</span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenRun</span><span class="params">(Runnable action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>下面是一个例子：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">future.thenAcceptAsync(dbl -&gt; log.debug(<span class="string">"Result: &#123;&#125;"</span>, dbl), executor);</span><br><span class="line">log.debug(<span class="string">"Continuing"</span>);</span><br></pre></td></tr></table></figure></p><p>thenAccept( )/thenRun( )方法并没有发生阻塞（即使没有明确的executor)。它们像事件侦听器。上例中”Continuing”消息将立即出现，但是这个时候thenAcceptAsync()有可能尚未执行完。thenAccept()和thenRun()的区别是：thenAccept()是针对结果进行消费，因为入参是Consumer函数式接口，有入参无返回值，而thenRun()它的入参是一个Runnable的实例，表示当得到上一步的结果时的操作，也就是当得到上一步的结果则异步执行Runnable。</p><h2>异常处理</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"test exception"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            future.completeExceptionally(e);</span><br><span class="line">            future.complete(<span class="string">"test success"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">System.out.println(future.get());</span><br><span class="line"><span class="comment">//结果（触发了completeExceptionally后，complete将会失效）：</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.util.concurrent.ExecutionException: java.lang.RuntimeException: test exception</span><br><span class="line">at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:<span class="number">357</span>)</span><br><span class="line">at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:<span class="number">1895</span>)</span><br><span class="line">at org.throwable.TestGitA.main(TestGitA.java:<span class="number">22</span>)</span><br><span class="line">Caused by: java.lang.RuntimeException: test exception</span><br><span class="line">at org.throwable.TestGitA.main(TestGitA.java:<span class="number">17</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>补偿型的例子：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"测试一下异常情况"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">     &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">         System.out.println(e.getMessage());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">     &#125;).join();</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">java.lang.RuntimeException: 测试一下异常情况</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>全方位型的例子：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意这里OK为String类型</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; safe = future.handle((ok, ex) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ok != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(ok);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.warn(<span class="string">"Problem"</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2>CompletableFuture之间建立关联</h2><h3>CompletableFuture的”串联”–CompletableFuture.thenCompose()</h3><p>thenCompose()方法允许你对两个异步操作进行流水线，第一个操作完成时，将其结果作为参数传递给第二个操作。你可以创建两个CompletableFuture对象，对第一个CompletableFuture对象调用thenCompose() ，并向其传递一个函数。当第一个CompletableFuture执行完毕后，它的结果将作为该函数的参数，这个函数的返回值是以第一个CompletableFuture的返回做输入计算出的第二个CompletableFuture对象。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,CompletableFuture&lt;U&gt;&gt; fn)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,CompletableFuture&lt;U&gt;&gt; fn)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,CompletableFuture&lt;U&gt;&gt; fn,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>thenCompose()是一个重要的方法，它允许构建健壮的和异步的管道，没有阻塞和等待的中间步骤。在下面的事例中，仔细观察thenApply()(map)和thenCompose()（flatMap）的类型和差异，calculateRelevance()方法返回CompletableFuture实例：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Document&gt; docFuture = <span class="comment">//...</span></span><br><span class="line">CompletableFuture&lt;CompletableFuture&lt;Double&gt;&gt; f =  docFuture.thenApply(<span class="keyword">this</span>::calculateRelevance);</span><br><span class="line">CompletableFuture&lt;Double&gt; relevanceFuture = docFuture.thenCompose(<span class="keyword">this</span>::calculateRelevance);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Double&gt; <span class="title">calculateRelevance</span><span class="params">(Document doc)</span>  <span class="comment">//...</span></span></span><br></pre></td></tr></table></figure></p><h3>CompletableFuture的”并联”–CompletableFuture.thenCombine()</h3><p>thenCombine()用于连接两个独立的CompletableFuture，它接收名为 BiFunction 的第二参数，这个参数定义了当两个CompletableFuture 对象完成计算后结果如何合并，返回携带计算合并结果的一个新的CompletableFuture。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombine</span><span class="params">(CompletableFuture&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span>;</span><br><span class="line">&lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletableFuture&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span>;</span><br><span class="line">&lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletableFuture&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>假设你有两个CompletableFuture，一个加载Customer另一个加载最近的Shop。他们彼此完全独立，但是当他们完成时，您想要使用它们的值来计算Route。下面是一个例子：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Customer&gt; customerFuture = loadCustomerDetails(<span class="number">123</span>);  <span class="comment">//省略loadCustomerDetails方法代码</span></span><br><span class="line">CompletableFuture&lt;Shop&gt; shopFuture = closestShop();  <span class="comment">//省略closestShop方法代码</span></span><br><span class="line">CompletableFuture&lt;Route&gt; routeFuture = customerFuture.thenCombine(shopFuture, (cust, shop) -&gt; findRoute(cust, shop));</span><br><span class="line">   </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Route <span class="title">findRoute</span><span class="params">(Customer customer, Shop shop)</span> <span class="comment">//...</span></span></span><br></pre></td></tr></table></figure></p><p>新建customerFuture和shopFuture。那么routeFuture包装它们然后“等待”它们完成。当它们的结果准备好了，它会运行我们提供的函数来结合所有的结果(findRoute())。当两个基本的CompletableFuture实例完成并且findRoute()也完成时，这样routeFuture将会完成。</p><h2>结果记录–CompletableFuture.whenComplete()</h2><p>***CompletableFuture.whenComplete()***的作用是CompletableFuture运行完成时，对结果的记录操作，记录的操作由函数BiConsumer&lt;? super T, ? super Throwable&gt;完成，一般BiConsumer这种消费操作应该是终端操作，但是whenComplete返回的是CompletableFuture的接口的实例，这个实例就是调用whenComplete的原始CompletableFuture对象。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">CompletionStage&lt;T&gt; <span class="title">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>一个使用例子如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"测试一下异常情况"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">     &#125;).whenComplete((s, t) -&gt; &#123;</span><br><span class="line">         System.out.println(s);</span><br><span class="line">         System.out.println(t.getMessage());</span><br><span class="line">     &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">         System.out.println(e.getMessage());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">     &#125;).join();</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">java.lang.RuntimeException: 测试一下异常情况</span><br><span class="line">java.lang.RuntimeException: 测试一下异常情况</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>这里也可以看出，如果使用了exceptionally，就会对最终的结果产生影响，也就证明了whenComplete返回的是原始的CompletableFuture对象。</p><h2>结果处理–CompletableFuture.handle()</h2><p><strong><em>CompletableFuture.handle()</em></strong> 的作用是CompletableFuture运行完成时，对结果的处理。这里的完成时有两种情况，一种是正常执行，返回预期的值。另外一种是遇到异常抛出造成程序的中断。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">handle</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>一个出现异常时的例子：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出现异常</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"测试一下异常情况"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">    &#125;).handle((s, t) -&gt; &#123;   <span class="comment">//这里t的参数类型为Throwable。</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hello world"</span>; <span class="comment">//这里是异常不为null时候的逻辑，可以选择补偿，也可以直接抛出异常t，一旦抛出异常，调用join（）的时候异常会外抛。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;).join();</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>一个未出现异常时的例子：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">    &#125;).handle((s, t) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hello world"</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;   <span class="comment">//未出现异常，实际上走到这一步</span></span><br><span class="line">    &#125;).join();</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">s1</span><br></pre></td></tr></table></figure></p><h2>合并消费–CompletableFuture.thenAcceptBoth()</h2><p><strong><em>CompletableFuture.thenAcceptBoth()</em></strong> 用于连接两个独立的CompletableFuture，它接收名为BiConsumer的第二参数，这个参数定义了当两个CompletableFuture对象完成计算后，结果如何消费，有点像thenCombine，但是对于两个CompletableFuture的计算操作是终端操作，没有返回值(或者说返回结果为Void类型)。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action, Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>一个例子如下，5000毫秒后控制台输出”hello world”：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">     &#125;).thenAcceptBoth(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"world"</span>;</span><br><span class="line">     &#125;), (s1, s2) -&gt; System.out.println(s1 + <span class="string">" "</span> + s2));</span><br></pre></td></tr></table></figure></p><h2>合并执行–CompletableFuture.runAfterBoth()</h2><p><strong><em>CompletableFuture.runAfterBoth()</em></strong> 用于连接两个独立的CompletableFuture，不关心两个CompletableFuture的计算结果，当两个CompletableFuture执行完成后，执行Runnable。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>一个例子如下，5000毫秒后控制台输出”hello world”：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">     &#125;).runAfterBothAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"s2"</span>;</span><br><span class="line">     &#125;), () -&gt; System.out.println(<span class="string">"hello world"</span>));  <span class="comment">//() -&gt; System.out.println("hello world")；就是Runnable的Lambda实现</span></span><br></pre></td></tr></table></figure></p><h2>时间优先度执行</h2><p>CompletableFuture中有部分的API可以等待第一个完成的CompletableFuture再进行后续操作。当你有两个相同类型任务的结果时就显得非常方便，你只要关心响应时间就行了，没有哪个任务是优先的（这类型的方法的好处是只关注响应的时间，除了时间这个优先级限定，没有其他优先级）。</p><h3>时间优先转换–CompletableFuture.applyToEither()</h3><p><strong><em>CompletableFuture.applyToEither()</em></strong> 用于连接两个独立的CompletableFuture，选择计算（返回结果）最快的一个CompletableFuture，进行转换计算操作(Function&lt;? super T, U&gt;)并返回结果。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="keyword">super</span> T, U&gt; fn)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="keyword">super</span> T, U&gt; fn)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="keyword">super</span> T, U&gt; fn,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>我们现实开发场景中，总会碰到有两种渠道完成同一个事情，所以就可以调用这个方法，找一个最快的结果进行处理。一个例子如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">     &#125;).applyToEither(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">     &#125;), s -&gt; s).join();  <span class="comment">//2000毫秒后返回"hello world"</span></span><br></pre></td></tr></table></figure></p><h3>时间优先消费–CompletableFuture.acceptEither()</h3><p><strong><em>CompletableFuture.acceptEither()</em></strong> 用于连接两个独立的CompletableFuture，选择计算（返回结果）最快的一个CompletableFuture，进行消费操作(Consumer&lt;? super T&gt; action)，无返回值。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">acceptEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="keyword">super</span> T&gt; action,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>一个例子如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">     &#125;).acceptEither(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">     &#125;), System.out::println); <span class="comment">//2000毫秒后控制台打印 "hello world"</span></span><br></pre></td></tr></table></figure></p><h3>时间优先执行–CompletableFuture.runAfterEither()</h3><p><strong><em>CompletableFuture.runAfterEither()</em></strong> 用于连接两个独立的CompletableFuture，不关心任何CompletableFuture的返回值，任何一个CompletableFuture执行完毕得到了结果后会马上执行Runable。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>一个例子如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">     &#125;).runAfterEither(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"s2"</span>;</span><br><span class="line">     &#125;), () -&gt; System.out.println(<span class="string">"hello world"</span>)); <span class="comment">//() -&gt; System.out.println("hello world")是Runable的Lambda实现。 2000毫秒后控制台打印 "hello world"</span></span><br></pre></td></tr></table></figure></p><h2>结果赋值</h2><p>CompletableFuture的完计算结果直接赋值方法主要有以下几个：</p><ul><li>boolean complete(T value)，通过CAS赋值计算结果，内部会发送完成状态，再次调用无效。</li><li>boolean completeExceptionally(Throwable ex)，通过CAS赋值计算异常，内部会发送完成状态，再次调用无效。</li><li>void obtrudeValue(T value)，直接赋值计算结果，内部会发送完成状态，再次调用无效。</li><li>obtrudeException(Throwable ex)，直接赋值计算异常，内部会发送完成状态，再次调用无效。</li></ul><p>只要上面四个方法之一被调用，CompletableFuture就会标记为’完结状态’，再次调用其他方法将不会起效，另外，obtrudeXXX方法属于强制赋值，不建议使用，因为它们会直接覆盖当前的值。</p><p>一个例子如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            future.complete(<span class="string">"test success"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            future.completeExceptionally(e);</span><br><span class="line">        &#125;</span><br><span class="line">System.out.println(future.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 test success</span></span><br></pre></td></tr></table></figure></p><h2>结果获取</h2><ul><li><strong><em>T get() throws InterruptedException, ExecutionException</em></strong> ，永久阻塞，直到返回结果值，允许中断，计算过程中所有的异常会包裹为新的ExecutionException实例再抛出。</li><li><strong><em>T get(long timeout, TimeUnit unit)throws InterruptedException, ExecutionException, TimeoutException</em></strong> ，添加超时时间设定，如果超时会抛出TimeoutException，如果获取到结果则释放并返回，允许中断，计算过程中所有的异常会包裹为新的ExecutionException实例再抛出。</li><li><strong><em>T join()</em></strong> ，永久阻塞，直到返回结果值，不允许中断，计算过程中所有的异常会直接抛出。</li><li><strong><em>T getNow(T valueIfAbsent)</em></strong> ，如果当前的计算结果为null，马上返回valueIfAbsent，否则调用join()的逻辑。结果的获取不做举例，因为这个实在太常用，强烈建议使用T get(long timeout, TimeUnit unit)，其他三个方法看场景选择使用。</li></ul><h2>其它</h2><h3>取消–cancel()</h3><p>调用CompletableFuture实例的 <strong><em>cancel()</em></strong> 方法可以取消当前的CompletableFuture，此时该CompletableFuture实例会进入’完结状态’，其结果会传入一个新的CancellationException实例，此时通过上一节的’结果获取’中的Api调用就会按各自的处理模式抛出异常。</p><h3>所有完成</h3><p>调用CompletableFuture的静态方法 <strong><em>CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)</em></strong> ，当所有的传入的CompletableFuture实例都完成的时候，会返回一个新建的CompletableFuture，也就是程序将会阻塞在此方法调用，直到所有传入CompletableFuture都完成，这个时候返回值CompletableFuture实例也完成。举个例子：<strong><em>CompletableFuture.allOf(cf1,cf2).join()</em></strong> ;，其中cf1、cf2是两个独立的CompletableFuture实例。如果你的程序有这么一段代码，那么执行的时候会阻塞在此，直到cf1和cf2都完成了，才会释放。</p><h3>任一完成</h3><p>调用CompletableFuture的静态方法 <strong><em>CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs)</em></strong>， 这个方法和上面的’所有完成’是相对的。当所有的传入的CompletableFuture实例中只要有一个实例完成的时候，会返回一个新建的CompletableFuture，也就是程序将会阻塞在此方法调用，直到有一个传入的CompletableFuture完成，这个时候返回值CompletableFuture实例也完成。举个例子： <strong><em>CompletableFuture.anyOf(cf1,cf2).join();</em></strong> ，其中cf1、cf2是两个独立的CompletableFuture实例。如果你的程序有这么一段代码，那么执行的时候会阻塞在此，直到cf1或cf2其中一个完成了，才会释放。</p><h1>四、实战例子</h1><p>个人认为，CompletableFuture使用在API网关做接口的聚合是什么有优势的(不知道为什么身边很少人使用这个神器)。现在假设有一个API网关，在调用查询用户某个订单详情的时候，需要分别从订单服务的订单信息接口、用户服务的用户信息接口两个接口拉取数据，一般来说，低效的伪代码大概如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这两个参数从外部获得</span></span><br><span class="line">Long userId = <span class="number">10006L</span>;</span><br><span class="line">String orderId = <span class="string">"XXXXXXXXXXXXXXXXXXXXXX"</span>;</span><br><span class="line"><span class="comment">//从用户服务获取用户信息</span></span><br><span class="line">UserInfo userInfo = userService.getUserInfo(userId);</span><br><span class="line"><span class="comment">//从用订单务获取订单信息</span></span><br><span class="line">OrderInfo orderInfo = orderService.getOrderInfo(orderId);</span><br><span class="line"><span class="comment">//返回两者的聚合DTO</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OrderDetailDTO(userInfo,orderInfo);</span><br></pre></td></tr></table></figure></p><p>其实如果微服务设计得足够好，下面三个外部接口的信息一定是不相关联的，也就是可以并行获取，三个接口的结果都获取完毕之后做一次数据聚合到DTO即可，也就是聚合的耗时大致是这三个接口中耗时最长的接口的响应时间。修改后的代码如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDetailService</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建立一个线程池专门交给CompletableFuture使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">20</span>, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>));</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> OrderService orderService;</span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderDetailDTO <span class="title">getOrderDetail</span><span class="params">(Long userId, String orderId)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">CompletableFuture&lt;UserInfo&gt; userInfoCompletableFuture = CompletableFuture.supplyAsync(() -&gt; userService.getUserInfo(userId), executor);</span><br><span class="line">CompletableFuture&lt;OrderInfo&gt; orderInfoCompletableFuture = CompletableFuture.supplyAsync(() -&gt; orderService.getOrderInfo(orderId), executor);</span><br><span class="line">CompletableFuture&lt;OrderDetailDTO&gt; result</span><br><span class="line">= userInfoCompletableFuture.thenCombineAsync(orderInfoCompletableFuture, OrderDetailDTO::<span class="keyword">new</span>, executor);</span><br><span class="line"><span class="keyword">return</span> result.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码还没有考虑到外部的微服务异常的情况，但是相对串行的拉取外部信息的接口的操作方式，这种并行的方式显然是更加高效的，而且CompletableFuture的supplyAsync方法可以传入Supplier接口实例，也就是允许任何参数类型的表达式，这点是什么方便的。当然，其实用ExecutorService的invokeAll方法也可以达到相同的效果.</p><p><a href="http://www.importnew.com/10815.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;一、简介&lt;/h1&gt;
&lt;p&gt;java.util.concurrent.CompletableFuture继承于java.util.concurrent.Future，它本身具备Future的所有特性，并且基于JDK1.8的流式编程以及Lambda表达式等实现一元操作符、异步
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://hhbbz.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Netty入门浅析(2)</title>
    <link href="https://hhbbz.github.io/2018/07/22/Netty%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90(2)/"/>
    <id>https://hhbbz.github.io/2018/07/22/Netty入门浅析(2)/</id>
    <published>2018-07-22T14:59:38.000Z</published>
    <updated>2019-12-06T08:14:48.141Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>在上一章中我们认识了netty，他有三大优点：并发高，传输快，封装好。在这一章我们来用Netty搭建一个HttpServer，从实际开发中了解netty框架的一些特性和概念。</p><h1>认识Http请求</h1><p>在动手写Netty框架之前，我们先要了解http请求的组成，如下图：</p><p><img src="/2018/07/22/Netty入门浅析(2)/1.jpg" title="图片"></p><ol><li>HTTP Request 第一部分是包含的头信息</li><li>HttpContent 里面包含的是数据，可以后续有多个 HttpContent 部分</li><li>LastHttpContent 标记是 HTTP request 的结束，同时可能包含头的尾部信息</li><li>完整的 HTTP request，由1，2，3组成</li></ol><p><img src="/2018/07/22/Netty入门浅析(2)/2.jpg" title="图片"></p><ol><li>HTTP response 第一部分是包含的头信息</li><li>HttpContent 里面包含的是数据，可以后续有多个 HttpContent 部分</li><li>LastHttpContent 标记是 HTTP response 的结束，同时可能包含头的尾部信息</li><li>完整的 HTTP response，由1，2，3组成</li></ol><p>从request的介绍我们可以看出来，一次http请求并不是通过一次对话完成的，他中间可能有很次的连接。通过上一章我们队netty的了解，每一次对话都会建立一个channel，并且一个ChannelInboundHandler一般是不会同时去处理多个Channel的。如何在一个Channel里面处理一次完整的Http请求？这就要用到我们上图提到的FullHttpRequest，我们只需要在使用netty处理channel的时候，只处理消息是FullHttpRequest的Channel，这样我们就能在一个ChannelHandler中处理一个完整的Http请求了。</p><h1>编写代码</h1><p>搭建一个Netty服务器，我们只需要两个类——一个是启动类，负责启动（BootStrap）和main方法，一个是ChannelHandler，负责具体的业务逻辑，我们先从启动类说起。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpRequestDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpResponseEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by RoyDeng on 17/7/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">            System.err.println(</span><br><span class="line">                    <span class="string">"Usage: "</span> + HttpServer.class.getSimpleName() +</span><br><span class="line">                            <span class="string">" &lt;port&gt;"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">new</span> HttpServer(port).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        b.group(group)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span></span></span><br><span class="line"><span class="function">                            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"initChannel ch:"</span> + ch);</span><br><span class="line">                        ch.pipeline()</span><br><span class="line">                                .addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> HttpRequestDecoder())   <span class="comment">// 1</span></span><br><span class="line">                                .addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> HttpResponseEncoder())  <span class="comment">// 2</span></span><br><span class="line">                                .addLast(<span class="string">"aggregator"</span>, <span class="keyword">new</span> HttpObjectAggregator(<span class="number">512</span> * <span class="number">1024</span>))    <span class="comment">// 3</span></span><br><span class="line">                                .addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HttpHandler());        <span class="comment">// 4</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// determining the number of connections queued</span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">        b.bind(port).sync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个类同上一章中出现的Netty简易封装服务器代码类似，不一样的是这里使用了多个ChannelHandler，在这里一一介绍：</p><ol><li>HttpRequestDecoder，用于解码request</li><li>HttpResponseEncoder，用于编码response</li><li><strong>aggregator</strong>，消息聚合器（重要）。为什么能有FullHttpRequest这个东西，就是因为有他，HttpObjectAggregator，如果没有他，就不会有那个消息是FullHttpRequest的那段Channel，同样也不会有FullHttpResponse。如果我们将z'h</li><li>HttpObjectAggregator(512 * 1024)的参数含义是消息合并的数据大小，如此代表聚合的消息内容长度不超过512kb。添加我们自己的处理接口</li></ol><p>完成启动类之后，接下来就是我们的业务处理类HttpHandler了，先上代码：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.AsciiString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by RoyDeng on 17/7/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">FullHttpRequest</span>&gt; </span>&#123; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsciiString contentType = HttpHeaderValues.TEXT_PLAIN;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"class:"</span> + msg.getClass().getName());</span><br><span class="line">        DefaultFullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1,</span><br><span class="line">                HttpResponseStatus.OK,</span><br><span class="line">                Unpooled.wrappedBuffer(<span class="string">"test"</span>.getBytes())); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        HttpHeaders heads = response.headers();</span><br><span class="line">        heads.add(HttpHeaderNames.CONTENT_TYPE, contentType + <span class="string">"; charset=UTF-8"</span>);</span><br><span class="line">        heads.add(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes()); <span class="comment">// 3</span></span><br><span class="line">        heads.add(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);</span><br><span class="line"></span><br><span class="line">        ctx.write(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channelReadComplete"</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelReadComplete(ctx);</span><br><span class="line">        ctx.flush(); <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"exceptionCaught"</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != cause) cause.printStackTrace();</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != ctx) ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该段代码需要注意的地方如注释所示，有以下四点：</p><ol><li>Handler需要声明泛型为&lt;FullHttpRequest&gt;，声明之后，只有msg为FullHttpRequest的消息才能进来。由于泛型的过滤比较简单，我们就不改代码来验证了，但是在这里我们可以利用泛型的特性另外做个小测试，将泛型去掉，并且将HttpServer中</li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.addLast(<span class="string">"aggregator"</span>, <span class="keyword">new</span> HttpObjectAggregator(<span class="number">512</span> * <span class="number">1024</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>这一行代码注释掉，然后观察注释前后的log。</p><p>注释前:</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initChannel ch:[id: 0xcb9d8e9e, L:/0:0:0:0:0:0:0:1:8888 - R:/0:0:0:0:0:0:0:1:58855]</span><br><span class="line">class:io.netty.handler.codec.http.HttpObjectAggregator$AggregatedFullHttpRequest</span><br><span class="line">channelReadComplete</span><br></pre></td></tr></table></figure></p><p>注释后:</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initChannel ch:[id: 0xc5415409, L:/0:0:0:0:0:0:0:1:8888 - R:/0:0:0:0:0:0:0:1:58567]</span><br><span class="line">class:io.netty.handler.codec.http.DefaultHttpRequest</span><br><span class="line">class:io.netty.handler.codec.http.LastHttpContent$1</span><br><span class="line">channelReadComplete</span><br><span class="line">channelReadComplete</span><br></pre></td></tr></table></figure></p><p>从中可以看出，如果没有aggregator，那么一个http请求就会通过多个Channel被处理，这对我们的业务开发是不方便的，而aggregator的作用就在于此。</p><ol start="2"><li>生成response，这里使用的FullHttpResponse，同FullHttpRequest类似，通过这个我们就不用将response拆分成多个channel返回给请求端了。</li><li>添加header描述length。这一步是很重要的一步，如果没有这一步，你会发现用postman发出请求之后就一直在刷新，因为http请求方不知道返回的数据到底有多长。</li><li>channel读取完成之后需要输出缓冲流。如果没有这一步，你会发现postman同样会一直在刷新</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;简介&lt;/h1&gt;
&lt;p&gt;在上一章中我们认识了netty，他有三大优点：并发高，传输快，封装好。在这一章我们来用Netty搭建一个HttpServer，从实际开发中了解netty框架的一些特性和概念。&lt;/p&gt;
&lt;h1&gt;认识Http请求&lt;/h1&gt;
&lt;p&gt;在动手写Netty框架之
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://hhbbz.github.io/tags/Java/"/>
    
      <category term="分布式" scheme="https://hhbbz.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Netty" scheme="https://hhbbz.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty入门浅析(1)</title>
    <link href="https://hhbbz.github.io/2018/07/22/Netty%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90(1)/"/>
    <id>https://hhbbz.github.io/2018/07/22/Netty入门浅析(1)/</id>
    <published>2018-07-22T04:36:12.000Z</published>
    <updated>2019-12-06T08:14:49.908Z</updated>
    
    <content type="html"><![CDATA[<h1>Netty的简单介绍</h1><p>Netty 是一个 NIO client-server(客户端服务器)框架，使用 Netty 可以快速开发网络应用，例如服务器和客户 端协议。 Netty 提供了一种新的方式来使开发网络应用程序，这种新的方式使得它很容易使用和有很强的扩展性。 Netty 的内部实现时很复杂的，但是 Netty 提供了简单易用的 api 从网络处理代码中解耦业务逻辑。 Netty 是完全基 于 NIO 实现的，所以整个 Netty 都是异步的。 简单点说就是Netty提供了一个简单，间接的方法来操作网络之间的通讯。</p><h1>使用 Netty 能够做什么</h1><ul><li>开发异步、非阻塞的 TCP 网络应用程序；</li><li>开发异步、非阻塞的 UDP 网络应用程序；</li><li>开发异步文件传输应用程序；</li><li>开发异步 HTTP 服务端和客户端应用程序；</li><li>提供对多种编解码框架的集成，包括谷歌的 Protobuf、Jbossmarshalling、Java 序列化、压缩编解码、XML 解码、字符串编解码等，这些编解码框架可以被用户直接使用；提供形式多样的编解码基础类库，可以非常方便的实现私有协议栈编解码框架的二次定制和开发；</li><li>基于职责链模式的 Pipeline-Handler 机制，用户可以非常方便的对网络事件进行拦截和定制；所有的 IO 操作都是异步的，用户可以通过 Future-Listener 机制主动 Get 结果或者由 IO 线程操作完成之后主动 Notify 结果，用户的业务线程不需要同步等待；</li><li>IP 黑白名单控制；</li><li>打印消息码流；流量控制和整形；</li><li>性能统计；基于链路空闲事件检测的心跳检测</li><li>……</li></ul><h1>Netty得到的应用</h1><ul><li>阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信。</li><li>淘宝的消息中间件 RocketMQ 的消息生产者和消息消费者之间，也采用 Netty 进行高性能、异步通信。</li></ul><h1>Netty Reactor模式</h1><p>Netty是典型的Reactor模型结构。Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，Boss线程池和Work线程池，其中Boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给Work线程池，其中Work线程池负责请求的read和write事件。<strong>流程图：</strong></p><p><img src="/2018/07/22/Netty入门浅析(1)/1.png" title="图片"></p><h1>Netty核心组件</h1><h2>Channel</h2><p>这里的Channel与Java的Channel不是同一个，是netty自己定义的通道；Netty的Channel是对网络连接处理的抽象，负责与网络进行通讯，支持NIO和OIO两种方式；内部与网络socket连接，通过channel能够进行I/O操作，如读、写、连接和绑定。通过Channel可以执行具体的I/O操作，如read, write, connect, 和bind。在Netty中，所有I/O操作都是异步的；Netty的服务器端处理客户端连接的Channel创建时可以设置父Channel。例如：ServerSocketChannel接收到请求创建SocketChannel，SocketChannel的父为ServerSocketChannel。</p><h2>ChannelHandler与ChannelPipeline</h2><p>ChannelHandler是通道处理器，用来处理I/O事件或拦截I/O操作，ChannelPipeline字如其名，是一个双向流水线，内部维护了多个ChannelHandler，服务器端收到I/O事件后，每次顺着ChannelPipeline依次调用ChannelHandler的相关方法。ChannelHandler是个接口，通常我们在Netty中需要使用下面的子类：</p><ul><li>ChannelInboundHandler 用来处理输入的I/O事件</li><li>ChannelOutboundHandler 用来处理输出的I/O事件</li></ul><p>另外，下面的adapter类提供了:</p><ul><li>ChannelInboundHandlerAdapter 用来处理输入的I/O事件</li><li>ChannelOutboundHandlerAdapter 用来处理输出的I/O事件</li><li>ChannelDuplexHandler 可以用来处理输入和输出的I/O事件</li></ul><p>Netty的ChannelPipeline和ChannelHandler机制类似于Servlet和Filter过滤器/拦截器，每次收到请求会依次调用配置好的拦截器链。Netty服务器收到消息后，将消息在ChannelPipeline中流动和传递，途经的ChannelHandler会对消息进行处理，ChannelHandler分为两种inbound和outbound，服务器read过程中只会调用inbound的方法，write时只寻找链中的outbound的Handler。ChannelPipeline内部维护了一个双向链表，Head和Tail分别代表表头和表尾，Head作为总入口和总出口，负责底层的网络读写操作；用户自己定义的ChannelHandler会被添加到链表中，这样就可以对I/O事件进行拦截和处理；这样的好处在于用户可以方便的通过新增和删除链表中的ChannelHandler来实现不同的业务逻辑，不需要对已有的ChannelHandler进行修改</p><p><img src="/2018/07/22/Netty入门浅析(1)/2.png" title="图片"></p><p>如图所示，在服务器初始化后，ServerSocketChannel的会创建一个Pipeline，内部维护了ChannelHanlder的双向链表，读取数据时，会依次调用ChannelInboundHandler子类的channelRead()方法，例如：读取到客户端数据后，依次调用解码-业务逻辑-直到Tail。而写入数据时，会从用户自定义的ChannelHandler出发查找ChannelOutboundHandler的子类，调用channelWrite()，最终由Head的write()向socket写入数据。例如：写入数据会通过业务逻辑的组装–编码–写入socket（Head的write）</p><h2>EventLoop与EventLoopGroup</h2><p>EventLoop是事件循环，EventLoopGroup是运行在线程池中的事件循环组，Netty使用了Reactor模型，服务器的连接和读写放在线程池之上的事件循环中执行，这是Netty获得高性能的原因之一。事件循环内部会打开selector，并将Channel注册到事件循环中，事件循环不断的进行select()查找准备就绪的描述符；此外，某些系统任务也会被提交到事件循环组中运行。</p><h2>ServerBootstrap</h2><p>ServerBootstrap是辅助启动类，用于服务端的启动，内部维护了很多用于启动和建立连接的属性。包括：</p><ul><li>EventLoopGroup group 线程池组</li><li>channel是通道</li><li>channelFactory 通道工厂，用于创建channel</li><li>localAddress 本地地址</li><li>options 通道的选项，主要是TCP连接的属性</li><li>attrs 用来设置channel的属性，</li><li>handler 通道处理器</li></ul><h1>参考</h1><p><a href="http://blog.leanote.com/post/shawn_yan/Netty%E5%8E%9F%E7%90%86%E6%A6%82%E8%A7%88" target="_blank" rel="noopener">Netty原理浅析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Netty的简单介绍&lt;/h1&gt;
&lt;p&gt;Netty 是一个 NIO client-server(客户端服务器)框架，使用 Netty 可以快速开发网络应用，例如服务器和客户 端协议。 Netty 提供了一种新的方式来使开发网络应用程序，这种新的方式使得它很容易使用和有很强的
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://hhbbz.github.io/tags/Java/"/>
    
      <category term="分布式" scheme="https://hhbbz.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Netty" scheme="https://hhbbz.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Java实现乐观互斥Key锁</title>
    <link href="https://hhbbz.github.io/2018/07/14/Java%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E4%BA%92%E6%96%A5Key%E9%94%81/"/>
    <id>https://hhbbz.github.io/2018/07/14/Java实现乐观互斥Key锁/</id>
    <published>2018-07-14T07:42:02.000Z</published>
    <updated>2018-07-14T09:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>java中的几种锁：synchronized，ReentrantLock，ReentrantReadWriteLock已基本可以满足编程需求，但其粒度都太大，同一时刻只有一个线程能进入同步块，加锁后性能受到太大的影响。这对于某些高并发的场景并不适用。本文实现了一个基于KEY（主键）的互斥锁，具有更细的粒度，在缓存或其他基于KEY的场景中有很大的用处。下面将讲解这个锁的设计和实现</p><h1>分段锁</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hhbbz on 2018/7/13.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Explain</span>: key锁（要保证key的hashCode不变,否则无法释放锁。即加锁之后不要手动更改lockMap）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadKeyLock</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//默认分段数量</span></span><br><span class="line">    <span class="keyword">private</span> Integer segments = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, ReentrantLock&gt; lockMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadKeyLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadKeyLock</span><span class="params">(Integer counts, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        init(counts, fair);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Integer counts, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (counts != <span class="keyword">null</span>) &#123;</span><br><span class="line">            segments = counts;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments; i++) &#123;</span><br><span class="line">            lockMap.put(i, <span class="keyword">new</span> ReentrantLock(fair));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = lockMap.get(key.hashCode() % segments);</span><br><span class="line">        lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = lockMap.get(key.hashCode() % segments);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>哈希锁</h1><p>上述分段锁的基础上发展起来的第二种锁策略，目的是实现真正意义上的细粒度锁。每个哈希值不同的对象都能获得自己独立的锁。在测试中，在被锁住的代码执行速度飞快的情况下，效率比分段锁慢 30% 左右。如果有长耗时操作，感觉表现应该会更好。代码如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashLock</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isFair = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SegmentLock&lt;T&gt; segmentLock = <span class="keyword">new</span> SegmentLock&lt;&gt;();<span class="comment">//分段锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;T, LockInfo&gt; lockMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        isFair = fair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        LockInfo lockInfo;</span><br><span class="line">        segmentLock.lock(key);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lockInfo = lockMap.get(key);</span><br><span class="line">            <span class="keyword">if</span> (lockInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                lockInfo = <span class="keyword">new</span> LockInfo(isFair);</span><br><span class="line">                lockMap.put(key, lockInfo);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lockInfo.count.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            segmentLock.unlock(key);</span><br><span class="line">        &#125;</span><br><span class="line">        lockInfo.lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        LockInfo lockInfo = lockMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (lockInfo.count.get() == <span class="number">1</span>) &#123;</span><br><span class="line">            segmentLock.lock(key);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lockInfo.count.get() == <span class="number">1</span>) &#123;</span><br><span class="line">                    lockMap.remove(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                segmentLock.unlock(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lockInfo.count.decrementAndGet();</span><br><span class="line">        lockInfo.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LockInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> ReentrantLock lock;</span><br><span class="line">        <span class="keyword">public</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">LockInfo</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>弱引用锁</h1><p>哈希锁因为引入的分段锁来保证锁创建和销毁的同步，总感觉有点瑕疵，所以写了第三个锁来寻求更好的性能和更细粒度的锁。这个锁的思想是借助java的弱引用来创建锁，把锁的销毁交给jvm的垃圾回收，来避免额外的消耗。</p><p>有点遗憾的是因为使用了ConcurrentHashMap作为锁的容器，所以没能真正意义上的摆脱分段锁。这个锁的性能比 HashLock 快10% 左右。锁代码：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 弱引用锁，为每个独立的哈希值提供独立的锁功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashLock</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;T, WeakLockRef&lt;T, ReentrantLock&gt;&gt; lockMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReferenceQueue&lt;ReentrantLock&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReentrantLock <span class="title">get</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lockMap.size() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">            clearEmptyRef();</span><br><span class="line">        &#125;</span><br><span class="line">        WeakReference&lt;ReentrantLock&gt; lockRef = lockMap.get(key);</span><br><span class="line">        ReentrantLock lock = (lockRef == <span class="keyword">null</span> ? <span class="keyword">null</span> : lockRef.get());</span><br><span class="line">        <span class="keyword">while</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lockMap.putIfAbsent(key, <span class="keyword">new</span> WeakLockRef&lt;&gt;(<span class="keyword">new</span> ReentrantLock(), queue, key));</span><br><span class="line">            lockRef = lockMap.get(key);</span><br><span class="line">            lock = (lockRef == <span class="keyword">null</span> ? <span class="keyword">null</span> : lockRef.get());</span><br><span class="line">            <span class="keyword">if</span> (lock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> lock;</span><br><span class="line">            &#125;</span><br><span class="line">            clearEmptyRef();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearEmptyRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Reference&lt;? extends ReentrantLock&gt; ref;</span><br><span class="line">        <span class="keyword">while</span> ((ref = queue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            WeakLockRef&lt;T, ? extends ReentrantLock&gt; weakLockRef = (WeakLockRef&lt;T, ? extends ReentrantLock&gt;) ref;</span><br><span class="line">            lockMap.remove(weakLockRef.key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakLockRef</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">WeakLockRef</span><span class="params">(K referent, ReferenceQueue&lt;? <span class="keyword">super</span> K&gt; q, T key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(referent, q);</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>适合耗时长场景的互斥key锁</h1><p>一个细粒度的锁，在某些场景能比synchronized，ReentrantLock等获得更高的并行度更好的性能</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyLock</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 保存所有锁定的KEY及其信号量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;K, Semaphore&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;K, Semaphore&gt;();</span><br><span class="line">    <span class="comment">// 保存每个线程锁定的KEY及其锁定计数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;K, LockInfo&gt;&gt; local = <span class="keyword">new</span> ThreadLocal&lt;Map&lt;K, LockInfo&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Map&lt;K, LockInfo&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K, LockInfo&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁定key，其他等待此key的线程将进入等待，直到调用&#123;<span class="doctag">@link</span> #unlock(K)&#125;</span></span><br><span class="line"><span class="comment">     * 使用hashcode和equals来判断key是否相同，因此key必须实现&#123;<span class="doctag">@link</span> #hashCode()&#125;和</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #equals(Object)&#125;方法</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        LockInfo info = local.get().get(key);</span><br><span class="line">        <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Semaphore current = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">            current.acquireUninterruptibly();</span><br><span class="line">            Semaphore previous = map.put(key, current);</span><br><span class="line">            <span class="keyword">if</span> (previous != <span class="keyword">null</span>)</span><br><span class="line">                previous.acquireUninterruptibly();</span><br><span class="line">            local.get().put(key, <span class="keyword">new</span> LockInfo(current));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            info.lockCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放key，唤醒其他等待此key的线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        LockInfo info = local.get().get(key);</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span> &amp;&amp; --info.lockCount == <span class="number">0</span>) &#123;</span><br><span class="line">            info.current.release();</span><br><span class="line">            map.remove(key, info.current);</span><br><span class="line">            local.get().remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁定多个key</span></span><br><span class="line"><span class="comment">     * 建议在调用此方法前先对keys进行排序，使用相同的锁定顺序，防止死锁发生</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(K[] keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keys == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (K key : keys) &#123;</span><br><span class="line">            lock(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放多个key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(K[] keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keys == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (K key : keys) &#123;</span><br><span class="line">            unlock(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LockInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Semaphore current;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> lockCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">LockInfo</span><span class="params">(Semaphore current)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.current = current;</span><br><span class="line">            <span class="keyword">this</span>.lockCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;简介&lt;/h1&gt;
&lt;p&gt;java中的几种锁：synchronized，ReentrantLock，ReentrantReadWriteLock已基本可以满足编程需求，但其粒度都太大，同一时刻只有一个线程能进入同步块，加锁后性能受到太大的影响。这对于某些高并发的场景并不适用。
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://hhbbz.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security（2）流程详解</title>
    <link href="https://hhbbz.github.io/2018/07/07/Spring%20Security%EF%BC%882%EF%BC%89%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://hhbbz.github.io/2018/07/07/Spring Security（2）流程详解/</id>
    <published>2018-07-07T09:34:19.000Z</published>
    <updated>2018-07-07T10:33:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>上章记录一点基础的配置，这次结合高级认证灵活使用Spring Security的用户认证。</p><h1>Spring Boot 添加 Spring Security</h1><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1>认证流程</h1><ol><li><p>用户使用用户名和密码登录</p></li><li><p>用户名密码被过滤器（默认为 UsernamePasswordAuthenticationFilter）获取到，配合其他权限信息（自定义），根据UsernamePasswordAuthenticationToken封装成一个未认证的Authentication（处在securityContext中）</p></li><li><p>Token（Authentication实现类）传递给 AuthenticationManager 进行认证。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.getAuthenticationManager().authenticate(token)</span><br></pre></td></tr></table></figure></p></li><li><p>AuthenticationManager管理一系列的AuthenticationProvider，AuthenticationManager会遍历全部AuthenticationProvider去对Authentication进行认证。</p></li><li><p>AuthenticationProvider会调用userDetailService去数据库中验证用户信息 ,返回一个userDetail对象（可自定义），认证成功后返回一个封装了用户权限信息的，以UsernamePasswordAuthenticationToken实现的带用户名和密码以及权限的Authentication 对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//appServer为权限信息</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> UsernamePasswordAuthenticationToken(userDetail,<span class="keyword">null</span>,appServer;</span><br></pre></td></tr></table></figure></p></li><li><p>已经进行认证的Authentication返回到UsernamePasswordAuthenticationFilter中，如果验证失败，则进入unsuccessfulAuthentication;如果验证成功，则进入successfulAuthentication进行生成token.</p></li></ol><h1>Filter</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AjaxLoginAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationProcessingFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthenticationSuccessHandler successHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthenticationFailureHandler failureHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AjaxLoginAuthenticationFilter</span><span class="params">(String defaultProcessUrl, AuthenticationSuccessHandler successHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">            AuthenticationFailureHandler failureHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successHandler = successHandler;</span><br><span class="line">        <span class="keyword">this</span>.failureHandler = failureHandler;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> AuthenticationException, IOException, ServletException </span>&#123;</span><br><span class="line">        AjaxLoginRequest loginRequest;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(secretLogin)&#123;</span><br><span class="line">                SecretFormRequest secretFormRequest = JSONObject.parseObject(request.getInputStream(),SecretFormRequest.class);</span><br><span class="line">                loginRequest = secretFormRequest.build();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                loginRequest = JSONObject.parseObject(request.getInputStream(),AjaxLoginRequest.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            logger.error(e.getMessage(),e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidLoginException(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(loginRequest.getUsername()) || StringUtils.isBlank(loginRequest.getPassword())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(<span class="string">"Username or Password not provided"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//权限标识，信息，用于做权限区分</span></span><br><span class="line">        AppServer appServer; </span><br><span class="line"></span><br><span class="line">        UsernamePasswordAuthenticationAppServerToken token = <span class="keyword">new</span> UsernamePasswordAuthenticationAppServerToken(loginRequest.getUsername(), loginRequest.getPassword(),appServer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">successfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain,</span></span></span><br><span class="line"><span class="function"><span class="params">            Authentication authResult)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">unsuccessfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">            AuthenticationException failed)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        SecurityContextHolder.clearContext();</span><br><span class="line">        failureHandler.onAuthenticationFailure(request, response, failed);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1>Token（Authentication实现类）</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户认证Token</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordAuthenticationAppServerToken</span> <span class="keyword">extends</span> <span class="title">UsernamePasswordAuthenticationToken</span> </span>&#123;</span><br><span class="line">    <span class="comment">//权限标识，信息，用于做权限区分</span></span><br><span class="line">    <span class="keyword">private</span> AppServer appServer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationAppServerToken</span><span class="params">(Object principal, Object credentials,AppServer appServer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(principal,credentials);</span><br><span class="line">        <span class="keyword">this</span>.appServer = appServer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationAppServerToken</span><span class="params">(Object principal, Object credentials)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(principal, credentials);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationAppServerToken</span><span class="params">(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(principal, credentials, authorities);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AppServer <span class="title">getAppServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> appServer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>AuthenticationProvider</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 权限验证对比用户名,密码比较是否相同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AjaxAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BCryptPasswordEncoder encoder;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsServiceImpl userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        Assert.notNull(authentication, <span class="string">"No authentication data provided"</span>);</span><br><span class="line"></span><br><span class="line">        String username = (String) authentication.getPrincipal();</span><br><span class="line">        String password = (String) authentication.getCredentials();</span><br><span class="line"></span><br><span class="line">        JwtUser jwtUser = <span class="keyword">null</span>;</span><br><span class="line">        AppServer appServer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jwtUser = (JwtUser) userService.loadUserByUsername(username);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"获取用户成功！"</span>,jwtUser.getUsername());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(authentication <span class="keyword">instanceof</span> UsernamePasswordAuthenticationAppServerToken)&#123;</span><br><span class="line"></span><br><span class="line">            UsernamePasswordAuthenticationAppServerToken authenticationAppServerToken = (UsernamePasswordAuthenticationAppServerToken) authentication;</span><br><span class="line">            appServer = authenticationAppServerToken.getAppServer();</span><br><span class="line">            jwtUser = userService.loadUserByUsernameInAppServer(username,appServer.getId(),<span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匹配密码</span></span><br><span class="line">        <span class="keyword">if</span> (!encoder.matches(password, jwtUser.getPassword())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="string">"Authentication Failed. Username or Password not valid."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        UsernamePasswordAuthenticationAppServerToken authenticationAppServerToken = <span class="keyword">new</span> UsernamePasswordAuthenticationAppServerToken(jwtUser,<span class="keyword">null</span>,appServer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> authenticationAppServerToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>UserDetailService</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span>, <span class="title">IService</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        User user = userRepository.findByUserName(username);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(String.format(<span class="string">"No user found with username '%s'."</span>, username));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> JwtUserFactory.create(user,<span class="number">0L</span>,<span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>UserDetail</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUser</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> AppServer appServer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>SuccessHandler</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AjaxAwareAuthenticationSuccessHandler</span> <span class="keyword">implements</span> <span class="title">AuthenticationSuccessHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        JwtUser userDetails = (JwtUser) authentication.getPrincipal();</span><br><span class="line">        </span><br><span class="line">        AppServer appServer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (authentication <span class="keyword">instanceof</span> UsernamePasswordAuthenticationAppServerToken) &#123;</span><br><span class="line">            appServer = ((UsernamePasswordAuthenticationAppServerToken) authentication).getAppServer();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成token</span></span><br><span class="line">        JwtToken accessToken = jwtTokenUtil.generateToken(userDetails,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        userCacheManager.cache(accessToken.getToken(),userDetails);</span><br><span class="line">        <span class="keyword">if</span>(userDetails.getLastPasswordResetType() != <span class="keyword">null</span> &amp;&amp; userDetails.getLastPasswordResetType()==<span class="number">0</span> </span><br><span class="line">            &amp;&amp; userDetails.getLastPasswordResetDate() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            userService.updateUserResetDate(<span class="keyword">new</span> Date(), userDetails.getId());  </span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//用于是否需要重置密码判断</span></span><br><span class="line">        accessToken.setLastPasswordResetType(userDetails.getLastPasswordResetType());</span><br><span class="line"></span><br><span class="line">        response.setStatus(HttpStatus.OK.value());</span><br><span class="line">        response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        JSONObject.writeJSONString(response.getWriter(), accessToken);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;简介&lt;/h1&gt;
&lt;p&gt;上章记录一点基础的配置，这次结合高级认证灵活使用Spring Security的用户认证。&lt;/p&gt;
&lt;h1&gt;Spring Boot 添加 Spring Security&lt;/h1&gt;
&lt;p&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://hhbbz.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://hhbbz.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security（1）配置说明</title>
    <link href="https://hhbbz.github.io/2018/07/06/Spring-Security%EF%BC%881%EF%BC%89%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
    <id>https://hhbbz.github.io/2018/07/06/Spring-Security（1）配置说明/</id>
    <published>2018-07-06T10:35:40.000Z</published>
    <updated>2018-07-07T13:00:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Spring Security 模块</h1><ul><li><p><strong>核心模块</strong> - spring-security-core.jar：包含核心验证和访问控制类和接口，远程支 持的基本配置API，是基本模块</p></li><li><p><strong>远程调用</strong> - spring-security-remoting.jar：提供与 Spring Remoting 集成</p></li><li><p><strong>网页</strong> - spring-security-web.jar：包括网站安全的模块，提供网站认证服务和基于URL访问控制</p></li><li><p><strong>配置</strong> - spring-security-config.jar：包含安全命令空间解析代码，若使用XML进行配置则需要</p></li><li><p><strong>LDAP</strong> - spring-security-ldap.jar：LDAP 验证和配置，若需要LDAP验证和管理LDAP用户实体</p></li><li><p><strong>ACL访问控制表</strong> - spring-security-acl.jar：ACL专门领域对象的实现</p></li><li><p><strong>CAS</strong> - spring-security-cas.jar：CAS客户端继承，若想用CAS的SSO服务器网页验证</p></li><li><p><strong>OpenID</strong> - spring-security-openid.jar：OpenID网页验证支持</p></li><li><p><strong>Test</strong> - spring-security-test.jar：支持Spring Security的测试</p></li></ul><h1>默认执行顺序</h1><h2>UsernamePasswordAuthenticationFilter</h2><ol><li>用户通过url：/login 登录，该过滤器接收表单用户名密码</li><li>判断用户名密码是否为空</li><li>生成 UsernamePasswordAuthenticationToken</li><li>将Authentiction 传给 AuthenticationManager接口的 authenticate 方法进行认证处理</li><li>AuthenticationManager 默认是实现类为 ProviderManager ，ProviderManager 委托给 AuthenticationProvider 进行处理</li><li>UsernamePasswordAuthenticationFilter 继承了 AbstractAuthenticationProcessingFilter 抽象类，AbstractAuthenticationProcessingFilter 在 successfulAuthentication 方法中对登录成功进行了处理，通过 SecurityContextHolder.getContext().setAuthentication() 方法将 Authentication 认证信息对象绑定到 SecurityContext</li><li>下次请求时，在过滤器链头的 SecurityContextPersistenceFilter 会从 Session 中取出用户信息并生成 Authentication（默认为 UsernamePasswordAuthenticationToken），并通过 SecurityContextHolder.getContext().setAuthentication() 方法将 Authentication 认证信息对象绑定到 SecurityContext</li><li>需要权限才能访问的请求会从 SecurityContext 中获取用户的权限进行验证DaoAuthenticationProvider （实现了 AuthenticationProvider）：通过 UserDetailsService 获取 UserDetails将 UserDetails 和 UsernamePasswordAuthentionToken 进行认证匹配用户名密码是否正确若正确则通过 UserDetails 中用户的权限、用户名等信息生成一个新的 Authentication 认证对象并返回</li></ol><h2>DaoAuthenticationProvider （实现了 AuthenticationProvider）</h2><ol><li>通过 UserDetailsService 获取 UserDetails</li><li>将 UserDetails 和 UsernamePasswordAuthentionToken 进行认证匹配用户名密码是否正确</li><li>若正确则通过 UserDetails 中用户的权限、用户名等信息生成一个新的 Authentication 认证对象并返回</li></ol><h1>相关类</h1><h2>WebSecurityConfigurerAdapter</h2><ul><li>为创建 WebSecurityConfigurer 实例提供方便的基类，重写它的 configure 方法来设置安全细节<ul><li>configure(HttpSecurity http)：重写该方法，通过 http 对象的 authorizeRequests()方法定义URL访问权限，默认会为 formLogin() 提供一个简单的测试HTML页面</li><li>_configureGlobal(AuthenticationManagerBuilder auth) _：通过 auth 对象的方法添加身份验证</li></ul></li></ul><h2>SecurityContextHolder</h2><ul><li>SecurityContextHolder 用于存储安全上下文信息（如操作用户是谁、用户是否被认证、用户权限有哪些），它用 ThreadLocal 来保存 SecurityContext，者意味着 Spring Security 在用户登录时自动绑定到当前现场，用户退出时，自动清除当前线程认证信息，SecurityContext 中含有正在访问系统用户的详细信息</li></ul><h2>AuthenticationManagerBuilder</h2><ul><li>用于构建认证 AuthenticationManager 认证，允许快速构建内存认证、LDAP身份认证、JDBC身份验证，添加 userDetailsService（获取认证信息数据） 和 AuthenticationProvider's（定义认证方式）</li><li>内存验证：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      auth.inMemoryAuthentication()</span><br><span class="line">            .withUser(<span class="string">"user"</span>).password(<span class="string">"123"</span>).roles(<span class="string">"USER"</span>).and()</span><br><span class="line">            .withUser(<span class="string">"admin"</span>).password(<span class="string">"456"</span>).roles(<span class="string">"USER"</span>,<span class="string">"ADMIN"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>JDBC 验证：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.jdbcAuthentication()</span><br><span class="line">            .dataSource(dataSource)</span><br><span class="line">            .withDefaultSchema()</span><br><span class="line">            .withUser(<span class="string">"linyuan"</span>).password(<span class="string">"123"</span>).roles(<span class="string">"USER"</span>).and()</span><br><span class="line">            .withUser(<span class="string">"linyuan2"</span>).password(<span class="string">"456"</span>).roles(<span class="string">"ADMIN"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>userDetailsService(T userDetailsService)：传入自定义的 UserDetailsService 获取认证信息数据</li><li>authenticationProvider(AuthenticationProvider authenticationProvider) ：传入自定义认证过程</li></ul><h2>UserDetailsService</h2><ul><li>该接口仅有一个方法 loadUserByUsername，Spring Security 通过该方法获取.可自定义。</li></ul><h2>UserDetails</h2><ul><li>我们可以实现该接口来定义自己认证用户的获取方式（如数据库中获取），认证成功后会将 UserDetails 赋给 Authentication 的 principal 属性，然后再把 Authentication 保存到 SecurityContext 中，之后需要实用用户信息时通过 SecurityContextHolder 获取存放在 SecurityContext 中的 Authentication 的 principal。</li></ul><h2>Authentication</h2><ul><li>Authentication 是一个接口，用来表示用户认证信息，在用户登录认证之前相关信息（用户传过来的用户名密码）会封装为一个 Authentication 具体实现类对象，默认情况下为 UsernamePasswordAuthenticationToken，登录之后（通过AuthenticationManager认证）会生成一个更详细的、包含权限的对象，然后把它保存在权限线程本地的 SecurityContext 中，供后续权限鉴定用</li></ul><h2>GrantedAuthority</h2><ul><li>GrantedAuthority 是一个接口，它定义了一个 getAuthorities() 方法返回当前 Authentication 对象的拥有权限字符串，用户有权限是一个 GrantedAuthority 数组，每一个 GrantedAuthority 对象代表一种用户</li><li>通常搭配 SimpleGrantedAuthority 类使用</li></ul><h2>AuthenticationManager</h2><ul><li>AuthenticationManager 是用来处理认证请求的接口，它只有一个方法 authenticate()，该方法接收一个 Authentication 作为对象，如果认证成功则返回一个封装了当前用户权限信息的 Authentication 对象进行返回</li><li>它默认的实现是 ProviderManager，但它不处理认证请求，而是将委托给 AuthenticationProvider 列表，然后依次使用 AuthenticationProvider 进行认证，如果有一个 AuthenticationProvider 认证的结果不为null，则表示成功（否则失败，抛出 ProviderNotFoundException），之后不在进行其它 AuthenticationProvider 认证，并作为结果保存在 ProviderManager</li><li>认证校验时最常用的方式就是通过用户名加载 UserDetails，然后比较 UserDetails 密码与请求认证是否一致，一致则通过，Security 内部的 DaoAuthenticationProvider 就是实用这种方式</li><li>认证成功后加载 UserDetails 来封装要返回的 Authentication 对象，加载的 UserDetails 对象是包含用户权限等信息的。认证成功返回的 Authentication 对象将会保存在当前的 SecurityContext 中</li></ul><h2>AuthenticationProvide</h2><ul><li><p>AuthenticationProvider 是一个身份认证接口，实现该接口来定制自己的认证方式，可通过 UserDetailsSevice 对获取数据库中的数据</p></li><li><p>该接口中有两个需要实现的方法：</p><ul><li>Authentication authenticate(Authentication authentication)：认证处理，返回一个 Authentication 的实现类则代表成功，返回 null 则为认证失败</li><li>supports(Class&lt;?&gt; aClass)：如果该 AuthenticationProvider 支持传入的 Authentication 认证对象，则返回 true ，如：return aClass.equals(UsernamePasswordAuthenticationToken.class);</li></ul></li></ul><h2>AuthorityUtils</h2><ul><li>是一个工具包，用于操作 GrantedAuthority 集合的实用方法：<ul><li>commaSeparatedStringToAuthorityList(String authorityString)：从逗号分隔符中创建 GrantedAuthority 对象数组</li></ul></li></ul><h2>AbstractAuthenticationProcessingFilter</h2><ul><li>该抽象类继承了 GenericFilterBean，是处理 form 登录的过滤器，与 form 登录相关的所有操作都在该抽象类的子类中进行（UsernamePasswordAuthenticationFilter 为其子类），比如获取表单中的用户名、密码，然后进行认证等操作</li><li>该类在 doFilter 方法中通过 attemptAuthentication() 方法进行用户信息逻辑认证，认证成功会将用户信息设置到 Session 中</li></ul><h2>UserDetails</h2><ul><li>代表了Spring Security的用户实体类，带有用户名、密码、权限特性等性质，可以自己实现该接口，供 Spring Security 安全认证使用，Spring Security 默认使用的是内置的 User 类</li><li>将从数据库获取的 User 对象传入实现该接口的类，并获取 User 对象的值来让类实现该接口的方法</li><li>通过 Authentication.getPrincipal() 的返回类型是 Object，但很多情况下其返回的其实是一个 UserDetails 的实例</li></ul><h2>HttpSecurity</h2><ul><li>用于配置全局 Http 请求的权限控制规则，对哪些请求进行验证、不验证等</li><li>常用方法：</li><li>authorizeRequests()：返回一个配置对象用于配置请求的访问限制</li><li>formLogin()：返回表单配置对象，当什么都不指定时会提供一个默认的，如配置登录请求，还有登录成功页面</li><li>logout()：返回登出配置对象，可通过logoutUrl设置退出url</li><li>antMatchers：匹配请求路径或请求动作类型，如：.antMatchers(&quot;/admin/**&quot;)</li><li>addFilterBefore: 在某过滤器之前添加 filter</li><li>addFilterAfter：在某过滤器之后添加 filter</li><li>addFilterAt：在某过滤器相同位置添加 filter，不会覆盖相同位置的 filter</li><li>hasRole：结合 antMatchers 一起使用，设置请求允许访问的角色权限或IP，如：</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.antMatchers(<span class="string">"/admin/**"</span>).hasAnyRole(<span class="string">"ROLE_ADMIN"</span>,<span class="string">"ROLE_USER"</span>)</span><br></pre></td></tr></table></figure></p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">access(String)</td><td style="text-align:left">SpringEL表达式结果为true时可访问</td></tr><tr><td style="text-align:left">anonymous()</td><td style="text-align:left">匿名可访问</td></tr><tr><td style="text-align:left">denyAll()</td><td style="text-align:left">用户不可以访问</td></tr><tr><td style="text-align:left">fullyAuthenticated()</td><td style="text-align:left">用户完全认证访问（非remember me下自动登录）</td></tr><tr><td style="text-align:left">hasAnyAuthority(String…)</td><td style="text-align:left">参数中任意权限可访问</td></tr><tr><td style="text-align:left">hasAnyRole(String…)</td><td style="text-align:left">参数中任意角色可访问</td></tr><tr><td style="text-align:left">hasAuthority(String)</td><td style="text-align:left">某一权限的用户可访问</td></tr><tr><td style="text-align:left">hasRole(String)</td><td style="text-align:left">某一角色的用户可访问</td></tr><tr><td style="text-align:left">permitAll()</td><td style="text-align:left">所有用户可访问</td></tr><tr><td style="text-align:left">rememberMe()</td><td style="text-align:left">允许通过remember me登录的用户访问</td></tr><tr><td style="text-align:left">authenticated()</td><td style="text-align:left">用户登录后可访问</td></tr><tr><td style="text-align:left">hasIpAddress(String)</td><td style="text-align:left">用户来自参数中的IP可访问</td></tr></tbody></table><h2>注解与Spring EL</h2><ul><li><strong>@EnableWebSecurity</strong>：开启 Spring Security 注解</li><li><strong>@EnableGlobalMethodSecurity(prePostEnabled=true)</strong>：开启security方法注解</li><li><strong>@PreAuthorize</strong>：在方法调用前，通过SpringEL表达式限制方法访问</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('ROLE_ADMIN')"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果具有权限 ROLE_ADMIN 访问该方法</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>@PostAuthorize</strong>：允许方法调用，但时如果表达式结果为false抛出异常</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//returnObject可以获取返回对象user，判断user属性username是否和访问该方法的用户对象的用户名一样。不一样则抛出异常。</span></span><br><span class="line"><span class="meta">@PostAuthorize</span>(<span class="string">"returnObject.user.username==principal.username"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line">   <span class="comment">//允许进入</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>@PostFilter</strong>：允许方法调用，但必须按表达式过滤方法结果</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将结果过滤，即选出性别为男的用户</span></span><br><span class="line"><span class="meta">@PostFilter</span>(<span class="string">"returnObject.user.sex=='男' "</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//允许进入</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>@PreFilter</strong>：允许方法调用，但必须在进入方法前过滤输入值</li></ul><h2>Spring EL 表达式</h2><table><thead><tr><th style="text-align:left">表达式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">hasRole ([role])</td><td style="text-align:left">当前用户是否拥有指定角色</td></tr><tr><td style="text-align:left">hasAnyRole([role1,role2])</td><td style="text-align:left">多个角色是一个以逗号进行分隔的字符串。如果当前用户拥有指定角色中的任意一个则返回true</td></tr><tr><td style="text-align:left">hasAuthority ([auth])</td><td style="text-align:left">等同于hasRole</td></tr><tr><td style="text-align:left">hasAnyAuthority([auth1,auth2])</td><td style="text-align:left">等同于 hasAnyRole</td></tr><tr><td style="text-align:left">Principle</td><td style="text-align:left">代表当前用户的 principle对象</td></tr><tr><td style="text-align:left">authentication</td><td style="text-align:left">直接从 Security context获取的当前 Authentication对象</td></tr><tr><td style="text-align:left">permitAll</td><td style="text-align:left">总是返回true,表示允许所有的访问</td></tr><tr><td style="text-align:left">denyAll</td><td style="text-align:left">总是返回false,表示拒绝所有的访问访问</td></tr><tr><td style="text-align:left">isAnonymous()</td><td style="text-align:left">当前用户是否是一个匿名用户</td></tr><tr><td style="text-align:left">isRememberMe</td><td style="text-align:left">表示当前用户是否是通过remember - me自动登录的</td></tr><tr><td style="text-align:left">isAuthenticated()</td><td style="text-align:left">表示当前用户是否已经登录认证成功了</td></tr><tr><td style="text-align:left">isFullAuthenticated()</td><td style="text-align:left">如果当前用户既不是一个匿名用户,同时又不是通过Remember-Me自动登录的,则返回true</td></tr></tbody></table><h2>密码加密（PassWordEncoder）</h2><ul><li>Spring 提供的一个用于对密码加密的接口，首选实现类为 BCryptPasswordEncoder</li><li>通过@Bean注解将它注入到IOC容器：</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>过滤器链</h2><h3>SecurityContextPersistenceFilter</h3><ul><li>过滤器链头，是从 SecurityContextRepository 中取出用户认证信息，默认实现为 HttpSessionSecurityContextRepository，它会从 Session 中取出已认证的用户信息，提高效率，避免每次请求都要查询用户认证信息</li><li>取出之后会放入 SecurityContextHolder 中，以便其它 filter 使用，SecurityContextHolder 使用 ThreadLocal 存储用户认证信息，保证线程之间信息隔离，最后再 finally 中清除该信息</li></ul><h3>WebAsyncManagerIntegrationFilter</h3><ul><li>提供了对 SecurityContext 和 WebAsyncManager 的集成，会把 SecurityContext 设置到异步线程，使其也能获取到用户上下文认证信息</li></ul><h3>HanderWriterFilter</h3><ul><li>会往请求的 Header 中添加相应的信息</li></ul><h3>CsrfFilter</h3><ul><li>跨域请求伪造过滤器，通过客户端穿来的 token 与服务端存储的 token 进行对比来判断请求</li></ul><h3>LogoutFilter</h3><ul><li>匹配URL，默认为 /logout，匹配成功后则会用户退出，清除认证信息，若有自己的退出逻辑，该过滤器可以关闭</li></ul><h3>UsernamePasswordAuthenticationFilter</h3><ul><li>登录认证过滤器，默认是对 /login 的 POST 请求进行认证，首先该方法会调用 attemptAuthentication 尝试认证获取一个 Authentication 认证对象，然后通过 sessionStrategy.onAuthentication 执行持久化，也就是保存认证信息，然后转向下一个 Filter，最后调用 successfulAuthentication 执行认证后事件</li><li>attemptAuthentication 该方法是认证的主要方法，认证基本流程为 UserDeatilService 根据用户名获取到用户信息，然后通过 UserDetailsChecker.check 对用户状态进行校验，最后通过 additionalAuthenticationChecks 方法对用户密码进行校验完后认证后，返回一个认证对象</li></ul><h3>DefaultLoginPageGeneratingFilter</h3><ul><li>当请求为登录请求时，生成简单的登录页面，可以关闭</li></ul><h3>BasicAuthenticationFilter</h3><ul><li>Http Basci 认证的支持，该认证会把用户名密码使用 base64 编码后放入 header 中传输，认证成功后会把用户信息放入 SecurityContextHolder 中</li></ul><h3>RequestCacheAwareFilter</h3><ul><li>恢复被打断时的请求</li></ul><h3>SecurityContextHolderAwareRequestFilter</h3><ul><li>针对 Servlet api 不同版本做一些包装</li></ul><h3>AnonymousAuthenticationFIlter</h3><ul><li>SecurityContextHolder 中认证信息为空，则会创建一个匿名用户到 SecurityContextHolder 中</li></ul><h3>SessionManagementFilter</h3><ul><li>与登录认证拦截时作用一样，持久化用户登录信息，可以保存到 Session 中，也可以保存到 cookie 或 redis 中</li></ul><h3>ExceptionTranslationFilter</h3><ul><li>异常拦截，处于 Filter 链条后部，只能拦截其后面的节点并着重处理 AuthenticationException 与 AccessDeniedException 异常</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Spring Security 模块&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;核心模块&lt;/strong&gt; - spring-security-core.jar：包含核心验证和访问控制类和接口，远程支 持的基本配置API，是基本模块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://hhbbz.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://hhbbz.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker容器部署ELK</title>
    <link href="https://hhbbz.github.io/2018/07/03/%E4%BD%BF%E7%94%A8Docker%E5%AE%B9%E5%99%A8%E9%83%A8%E7%BD%B2ELK/"/>
    <id>https://hhbbz.github.io/2018/07/03/使用Docker容器部署ELK/</id>
    <published>2018-07-03T15:11:29.000Z</published>
    <updated>2018-07-03T15:51:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1>选择镜像</h1><p>选择docker images(在hub.docker.com 搜索 elk 选择 start或pulls比较多的镜像) 本次安装选择的是 sebp/elk,默认本地已安装docker环境docker pull sebp/elk</p><ol><li><p>选择docker镜像登录 hub.docker.com 搜索 'elk', 选择stars 和 pulls 比较多的镜像</p></li><li><p>下载镜像docker pull sebp/elk</p></li></ol><h1>启动docker容器</h1><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --ulimit nofile=65536:65536 -p 5601:5601 -p 9200:9200 -p 5044:5044 -p 5045:5045 -p 5046:5046 -d --restart=always -v /etc/logstash:/etc/logstash -v /etc/localtime:/etc/localtime --name elk sebp/elk</span><br></pre></td></tr></table></figure></p><h2>参数介绍</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--ulimit  来修改容器的ulimit参数(该镜像默认的ulimit值为4096。 不带该参数，启动容器会出现类似 “max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]” 错误)</span><br><span class="line">    -p  指定容器和宿主机映射端口</span><br><span class="line">        5601：  kibana服务端口 HTTP  (web访问)</span><br><span class="line">        9200： Elasticsearch 开发端口 HTTP,保存数据到Elasticsearch中使用</span><br><span class="line">        5044： logstash  收集日志端口 TCP</span><br><span class="line">    -v  挂载目录 可以将logstash 的配置文件挂载在宿主机的目录上，方便随时修改，修改后的配置文件会同步到容器中。</span><br><span class="line">        挂载 /etc/localtime 该目录是为了保证容器和宿主机的时区相同。</span><br><span class="line">        通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。</span><br><span class="line">        现在镜像内就可以共享宿主机里的文件了。</span><br></pre></td></tr></table></figure></p><h1>配置logstash</h1><p>创建以下路径，并在其中创建logstash配置文件 /etc/logstash/conf.d/logstash.conf</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    beats &#123;</span><br><span class="line">        port =&gt; 5044</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;127.0.0.1:9200&quot;]</span><br><span class="line">        index =&gt; &quot;test&quot; ##对应es索引名</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改完配置文件后，执行如下命令来重启logstash<br>docker exec elk /etc/init.d/logstash restart</p><h1>客户端服务器</h1><ol><li>安装filebeat</li></ol><p>Debian/Ubuntu:</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-5.3.2-amd64.deb</span><br><span class="line">sudo dpkg -i filebeat-5.3.2-amd64.deb</span><br></pre></td></tr></table></figure></p><p>Redhat/Centos/Fedora:</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-5.3.2-x86_64.rpm</span><br><span class="line">sudo rpm -vi filebeat-5.3.2-x86_64.rpm</span><br></pre></td></tr></table></figure></p><ol start="2"><li>配置filebeat （默认文件路径 /etc/filebeat/filebeat.yml）</li></ol><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">filebeat.prospectors:</span></span><br><span class="line"><span class="attr">    - input_type:</span> <span class="string">log</span></span><br><span class="line"><span class="attr">document_type:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/data/logs/info.log</span></span><br><span class="line"><span class="string">output.logstash:</span></span><br><span class="line"><span class="attr">    hosts:</span> <span class="string">["18.18.18.18:5044"]</span></span><br></pre></td></tr></table></figure></p><p>paths 需要收集的日志文件路径<br>hosts: logstash 服务IP和端口</p><ol start="3"><li>测试配置文件语法是否正确</li></ol><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/filebeat.sh -configtest /etc/filebeat/filebeat.yml</span><br></pre></td></tr></table></figure></p><p>修改完成后，重启filebeat</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/filebeat restart</span><br></pre></td></tr></table></figure></p><h1>访问kibana页面</h1><ol><li>在已经安装filebeat的客户端服务器上，测试日志收集</li></ol><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 'nihao' &gt;&gt; /data/logs/info.log</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>在浏览器输入 18.18.18.18:5601（IP修改为ELK所在服务器的IP地址）创建 index pattern，选择刚才创建的“test“索引即可，可以在web上看到输入的测试日志。</p></li><li><p>在 http://localhost:9200/_search?pretty 可看到es中的全部索引数据。</p></li><li><p>在 http://localhost:9200/_cat/indices?v 可看到es中的全部索引。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;选择镜像&lt;/h1&gt;
&lt;p&gt;选择docker images(在hub.docker.com 搜索 elk 选择 start或pulls比较多的镜像) 本次安装选择的是 sebp/elk,默认本地已安装docker环境
docker pull sebp/elk&lt;/p&gt;
&lt;ol
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="运维" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Docker" scheme="https://hhbbz.github.io/tags/Docker/"/>
    
      <category term="Linux" scheme="https://hhbbz.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="https://hhbbz.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统CAP定理及详解</title>
    <link href="https://hhbbz.github.io/2018/06/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9FCAP%E5%AE%9A%E7%90%86%E5%8F%8A%E8%AF%A6%E8%A7%A3/"/>
    <id>https://hhbbz.github.io/2018/06/02/分布式系统CAP定理及详解/</id>
    <published>2018-06-02T14:45:55.000Z</published>
    <updated>2019-12-06T08:16:09.171Z</updated>
    
    <content type="html"><![CDATA[<h1>CAP定理简介</h1><p>C：Consistency，多台机器的数据一致性。</p><p>A：Availability，服务可用性，比如你用一个分布式事务从主同步数据到从，这时候服务不可用。</p><p>P：Partition-tolerance，分区容忍性，如果多台机器间，产生了分区，比如网络不通，服务是否可容忍。 等同于，【如果多台服务器有相同的数据，对于分区是可以容忍的】。</p><p>CA：单服务器。</p><p>CP：多服务器，数据强行同步，比如2PC，导致服务短时间不可用。</p><p>AP：多服务器，数据最终一致，比如异步消息，导致主挂了后，从可能没有完整数据。</p><p>Consistency其实就是数据库系统中提到的ACID的另一种表述：</p><ul><li><p>一个用户请求要么成功、要么失败，不能处于中间状态（Atomic）；</p></li><li><p>一旦一个事务完成，将来的所有事务都必须基于这个完成后的状态（Consistent）；</p></li><li><p>未完成的事务不会互相影响（Isolated）；</p></li><li><p>一旦一个事务完成，就是持久的（Durable）。</p></li></ul><p>对于Availability，其概念没有变化，指的是对于一个系统而言，所有的请求都应该‘成功’并且收到‘返回’。</p><p>对于Partition-tolerance，所指就是分布式系统的容错性。节点crash或者网络分片都不应该导致一个分布式系统停止服务。</p><h1>业界方案</h1><p>由于每台机器都可能挂，所以排除CA，即数据需要备多份，P必须满足。从上面可以看出，CP或者AP都有明显缺点，所以选择一个折衷的方案：2f+1台服务器，如果1是主，同步到f台备后就告诉请求方，已经成功。在可用性与一致性方面折衷。</p><p>如果备挂了，不用管，直到它自己恢复。</p><p>如果主挂了，用Raft等选举算法，选举出新的主。选举过程中，服务不可用，大概几百ms。</p><p><strong>即采取AP，保证分布式高可用，并通过弱一致性或最终一致性来同步数据。系统可以不同时达到CAP，而是分时达到。</strong></p><h1>CAP的证明</h1><p>CAP的证明很简单，假设两个节点集{G1, G2}，由于网络分片导致G1和G2之间所有的通讯都断开了，如果在G1中写，在G2中读刚写的数据， G2中返回的值不可能G1中的写值。由于A的要求，G2一定要返回这次读请求，由于P的存在，导致C一定是不可满足的。</p><h1>流行解释</h1><p>目前流行的、对CAP理论解释的情形是从同一数据在网络环境中存在多个副本出发为前提的。为了保证数据不会丢失，同时也是为了增加并发访问量（读写分离），在企业级的数据管理方案中，一般必须考虑数据的冗余存储问题，而这应该是通过在网络上的其他独立物理存储节点上保留另一份、或多份数据副本来实现的。因为在同一个存储节点上的数据冗余明显不能解决单点故障问题，这与通过多节点集群来提供更好的计算可用性的道理是相同的。</p><p>数据在节点A、B、C上保留了三份，如果对节点A上的数据进行了修改，然后再让客户端通过网络对该数据进行读取。那么，客户端的读取操作什么时候返回呢？</p><p>一种情况是要求节点A、B、C的三份数据完全一致后返回。也就是说，这时从任何一个网络节点读取的数据都是一样的，这就是所谓的强一致性读。很明显，这时数据读取的Latency要高一些（因为要等数据在网络中的复制），同时A、B、C三个节点中任何一个宕机，都会导致数据不可用。也就是说，要保证强一致性，网络中的副本越多，数据的可用性就越差。</p><p>另一种情况是，允许读操作立即返回，容忍B节点的读取与A节点的读取不一致的情况发生。这样一来，可用性显然得到了提高，网络中的副本也可以多一些，唯一得不到保证的是数据一致性。当然，对写操作同样也有多个节点一致性的情况，在此不再赘述。</p><p>可以看出，上述对CAP理论的解释主要是从网络上多个节点之间的读写一致性出发考虑问题的。而这一点，对于关系型数据库意味着什么呢？当然主要是指通常所说的Standby（关于分布式事务，涉及到更多考虑，随后讨论）情况。对此，在实践中我们大多已经采取了弱一致性的异步延时同步方案，以提高可用性。这种情况并不存在关系型数据库为保证C、A而放弃P的情况；而对海量数据管理的需求，关系型数据库扩展过程中所遇到的性能瓶颈，似乎也并不是CAP理论中所描述的那种原因造成的。那么，上述流行的说法中所描述的关系型数据库为保证C、A而牺牲P到底是在指什么呢？ 如果只将CAP当作分布式系统中多个数据副本之间的读写一致性问题的通用理论对待，那么就可以得出结论：CAP既适用于NoSQL数据库，也适用于关系型数据库。它是NoSQL数据库、关系型数据库，乃至一切分布式系统在设计数据多个副本之间读写一致性问题时需要遵循的共同原则。</p><h1>解决CAP</h1><p>根据一些专家的分析，CAP并不是一个严谨的定律，并不是牺牲了Consistency，就一定能同时获得Availability和Partition Tolerance。还有一个很重要的因素是Latency，在CAP中并没有体现。在现在NoSQL以及其他一些大规模设计时，A和P并不是牺牲C或部分牺牲C的借口，因为即使牺牲了C，也不一定A和P，并且C不一定必须要牺牲。</p><p>淘宝一天就处理了1亿零580万，而12306一天处理的交易仅仅166万条 ，如果从并发性上来说，淘宝的并发量远比12306大，但天猫的商品信息，促销数据都可以做缓存，做CDN，而12306的“商品”是一个个座位，这些座位必须通过后端数据库即时查询出来，状态的一致性要求很高。</p><p>从这点上看，12306的商品信息很难利用到缓存，因此12306查看“商品”的代价是比较大的，涉及到一系列的后端数据库操作，从这个角度讲，12306的复杂度是高于天猫的。 淘宝的商品相对独立，而12306商品之间的关联性很大，由于CAP定律限制，如果其商品的一致性要求过高，必然对可用性和分区容错性造成影响。</p><p>因此，业务设计上，如果找到一条降低一致性要求时，还能保证业务的正确性的业务分拆之路。举个例子，火车票查询时，不要显示多少张，而是显示“有”或“无”，或者显示&gt;100张，50~100,小于50等，这样就可以减小状态的更新频率，充分使用缓存数据。</p><p>CAP 理论说在一个系统中对某个数据不存在一个算法同时满足 Consistency, Availability, Partition-tolerance。注意，这里边最重要和最容易被人忽视的是限定词“对某个数据不存在一个算法”。这就是说在一个系统中，可以对某些数据做到 CP, 对另一些数据做到 AP，就算是对同一个数据，调用者可以指定不同的算法，某些算法可以做到 CP，某些算法可以做到 AP。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;CAP定理简介&lt;/h1&gt;
&lt;p&gt;C：Consistency，多台机器的数据一致性。&lt;/p&gt;
&lt;p&gt;A：Availability，服务可用性，比如你用一个分布式事务从主同步数据到从，这时候服务不可用。&lt;/p&gt;
&lt;p&gt;P：Partition-tolerance，分区容忍性，如
      
    
    </summary>
    
      <category term="后端" scheme="https://hhbbz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="分布式" scheme="https://hhbbz.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
