<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Elasticsearch初体验</title>
      <link href="/2018/08/20/Elasticsearch%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2018/08/20/Elasticsearch%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h1>简介</h1><p>Elasticsearch 是一款稳定高效的分布式搜索和分析引擎，它的底层基于 Lucene，并提供了友好的 RESTful API 来对数据进行操作，还有比较重要的一点是， Elasticsearch 开箱即可用，上手也比较容易。目前 Elasticsearch 在搭建企业级搜索（如日志搜索、商品搜索等）平台中很广泛，官网也提供了不少案例，比如：</p><pre><code>* GitHub 使用 Elasticsearch 检索超过 800 万的代码库* eBay 使用 Elasticsearch 搜索海量的商品数据* Netflix 使用 Elasticsearch 来实现高效的消息传递系统</code></pre><p>本文主要介绍 Elasticsearch 的基本概念及入门使用。</p><h1>安装</h1><p>在安装 Elasticsearch 之前，请确保你的计算机已经安装了 Java。目前 Elasticsearch 的最新版是 5.2，需要安装 Java 8，如果你用的是老版本的 Elasticsearch，如 2.x 版，可用 Java 7，但还是推荐使用 Java 8。</p><p>可以使用如下的命令检查 Java 的版本：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> java -version</span><br></pre></td></tr></table></figure></p><p>接着，下载最新版本的 Elasticsearch，可使用 wget 下载，如下：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.2.2.tar.gz</span><br></pre></td></tr></table></figure></p><p>Windows 用户也可以下载 .zip 格式的安装包。</p><p>下载完后进行解压：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tar -zxvf elasticsearch-5.2.2.tar.gz</span><br></pre></td></tr></table></figure></p><h2>运行</h2><p>首先，Elasticsearch不允许通过root管理员运行，所以我们要新建一个非管理员用户。</p><ol><li>useradd yourname ：新建账户</li><li>passwd yourname ：设置密码</li><li>su yourname：切换到新建账户</li></ol><p>然后，我们进入到刚刚解压出来的目录中：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd elasticsearch-5.2.2</span><br></pre></td></tr></table></figure></p><p>接着，使用如下命令启动 Elasticsearch：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bin/elasticsearch -d</span><br></pre></td></tr></table></figure></p><p>此时，如果正常的话，你可以在终端看到类似如下的输出：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[2018-08-19T23:25:09,961][INFO ][o.e.n.Node               ] [] initializing ...</span><br><span class="line">[2018-08-19T23:25:10,073][INFO ][o.e.e.NodeEnvironment    ] [yO11WLM] using [1] data paths, mounts [[/ (/dev/disk0s2)]], net usable_space [141.1gb], net total_space [232.9gb], spins? [unknown], types [hfs]</span><br><span class="line">[2018-08-19T23:25:10,074][INFO ][o.e.e.NodeEnvironment    ] [yO11WLM] heap size [1.9gb], compressed ordinary object pointers [true]</span><br><span class="line">[2018-08-19T23:25:10,095][INFO ][o.e.n.Node               ] node name [yO11WLM] derived from node ID [yO11WLMOQDuAOpZbYZYjzw]; set [node.name] to override</span><br><span class="line">[2018-08-19T23:25:10,100][INFO ][o.e.n.Node               ] version[5.2.2], pid[7607], build[db0d481/2017-02-09T22:05:32.386Z], OS[Mac OS X/10.11.5/x86_64], JVM[Oracle Corporation/Java HotSpot(TM) 64-Bit Server VM/1.8.0_102/25.102-b14]</span><br><span class="line">[2018-08-19T23:25:11,363][INFO ][o.e.p.PluginsService     ] [yO11WLM] loaded module [aggs-matrix-stats]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>上面的命令是在前台运行的，如果想在后台以守护进程模式运行，可以加 -d 参数。Elasticsearch 启动后，也启动了两个端口 9200 和 9300：</p><p>9200 端口：HTTP RESTful 接口的通讯端口9300 端口：TCP 通讯端口，用于集群间节点通信和与 Java 客户端通信的端口</p><p>现在，让我们做一些测试。在浏览器访问链接 http://localhost:9200/ ，或使用 curl 命令：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl 'http://localhost:9200/?pretty'</span><br></pre></td></tr></table></figure></p><p>我们可以看到类似如下的输出：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"yO11WLM"</span>,</span><br><span class="line">  <span class="attr">"cluster_name"</span> : <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"cluster_uuid"</span> : <span class="string">"yC8BGwzlSnu_zGbKL918Xg"</span>,</span><br><span class="line">  <span class="attr">"version"</span> : &#123;</span><br><span class="line">    <span class="attr">"number"</span> : <span class="string">"5.2.1"</span>,</span><br><span class="line">    <span class="attr">"build_hash"</span> : <span class="string">"db0d481"</span>,</span><br><span class="line">    <span class="attr">"build_date"</span> : <span class="string">"2017-02-09T22:05:32.386Z"</span>,</span><br><span class="line">    <span class="attr">"build_snapshot"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"lucene_version"</span> : <span class="string">"6.4.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>概念</h1><p>在进一步使用 Elasticsearch 之前，让我们先了解几个关键概念。</p><p>在逻辑层面：</p><ul><li>Index (索引)：这里的 Index 是名词，一个 Index 就像是传统关系数据库的 Database，它是 Elasticsearch 用来存储数据的逻辑区域</li><li>Document (文档)：Elasticsearch 使用 JSON 文档来表示一个对象，就像是关系数据库中一个 Table 中的一行数据</li><li>Type (类型)：文档归属于一种 Type，就像是关系数据库中的一个 Table。(目前官方不推荐使用)</li><li>Field (字段)：每个文档包含多个字段，类似关系数据库中一个 Table 的列</li></ul><p>我们用一个表格来做类比，如下：</p><table><thead><tr><th style="text-align:left">Elasticsearch</th><th style="text-align:left">MySQL</th></tr></thead><tbody><tr><td style="text-align:left">Index</td><td style="text-align:left">Database</td></tr><tr><td style="text-align:left">Type</td><td style="text-align:left">Table</td></tr><tr><td style="text-align:left">Document</td><td style="text-align:left">Row</td></tr><tr><td style="text-align:left">Field</td><td style="text-align:left">Column</td></tr></tbody></table><p>在物理层面：</p><ul><li>Node (节点)：node 是一个运行着的 Elasticsearch 实例，一个 node 就是一个单独的 server</li><li>Cluster (集群)：cluster 是多个 node 的集合</li><li>Shard (分片)：数据分片，一个 index 可能会存在于多个 shard</li></ul><h1>使用</h1><p>接下来，我们看看如何建立索引、创建文档等，就好比在 MySQL 中进行诸如创建数据库，插入数据等操作。</p><h2>添加文档</h2><p>下面，我们将创建一个存储电影信息的 Document：</p><ul><li>Index 的名称为 movie</li><li>Type 为 adventure</li><li>Document 有两个字段：name 和 actors</li></ul><p>我们使用 Elasticsearch 提供的 RESTful API 来执行上述操作，如图所示：</p><p><img src="/2018/08/20/Elasticsearch初体验/1.png" title="图片"></p><ul><li>用 url 表示一个资源，比如 /movie/adventure/1 就表示一个 index 为 movie，type 为 adventure，id 为 1 的 document</li><li>用 http 方法操作资源，如使用 GET 获取资源，使用 POST、PUT 新增或更新资源，使用 DELETE 删除资源等</li></ul><p>我们可以使用 curl 命令来执行上述操作：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -i -X PUT "localhost:9200/movie/adventure/1" -d '&#123;"name": "Life of Pi", "actors": ["Suraj", "Irrfan"]&#125;'</span><br></pre></td></tr></table></figure></p><p>不过，本文推荐使用 httpie，类似 curl，但比 curl 更好用，将上面的命令换成 httpie，如下：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http put :9200/movie/adventure/1 name="Life of Pi" actors:='["Suraj", "Irrfan"]'</span><br></pre></td></tr></table></figure></p><p>上面的命令结果如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Location: /movie/adventure/1</span><br><span class="line">content-encoding: gzip</span><br><span class="line">content-type: application/json; charset=UTF-8</span><br><span class="line">transfer-encoding: chunked</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"_index"</span>: <span class="string">"movie"</span>,</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">        <span class="attr">"failed"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"_type"</span>: <span class="string">"adventure"</span>,</span><br><span class="line">    <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"created"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"result"</span>: <span class="string">"created"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，我们已经成功创建了一个 <strong>_index</strong> 为 movie，<strong>_type</strong> 为 adventure，<strong>_id</strong> 为 1 的文档。</p><p>我们通过 GET 请求来查看这个文档的信息：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http :9200/movie/adventure/1</span><br></pre></td></tr></table></figure></p><p>结果如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">content-encoding: gzip</span><br><span class="line">content-type: application/json; charset=UTF-8</span><br><span class="line">transfer-encoding: chunked</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"_index"</span>: <span class="string">"movie"</span>,</span><br><span class="line">    <span class="attr">"_source"</span>: &#123;</span><br><span class="line">        <span class="attr">"actors"</span>: [</span><br><span class="line">            <span class="string">"Suraj"</span>,</span><br><span class="line">            <span class="string">"Irrfan"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Life of Pi"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"_type"</span>: <span class="string">"adventure"</span>,</span><br><span class="line">    <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"found"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，原始的文档数据存在了 <strong>_source</strong> 字段中。</p><p>如果我们的数据没有 id，也可以让 Elasticsearch 自动为我们生成，此时要使用 POST 请求，形式如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /movie/adventure/</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Life of Pi"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>更新整个文档</h2><p>当我们使用 PUT 方法指明文档的 <strong>_index</strong>, <strong>_type</strong> 和 <strong>_id</strong>时，如果 <strong>_id</strong> 已存在，则新文档会替换旧文档，此时文档的 <strong>_version</strong> 会增加 1，并且 <strong>_created</strong> 字段为 false。比如：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http put :9200/movie/adventure/1 name="Life of Pi"</span><br></pre></td></tr></table></figure></p><p>结果如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">content-encoding: gzip</span><br><span class="line">content-type: application/json; charset=UTF-8</span><br><span class="line">transfer-encoding: chunked</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"_index"</span>: <span class="string">"movie"</span>,</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">        <span class="attr">"failed"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"_type"</span>: <span class="string">"adventure"</span>,</span><br><span class="line">    <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"created"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"result"</span>: <span class="string">"updated"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 GET 请求查看新文档的数据：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http :9200/movie/adventure/1</span><br></pre></td></tr></table></figure></p><p>结果如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">content-encoding: gzip</span><br><span class="line">content-type: application/json; charset=UTF-8</span><br><span class="line">transfer-encoding: chunked</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"_index"</span>: <span class="string">"movie"</span>,</span><br><span class="line">    <span class="attr">"_source"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Life of Pi"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"_type"</span>: <span class="string">"adventure"</span>,</span><br><span class="line">    <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"found"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，actors 这个字段已经不存在了，文档的 <strong>_version</strong> 变成了 2。因此，为了避免在误操作的情况下，原文档被替换，我们可以使用 <strong>_create</strong> 这个 API，表示只在文档不存在的情况下才创建新文档（返回 201 Created），如果文档存在则不做任何操作（返回 409 Conflict），命令如下：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http put :9200/movie/adventure/1/_create name="Life of Pi"</span><br></pre></td></tr></table></figure></p><p>由于文档 id 存在，会返回 409 Conflict。</p><h2>局部更新</h2><p>在有些情况下，我们只想更新文档的局部，而不是整个文档，这时我们可以使用 <strong>_update</strong> 这个 API。</p><p>现在，待更新的文档信息如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"_index"</span>: <span class="string">"movie"</span>,</span><br><span class="line">    <span class="attr">"_source"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Life of Pi"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"_type"</span>: <span class="string">"adventure"</span>,</span><br><span class="line">    <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"found"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最简单的 update 请求接受一个局部文档参数 <strong>doc</strong>，它会合并到现有文档中：将对象合并在一起，存在的标量字段被覆盖，新字段被添加。</p><p>形式如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /movie/adventure/1/_update</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"doc"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"life of pi"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于有嵌套字段，我们可以这样使用 http（这里需要注意使用 POST 方法）：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> echo '&#123;"doc": &#123;"actors": ["Suraj", "Irrfan"]&#125;&#125;' | http post :9200/movie/adventure/1/_update</span><br></pre></td></tr></table></figure></p><p>上面的命令中，我们添加了一个新的字段：actors，结果如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">content-encoding: gzip</span><br><span class="line">content-type: application/json; charset=UTF-8</span><br><span class="line">transfer-encoding: chunked</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"_index"</span>: <span class="string">"movie"</span>,</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">        <span class="attr">"failed"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"_type"</span>: <span class="string">"adventure"</span>,</span><br><span class="line">    <span class="attr">"_version"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"result"</span>: <span class="string">"updated"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，_version 增加了 1，result 的结果是 updated。</p><h2>检索文档</h2><h3>检索某个文档</h3><p>要检索某个文档很简单，我们只需使用 GET 请求并指出文档的 index, type, id 就可以了，比如：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http :9200/movie/adventure/1/</span><br></pre></td></tr></table></figure></p><p>响应内容会包含文档的元信息，文档的原始数据存在 <strong>_source</strong> 字段中。</p><p>我们也可以直接检索出文档的 <strong>_source</strong> 字段，如下：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http :9200/movie/adventure/1/_source</span><br></pre></td></tr></table></figure></p><h3>检索所有文档</h3><p>我们可以使用 <strong>_search</strong> 这个 API 检索出所有的文档，命令如下：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http :9200/movie/adventure/_search</span><br></pre></td></tr></table></figure></p><p>返回结果如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">        <span class="attr">"failed"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"hits"</span>: &#123;</span><br><span class="line">        <span class="attr">"hits"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">                <span class="attr">"_index"</span>: <span class="string">"movie"</span>,</span><br><span class="line">                <span class="attr">"_score"</span>: <span class="number">1.0</span>,</span><br><span class="line">                <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                    <span class="attr">"actors"</span>: [</span><br><span class="line">                        <span class="string">"Suraj"</span>,</span><br><span class="line">                        <span class="string">"Irrfan"</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">"name"</span>: <span class="string">"Life of Pi"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"_type"</span>: <span class="string">"adventure"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"max_score"</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"took"</span>: <span class="number">299</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，<strong>hits</strong> 这个 object 包含了 hits 数组，total 等字段，其中，hits 数组包含了所有的文档，这里只有一个文档，total 表明了文档的数量，默认情况下会返回前 10 个结果。我们也可以设定 <strong>From/Size</strong> 参数来获取某一范围的文档，可参考这里，比如：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http :9200/movie/adventure/_search?from=1&amp;size=5</span><br></pre></td></tr></table></figure></p><p>当不指定 from 和 size 时，会使用默认值，其中 from 的默认值是 0，size 的默认值是 10。</p><h3>检索某些字段</h3><p>有时候，我们只需检索文档的个别字段，这时可以使用 <strong>_source</strong> 参数，多个字段可以使用逗号分隔，如下所示：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http :9200/movie/adventure/1?_source=name</span><br><span class="line"><span class="meta">$</span> http :9200/movie/adventure/1?_source=name,actors</span><br></pre></td></tr></table></figure></p><h3>query string 搜索</h3><p>query string 搜索以 <strong>q=field:value</strong> 的形式进行查询，比如查询 name 字段含有 life 的电影：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http :9200/movie/adventure/_search?q=name:life</span><br></pre></td></tr></table></figure></p><h3>DSL 搜索</h3><p>上面的 query string 搜索比较轻量级，只适用于简单的场合。Elasticsearch 提供了更为强大的 DSL（Domain Specific Language）查询语言，适用于复杂的搜索场景，比如全文搜索。我们可以将上面的 query string 搜索转换为 DSL 搜索，如下：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /movie/adventure/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123;</span><br><span class="line">            <span class="attr">"name"</span> : <span class="string">"life"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果使用 httpie，可以这样：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> echo '&#123;"query": &#123;"match": &#123;"name": "life"&#125;&#125;&#125;' | http get :9200/movie/adventure/_search</span><br></pre></td></tr></table></figure></p><p>如果使用 curl，可以这样：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -X GET "127.0.0.1:9200/movie/adventure/_search" -d '&#123;"query": &#123;"match": &#123;"name": "life"&#125;&#125;&#125;'</span><br></pre></td></tr></table></figure></p><h2>文档是否存在</h2><p>使用 HEAD 方法查看文档是否存在：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http head :9200/movie/adventure/1</span><br></pre></td></tr></table></figure></p><p>如果文档存在则返回 200，否则返回 404。</p><h2>删除文档</h2><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> http delete :9200/movie/adventure/1</span><br></pre></td></tr></table></figure></p><h1>小结</h1><ul><li>Elasticsearch 通过简单的 RESTful API 来隐藏 Lucene 的复杂性，从而让全文搜索变得简单</li><li>在创建文档时，我们可以用 POST 方法指定将文档添加到某个 <strong>_index/_type</strong> 下，来让 Elasticsearch自动生成唯一的 <strong>_id</strong>；而用 PUT 方法指定将文档的 <strong>_index/_type/_id</strong></li></ul><h1>参考资料</h1><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html" target="_blank" rel="noopener">Elasticsearch Reference</a></li><li><a href="https://legacy.gitbook.com/book/looly/elasticsearch-the-definitive-guide-cn/details" target="_blank" rel="noopener">Elasticsearch 权威指南</a></li></ul>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ThreadLocal线程安全机制与坑</title>
      <link href="/2018/08/19/ThreadLocal%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%9D%91/"/>
      <url>/2018/08/19/ThreadLocal%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>Java 多线程类库对于共享数据的读写控制主要采用锁机制保证线程安全，本文所要探究的 ThreadLocal 则采用了一种完全不同的策略。ThreadLocal 不是用来解决共享数据的并发访问问题的，它让每个线程都将目标数据复制一份作为线程私有，后续对于该数据的操作都是在各自私有的副本上进行，线程之间彼此相互隔离，也就不存在竞争问题。</p><p>下面的例子演示了 ThreadLocal 的典型应用场景，在 jdk 1.8 之前，如果我们希望对日期和时间进行格式化操作，则需要使用 SimpleDateFormat 类，而我们知道它是是非线程安全的，在多线程并发执行时会出现一些奇怪的问题，而对于该类使用的最佳实践则是采用 ThreadLocal 进行包装，以保证每个线程都有一份属于自己的 SimpleDateFormat 对象，如下所示：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;SimpleDateFormat&gt; sdf = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1>一. 线程安全机制</h1><p>那么 ThreadLocal 是怎么做到让修饰的对象能够在每个线程中各持有一份呢？我们先来简单的概括一下：在 ThreadLocal 中定义了一个静态内部类 ThreadLocalMap，可以将其理解为一个特有的 Map 类型，而在 Thread 类中声明了一个 ThreadLocalMap 类型的属性 threadLocals，所以针对每个 Thread 对象，也就是每个线程来说都包含了一个 ThreadLocalMap 对象，即每个线程都有一个属于自己的内存数据库，而数据库中存储的就是我们用 ThreadLocal 修饰的对象，这里的 key 就是对应的 ThreadLocal 对象，而 value 就是我们记录在 ThreadLocal 中的值。当希望获取该对象时，我们首先需要拿到当前线程对应的 Thread 对象，然后获取到该对象对应的 threadLocals 属性，也就拿到了线程私有的内存数据库，最后以 ThreadLocal 对象为 key 获取到其修饰的目标值。整个过程还是有点绕的，可以借助下面这幅图进行理解。</p><p><img src="/2018/08/19/ThreadLocal线程安全机制与坑/1.png" title="图片"></p><h2>1.1 内存数据库 ThreadLocalMap</h2><p>接下来看一下相应的源码实现，首先来看一下内部定义的 ThreadLocalMap 静态内部类：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弱引用的key，继承自 WeakReference</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** ThreadLocal 修饰的对象 */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 初始化大小，必须是二次幂 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">/** 承载键值对的表，长度必须是二次幂 */</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    <span class="comment">/** 记录键值对表的大小 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 再散列阈值 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        Entry[] parentTable = parentMap.table;</span><br><span class="line">        <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">        setThreshold(len);</span><br><span class="line">        table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            Entry e = parentTable[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Object value = key.childValue(e.value);</span><br><span class="line">                    Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                    <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    table[h] = c;</span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略相应的方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ThreadLocalMap 是一个定制化的 Map 实现，这里可以简单将其理解为一般的 Map，用作键值存储的内存数据库，至于为什么要专门实现而不是复用已有的 HashMap，我们在后面进行说明。</p><h2>1.2 ThreadLocal 方法实现</h2><p>了解了 ThreadLocalMap 的定义，我们再来看一下 ThreadLocal 的实现。对于 ThreadLocal 来说，对外暴露的方法主要有 get、set，以及 remove 三个，下面逐一来看：</p><ul><li>获取线程私有值：get()</li></ul><p>与一般的 Map 取值操作不同，这里的 get() 并没有要求提供查询的 key，也正如前面所说的，这里的 key 就是调用 get() 方法的对象自身：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对象的 threadLocals 属性</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 以 ThreadLocal 对象为 key 获取目标线程私有值</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果当前线程对应的内存数据库 map 对象还未创建，则会调用 setInitialValue() 方法执行创建，如果在构造 ThreadLocal 对象时覆盖实现了 initialValue() 方法，则会调用该方法获取构造的初始化值并记录到创建的 map 对象中：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用模板方法 initialValue 获取指定的初始值</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 以当前 ThreadLocal 对象为 key 记录初始值</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 创建 map 并记录初始值</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>添加线程私有值：set(T value)</li></ul><p>再来看一下 set 方法，因为 key 就是当前 ThreadLocal 对象，所以 set 方法也不需要指定 key：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对象的 threadLocals 属性</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 以当前 ThreadLocal 对象为 key 记录线程私有值</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>和 get 方法的流程大致一样，都是操作当前线程私有的内存数据库 ThreadLocalMap，并记录目标值。</p><ul><li>删除线程私有值：remove()</li></ul><p>remove 方法以当前 ThreadLocal 为 key，从当前线程内存数据库 ThreadLocalMap 中删除目标值，具体逻辑比较简单：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 以当前 ThreadLocal 对象为 key</span></span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ThreadLocal 对外暴露的功能虽然有点小神奇，但是具体对应到内部实现并没有什么复杂的逻辑，如果我们把每个线程持有的专属 ThreadLocalMap 对象理解为当前线程的私有数据库，那么也就不难理解 ThreadLocal 的运行机制，每个线程自己维护自己的数据，彼此相互隔离，不存在竞争，也就没有线程安全问题可言。</p><h1>二. 真的就高枕无忧了吗？</h1><p>虽然对于每个线程来说数据是隔离的，但这也不表示任何对象丢到 ThreadLocal 中就万事大吉了，思考一下下面几种情况：</p><pre><code>1. 如果记录在 ThreadLocal 中的是一个线程共享的外部对象呢？2. 引入线程池，情况又会有什么变化？3. 如果 ThreadLocal 被 static 关键字修饰呢？</code></pre><p>先来看 <strong>第一个问题</strong> ，如果我们记录的是一个外部线程共享的对象，虽然我们以当前线程私有的 ThreadLocal 对象作为 key 对其进行了存储，但是恶魔终究是恶魔，共享的本质并不会因此而改变，这种情况下的访问还是需要进行同步控制，最好的方法就是从源头屏蔽掉这类问题。我们来举个例子：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalWithSharedInstance</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list 是一个事实共享的实例，即使被 ThreadLocal 修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;List&lt;String&gt;&gt; threadLocal = ThreadLocal.withInitial(() -&gt; list);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            List&lt;String&gt; li = threadLocal.get();</span><br><span class="line">            li.add(Thread.currentThread().getName() + <span class="string">"_"</span> + RandomUtils.nextInt(<span class="number">0</span>, <span class="number">10</span>));</span><br><span class="line">            threadLocal.set(li);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"[Thread-"</span> + Thread.currentThread().getName() + <span class="string">"], list="</span> + threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread ta = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadLocalWithSharedInstance(), <span class="string">"a"</span>);</span><br><span class="line">        Thread tb = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadLocalWithSharedInstance(), <span class="string">"b"</span>);</span><br><span class="line">        Thread tc = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadLocalWithSharedInstance(), <span class="string">"c"</span>);</span><br><span class="line">        ta.start(); ta.join();</span><br><span class="line">        tb.start(); tb.join();</span><br><span class="line">        tc.start(); tc.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上程序最终的输出如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Thread-a], list=[a_2, a_7, a_4, a_5, a_7]</span><br><span class="line">[Thread-b], list=[a_2, a_7, a_4, a_5, a_7, b_3, b_3, b_4, b_7, b_7]</span><br><span class="line">[Thread-c], list=[a_2, a_7, a_4, a_5, a_7, b_3, b_3, b_4, b_7, b_7, c_8, c_3, c_4, c_7, c_5]</span><br></pre></td></tr></table></figure></p><p>可以看到虽然使用了 ThreadLocal 修饰，但是 list 还是以共享的方式在多个线程之间被访问，如果不加同步控制，则会存在线程安全问题。</p><p>再来看 <strong>第二个问题</strong> ，相对问题一来说引入线程池就更加可怕，因为大部分时候我们都不会意识到问题的存在，直到代码暴露出奇怪的现象，这个时候并没有违背线程私有的本质，只是一个线程被复用来处理多个业务，而这个被线程私有的对象也会在多个业务之间被 “共享”。例如：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalWithThreadPool</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;List&lt;String&gt;&gt; threadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"thread-"</span> + Thread.currentThread().getId() + <span class="string">" init thread local"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            List&lt;String&gt; li = threadLocal.get();</span><br><span class="line">            li.add(Thread.currentThread().getId() + <span class="string">"_"</span> + RandomUtils.nextInt(<span class="number">0</span>, <span class="number">10</span>));</span><br><span class="line">            threadLocal.set(li);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"[Thread-"</span> + Thread.currentThread().getId() + <span class="string">"], list="</span> + threadLocal.get());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cpu core size : "</span> + NCPU);</span><br><span class="line">        List&lt;Callable&lt;Boolean&gt;&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;(NCPU * <span class="number">2</span>);</span><br><span class="line">        ThreadLocalWithThreadPool tl = <span class="keyword">new</span> ThreadLocalWithThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU * <span class="number">2</span>; i++) &#123;</span><br><span class="line">            tasks.add(tl);</span><br><span class="line">        &#125;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        List&lt;Future&lt;Boolean&gt;&gt; futures = es.invokeAll(tasks);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Future&lt;Boolean&gt; future : futures) &#123;</span><br><span class="line">            future.get();</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上程序的最终输出如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cpu core size : 8</span><br><span class="line">thread-12 init thread local</span><br><span class="line">thread-11 init thread local</span><br><span class="line">[Thread-12], list=[12_8, 12_8, 12_4, 12_0, 12_1]</span><br><span class="line">[Thread-11], list=[11_3, 11_3, 11_4, 11_8, 11_4]</span><br><span class="line">[Thread-12], list=[12_8, 12_8, 12_4, 12_0, 12_1, 12_6, 12_7, 12_8, 12_8, 12_8]</span><br><span class="line">[Thread-11], list=[11_3, 11_3, 11_4, 11_8, 11_4, 11_0, 11_2, 11_1, 11_7, 11_9]</span><br><span class="line">[Thread-12], list=[12_8, 12_8, 12_4, 12_0, 12_1, 12_6, 12_7, 12_8, 12_8, 12_8, 12_8, 12_2, 12_8, 12_0, 12_6]</span><br><span class="line">[Thread-11], list=[11_3, 11_3, 11_4, 11_8, 11_4, 11_0, 11_2, 11_1, 11_7, 11_9, 11_0, 11_6, 11_1, 11_2, 11_9]</span><br><span class="line">[Thread-12], list=[12_8, 12_8, 12_4, 12_0, 12_1, 12_6, 12_7, 12_8, 12_8, 12_8, 12_8, 12_2, 12_8, 12_0, 12_6, 12_6, 12_3, 12_3, 12_1, 12_1]</span><br><span class="line">[Thread-11], list=[11_3, 11_3, 11_4, 11_8, 11_4, 11_0, 11_2, 11_1, 11_7, 11_9, 11_0, 11_6, 11_1, 11_2, 11_9, 11_7, 11_5, 11_0, 11_6, 11_9]</span><br><span class="line">[Thread-12], list=[12_8, 12_8, 12_4, 12_0, 12_1, 12_6, 12_7, 12_8, 12_8, 12_8, 12_8, 12_2, 12_8, 12_0, 12_6, 12_6, 12_3, 12_3, 12_1, 12_1, 12_0, 12_0, 12_1, 12_9, 12_5]</span><br><span class="line">[Thread-11], list=[11_3, 11_3, 11_4, 11_8, 11_4, 11_0, 11_2, 11_1, 11_7, 11_9, 11_0, 11_6, 11_1, 11_2, 11_9, 11_7, 11_5, 11_0, 11_6, 11_9, 11_2, 11_7, 11_0, 11_8, 11_0]</span><br><span class="line">[Thread-12], list=[12_8, 12_8, 12_4, 12_0, 12_1, 12_6, 12_7, 12_8, 12_8, 12_8, 12_8, 12_2, 12_8, 12_0, 12_6, 12_6, 12_3, 12_3, 12_1, 12_1, 12_0, 12_0, 12_1, 12_9, 12_5, 12_3, 12_6, 12_6, 12_0, 12_9]</span><br><span class="line">[Thread-11], list=[11_3, 11_3, 11_4, 11_8, 11_4, 11_0, 11_2, 11_1, 11_7, 11_9, 11_0, 11_6, 11_1, 11_2, 11_9, 11_7, 11_5, 11_0, 11_6, 11_9, 11_2, 11_7, 11_0, 11_8, 11_0, 11_0, 11_9, 11_2, 11_7, 11_2]</span><br><span class="line">[Thread-12], list=[12_8, 12_8, 12_4, 12_0, 12_1, 12_6, 12_7, 12_8, 12_8, 12_8, 12_8, 12_2, 12_8, 12_0, 12_6, 12_6, 12_3, 12_3, 12_1, 12_1, 12_0, 12_0, 12_1, 12_9, 12_5, 12_3, 12_6, 12_6, 12_0, 12_9, 12_5, 12_7, 12_7, 12_9, 12_7]</span><br><span class="line">[Thread-11], list=[11_3, 11_3, 11_4, 11_8, 11_4, 11_0, 11_2, 11_1, 11_7, 11_9, 11_0, 11_6, 11_1, 11_2, 11_9, 11_7, 11_5, 11_0, 11_6, 11_9, 11_2, 11_7, 11_0, 11_8, 11_0, 11_0, 11_9, 11_2, 11_7, 11_2, 11_4, 11_9, 11_7, 11_5, 11_5]</span><br><span class="line">[Thread-12], list=[12_8, 12_8, 12_4, 12_0, 12_1, 12_6, 12_7, 12_8, 12_8, 12_8, 12_8, 12_2, 12_8, 12_0, 12_6, 12_6, 12_3, 12_3, 12_1, 12_1, 12_0, 12_0, 12_1, 12_9, 12_5, 12_3, 12_6, 12_6, 12_0, 12_9, 12_5, 12_7, 12_7, 12_9, 12_7, 12_6, 12_1, 12_7, 12_8, 12_7]</span><br><span class="line">[Thread-11], list=[11_3, 11_3, 11_4, 11_8, 11_4, 11_0, 11_2, 11_1, 11_7, 11_9, 11_0, 11_6, 11_1, 11_2, 11_9, 11_7, 11_5, 11_0, 11_6, 11_9, 11_2, 11_7, 11_0, 11_8, 11_0, 11_0, 11_9, 11_2, 11_7, 11_2, 11_4, 11_9, 11_7, 11_5, 11_5, 11_8, 11_5, 11_0, 11_2, 11_2]</span><br></pre></td></tr></table></figure></p><p>在我的 8 核处理器上，我用一个大小为 2 的线程池进行了模拟，可以看到初始化方法被调用了两次，所有线程的操作都是复用这两个线程。回忆一下前文所说的，ThreadLocal 的本质就是每个线程维护一个线程私有的内存数据库来记录线程私有的对象，但是在线程池情况下线程是会被复用的，也就是说线程私有的内存数据库也会被复用，如果在一个线程被使用完准备回放到线程池中之前，我们没有对记录在数据库中的数据执行清理，那么这部分数据就会被下一个复用该线程的业务看到，从而间接的共享了该部分数据。</p><p>最后我们再来看一下 <strong>第三个问题</strong> ，我们尝试将 ThreadLocal 对象用 static 关键字进行修饰：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalWithStaticEmbellish</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;List&lt;String&gt;&gt; threadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"thread-"</span> + Thread.currentThread().getName() + <span class="string">" init thread local"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            List&lt;String&gt; li = threadLocal.get();</span><br><span class="line">            li.add(Thread.currentThread().getId() + <span class="string">"_"</span> + RandomUtils.nextInt(<span class="number">0</span>, <span class="number">10</span>));</span><br><span class="line">            threadLocal.set(li);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"[Thread-"</span> + Thread.currentThread().getName() + <span class="string">"], list="</span> + threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ThreadLocalWithStaticEmbellish tl = <span class="keyword">new</span> ThreadLocalWithStaticEmbellish();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(tl, String.valueOf((<span class="keyword">char</span>) (i + <span class="number">97</span>)));</span><br><span class="line">            thread.start(); thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上程序的最终输出如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">thread-a init thread local</span><br><span class="line">[Thread-a], list=[11_4, 11_4, 11_4, 11_8, 11_0]</span><br><span class="line">thread-b init thread local</span><br><span class="line">[Thread-b], list=[12_0, 12_9, 12_0, 12_3, 12_3]</span><br><span class="line">thread-c init thread local</span><br><span class="line">[Thread-c], list=[13_6, 13_7, 13_5, 13_2, 13_0]</span><br><span class="line">thread-d init thread local</span><br><span class="line">[Thread-d], list=[14_1, 14_5, 14_5, 14_9, 14_2]</span><br><span class="line">thread-e init thread local</span><br><span class="line">[Thread-e], list=[15_4, 15_2, 15_6, 15_0, 15_8]</span><br><span class="line">thread-f init thread local</span><br><span class="line">[Thread-f], list=[16_7, 16_3, 16_8, 16_0, 16_0]</span><br><span class="line">thread-g init thread local</span><br><span class="line">[Thread-g], list=[17_6, 17_3, 17_8, 17_7, 17_1]</span><br><span class="line">thread-h init thread local</span><br><span class="line">[Thread-h], list=[18_0, 18_4, 18_5, 18_9, 18_3]</span><br><span class="line">thread-i init thread local</span><br><span class="line">[Thread-i], list=[19_7, 19_3, 19_7, 19_2, 19_0]</span><br></pre></td></tr></table></figure></p><p>由程序运行结果可以看到 static 修饰并没有引出什么问题，实际上这也是很容易理解的，ThreadLocal 采用 static 修饰仅仅是让数据库中记录的 key 是一样的，但是每个线程的内存数据库还是私有的，并没有被共享，就像不同的公司都有自己的用户信息表，即使一些公司之间的用户 ID 是一样的，但是对应的用户数据却是完全隔离的。</p><p>以上例子演示了一开始抛出的三个问题，其中问题一和问题二都是 ThreadLocal 使用过程中的小地雷。例子举的不一定恰当，实际中可能也不一定会如示例中这样去使用 ThreadLocal，主要还是为了传达一些意识。如果明白了 ThreadLocal 的内部实现细节，就能够很自然的绕过这些小地雷。</p><h1>三. 真的会内存泄露吗？</h1><p>关于 ThreadLocal 导致内存泄露的问题，曾经有一段时间在网上争得沸沸扬扬，那么到底会不会导致内存泄露呢？这里先给出答案:</p><pre><code>如果使用不恰当，存在内存泄露的可能性。</code></pre><p>我们来分析一下内存泄露的条件和原因，在最开始看 ThreadLocal 源码的时候，我就有一个疑问，<strong>ThreadLocal 为什么要专门实现 ThreadLocalMap，而不是采用已有的 HashMap 代替</strong>？后来分析具体实现时看到执行存储时的 key 为当前 ThreadLocal 对象，不需要专门指定 key 能够在一定程度上简化使用，但这并不足以为此专门去实现 ThreadLocalMap。继续阅读我发现 ThreadLocalMap 在实现 Entry 的时候有些奇怪，居然继承了 WeakReference：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从而让 key 成为一个弱引用，我们知道弱引用对象拥有非常短暂的生命周期，在垃圾收集器线程扫描其所管辖的内存区域过程中，一旦发现了弱引用对象，不管当前内存空间是否足够都会回收它的内存。也就是说这样的设计会很容易导致 ThreadLocal 对象被回收，线程所执行任务的时间长度是不固定的，这样的设计能够方便垃圾收集器回收线程私有的变量。</p><p>所以作者这样设计的目的是为了防止内存泄露，那怎么就变成了被很多文章所分析的是内存泄漏的导火索呢？这些文章的共同观点就是 key 被回收了，但是 value 是一个强引用没有被回收，这些 value 就变成了一个个的僵尸。这样的分析没有错，value 确实存在，且和线程是同生命周期的，但是如下策略可以保证尽量避免内存泄露：</p><pre><code>1. ThreadLocal 在每次执行 get 和 set 操作的时候都会去清理 key 为 null 的 value 值2. value 与线程同生命周期，线程死亡之时，也是 value 被 GC 之日</code></pre><p>策略一没啥好说的，看看源码就知道，我们来举例验证一下策略二：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalWithMemoryLeak</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">My50MB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">50</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.finalize();</span><br><span class="line">            System.out.println(<span class="string">"gc my 50 mb"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.finalize();</span><br><span class="line">            System.out.println(<span class="string">"gc my thread local"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyThreadLocal&lt;My50MB&gt; threadLocal = <span class="keyword">new</span> MyThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread-"</span> + Thread.currentThread().getId() + <span class="string">" is running"</span>);</span><br><span class="line">        threadLocal.set(<span class="keyword">new</span> My50MB());</span><br><span class="line">        threadLocal = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService es = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;Boolean&gt; future = es.submit(<span class="keyword">new</span> ThreadLocalWithMemoryLeak());</span><br><span class="line">        future.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// gc my thread local</span></span><br><span class="line">        System.out.println(<span class="string">"do gc"</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sleep 60s</span></span><br><span class="line">        System.out.println(<span class="string">"sleep 60s"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// gc my 50 mb</span></span><br><span class="line">        System.out.println(<span class="string">"do gc"</span>);</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上程序的最终输出如下</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-11 is running</span><br><span class="line">do gc</span><br><span class="line">gc my thread local</span><br><span class="line">sleep 60s</span><br><span class="line">do gc</span><br><span class="line">gc my 50 mb</span><br></pre></td></tr></table></figure></p><p>可以看到 value 最终还是被 GC 了，虽然第一次 GC 的时候没有被回收，这也验证 value 和线程是同生命周期的，之所以示例中等待 60 秒是因为 Executors.newCachedThreadPool() 中的线程默认生命周期是 60 秒，如果生命周期内该线程没有被再次复用则会死亡，我们这里就是要等待线程死亡，一但线程死亡，value 也就被 GC 了。所以 <strong>出现内存泄露的前提必须是持有 value 的线程一直存活</strong> ，这在使用线程池时是很正常的，在这种情况下 value 一直不会被 GC，因为线程对象与 value 之间维护的是强引用。此外就是 <strong>后续线程执行的业务一直没有调用 ThreadLocal 的 get 或 set 方法，导致不会主动去删除 key 为 null 的 value 对象</strong> ，在满足这两个条件下 value 对象一直常驻内存，所以存在内存泄露的可能性。</p><p>那么我们应该怎么避免呢？前面我们分析过线程池情况下使用 ThreadLocal 存在小地雷，这里的内存泄露一般也都是发生在线程池的情况下，所以在使用 ThreadLocal 时，对于不再有效的 value 主动调用一下 remove 方法来进行清除，从而消除隐患，这也算是最佳实践吧。</p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CompletableFuture终极指南</title>
      <link href="/2018/08/04/CompletableFuture%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/"/>
      <url>/2018/08/04/CompletableFuture%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h1>一、简介</h1><p>java.util.concurrent.CompletableFuture继承于java.util.concurrent.Future，它本身具备Future的所有特性，并且基于JDK1.8的流式编程以及Lambda表达式等实现一元操作符、异步性以及事件驱动编程模型，它的灵活性和更强大的功能是Future无法比拟的。它提供了一共有50多种Api，这些Api的注释比较少，命名也比较生涩，下面将会分类讲解它们的使用方式。CompletableFuture吸收了所有ListenableFuture(Guava)和SettableFuture的优点。此外，内置的lambda表达式使它更接近于Scala/Akka futures。CompletableFuture有两个主要的方面优于Future – 异步回调/转换，这能使得任何线程在任何时刻都可以设置CompletableFuture的值。</p><h1>二、使用流程简述</h1><p>首先，简单地创建新的CompletableFuture并且给你的客户端：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">ask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端代码调用ask().get()，它将永远阻塞，直到CompletableFuture回调，下面是一种回调方式：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">future.complete(<span class="string">"42"</span>);</span><br></pre></td></tr></table></figure></p><p>此时此刻所有客户端 <strong><em>Future(CompletableFuture).get()</em></strong> 将得到字符串的结果。注意的是： <strong><em>CompletableFuture.complete()</em></strong> 只能调用一次，后续调用将被忽略。但也有一个后门叫做 <strong><em>CompletableFuture.obtrudeValue()</em></strong> 覆盖Future之前的值，请小心使用。有时你想处理 <strong><em>CompletableFuture.complete()</em></strong> 调用过程抛出的异常，如果你想进一步传递异常，可以用 <strong><em>CompletableFuture.completeExceptionally(ex)</em></strong> (或者用 <strong><em>obtrudeException(ex)</em></strong> 这样更强大的方法覆盖前面的异常)。 completeExceptionally()也能解锁所有等待的客户端。前面说到get()（永久阻塞等待），其实还有 <strong><em>get（long timeout，TimeUnit unit）</em></strong> 可以设置超时时间（超时会抛出异常），也有 <strong><em>CompletableFuture.join( )</em></strong>（join方法在错误处理方面有着细微的变动。但总体上，它和get方法是一样的）。然后也有 <strong><em>CompletableFuture.getNow(valueIfAbsent)</em></strong> ，这个方法没有阻塞，但是如果Future还没完成将返回默认值，这使得当构建那种我们不想等太久的健壮系统时非常有用。最后的方法静态 <strong><em>completedFuture(value)</em></strong> 来返回已经完成Future的对象，当测试或者写一些适配器层时可能非常有用。</p><h1>三、CompletableFuture主要Api详述</h1><h2>声明</h2><p>如果CompletableFuture的方法没有参数Executor并且以…Async结尾，它将会使用 <strong><em>ForkJoinPool.commonPool()</em></strong> (在JDK8中的通用线程池，基于Fork/join线程池和任务窃取实现），这适用于CompletableFuture类中的大多数的方法。所以下面分析的时候可能会直接跳过命名为…Async的方法。</p><h2>创建和获取CompletableFuture</h2><p>使用 <strong><em>new</em></strong> 关键字新建CompletableFuture实例并不是唯一的选择，CompletableFuture提供了静态工厂方法用于创建自身的实例：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span>;</span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>runAsync()易于理解，注意它需要Runnable，因此它返回CompletableFuture&lt;Void&gt;作为Runnable不返回任何值。如果你需要处理异步操作并返回结果，使用Supplier&lt;U&gt;，它是一个函数式接口，接口如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以这样使用Supplier&lt;U&gt;：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...long running...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"42"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, executor);</span><br></pre></td></tr></table></figure></p><p>换成Lambda表达式：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">finalCompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//...long running...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"42"</span>;</span><br><span class="line">&#125;, executor)；</span><br></pre></td></tr></table></figure></p><h2>转换–CompletableFuture.thenApply()</h2><p>apply一般翻译为’作用于’，但是在CompletableFuture中，***thenApply()***起到转换结果的作用，总结来说就是叠加多个CompletableFuture的功能，把多个CompletableFuture组合在一起，跨线程池进行异步调用，调用的过程就是结果转换的过程。先看下这些方法：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn, Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>其中Function&lt;? super T,? extends U&gt;是函数式接口，此接口如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">    ...<span class="comment">//省略其他流式方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用例子：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; f1 =  = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"42"</span>;</span><br><span class="line">&#125;, executor)；</span><br><span class="line">CompletableFuture&lt;Integer&gt; f2 = f1.thenApply(Integer::parseInt);</span><br><span class="line">CompletableFuture&lt;Double&gt; f3 = f2.thenApply(r -&gt; r * r * Math.PI);</span><br></pre></td></tr></table></figure></p><p>或者直接使用流式编程：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Double&gt; f3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"42"</span>;</span><br><span class="line">&#125;, executor).thenApply(Integer::parseInt).thenApply(r -&gt; r * r * Math.PI);</span><br></pre></td></tr></table></figure></p><h2>终端运行(消费)–CompletableFuture.thenRun()/CompletableFuture.thenAccept()</h2><p>CompletableFuture有两种典型的”最终”阶段方法，其实就是Lambda的终端方法，使用的是Consumer接口(消费操作的接口)。当CompletableFuture的结果已经准备好，thenAccept()执行最终消费操作，thenRun()执行Runnable，没有返回值（或者说返回结果为Void）。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; block)</span></span>;</span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; block)</span></span>;</span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; block,Executor executor)</span></span>;</span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenRun</span><span class="params">(Runnable action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>下面是一个例子：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">future.thenAcceptAsync(dbl -&gt; log.debug(<span class="string">"Result: &#123;&#125;"</span>, dbl), executor);</span><br><span class="line">log.debug(<span class="string">"Continuing"</span>);</span><br></pre></td></tr></table></figure></p><p>thenAccept( )/thenRun( )方法并没有发生阻塞（即使没有明确的executor)。它们像事件侦听器。上例中”Continuing”消息将立即出现，但是这个时候thenAcceptAsync()有可能尚未执行完。thenAccept()和thenRun()的区别是：thenAccept()是针对结果进行消费，因为入参是Consumer函数式接口，有入参无返回值，而thenRun()它的入参是一个Runnable的实例，表示当得到上一步的结果时的操作，也就是当得到上一步的结果则异步执行Runnable。</p><h2>异常处理</h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"test exception"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            future.completeExceptionally(e);</span><br><span class="line">            future.complete(<span class="string">"test success"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">System.out.println(future.get());</span><br><span class="line"><span class="comment">//结果（触发了completeExceptionally后，complete将会失效）：</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.util.concurrent.ExecutionException: java.lang.RuntimeException: test exception</span><br><span class="line">at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:<span class="number">357</span>)</span><br><span class="line">at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:<span class="number">1895</span>)</span><br><span class="line">at org.throwable.TestGitA.main(TestGitA.java:<span class="number">22</span>)</span><br><span class="line">Caused by: java.lang.RuntimeException: test exception</span><br><span class="line">at org.throwable.TestGitA.main(TestGitA.java:<span class="number">17</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>补偿型的例子：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"测试一下异常情况"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">     &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">         System.out.println(e.getMessage());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">     &#125;).join();</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">java.lang.RuntimeException: 测试一下异常情况</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>全方位型的例子：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意这里OK为String类型</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; safe = future.handle((ok, ex) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ok != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(ok);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.warn(<span class="string">"Problem"</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2>CompletableFuture之间建立关联</h2><h3>CompletableFuture的”串联”–CompletableFuture.thenCompose()</h3><p>thenCompose()方法允许你对两个异步操作进行流水线，第一个操作完成时，将其结果作为参数传递给第二个操作。你可以创建两个CompletableFuture对象，对第一个CompletableFuture对象调用thenCompose() ，并向其传递一个函数。当第一个CompletableFuture执行完毕后，它的结果将作为该函数的参数，这个函数的返回值是以第一个CompletableFuture的返回做输入计算出的第二个CompletableFuture对象。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,CompletableFuture&lt;U&gt;&gt; fn)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,CompletableFuture&lt;U&gt;&gt; fn)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,CompletableFuture&lt;U&gt;&gt; fn,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>thenCompose()是一个重要的方法，它允许构建健壮的和异步的管道，没有阻塞和等待的中间步骤。在下面的事例中，仔细观察thenApply()(map)和thenCompose()（flatMap）的类型和差异，calculateRelevance()方法返回CompletableFuture实例：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Document&gt; docFuture = <span class="comment">//...</span></span><br><span class="line">CompletableFuture&lt;CompletableFuture&lt;Double&gt;&gt; f =  docFuture.thenApply(<span class="keyword">this</span>::calculateRelevance);</span><br><span class="line">CompletableFuture&lt;Double&gt; relevanceFuture = docFuture.thenCompose(<span class="keyword">this</span>::calculateRelevance);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Double&gt; <span class="title">calculateRelevance</span><span class="params">(Document doc)</span>  <span class="comment">//...</span></span></span><br></pre></td></tr></table></figure></p><h3>CompletableFuture的”并联”–CompletableFuture.thenCombine()</h3><p>thenCombine()用于连接两个独立的CompletableFuture，它接收名为 BiFunction 的第二参数，这个参数定义了当两个CompletableFuture 对象完成计算后结果如何合并，返回携带计算合并结果的一个新的CompletableFuture。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombine</span><span class="params">(CompletableFuture&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span>;</span><br><span class="line">&lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletableFuture&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span>;</span><br><span class="line">&lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletableFuture&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>假设你有两个CompletableFuture，一个加载Customer另一个加载最近的Shop。他们彼此完全独立，但是当他们完成时，您想要使用它们的值来计算Route。下面是一个例子：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Customer&gt; customerFuture = loadCustomerDetails(<span class="number">123</span>);  <span class="comment">//省略loadCustomerDetails方法代码</span></span><br><span class="line">CompletableFuture&lt;Shop&gt; shopFuture = closestShop();  <span class="comment">//省略closestShop方法代码</span></span><br><span class="line">CompletableFuture&lt;Route&gt; routeFuture = customerFuture.thenCombine(shopFuture, (cust, shop) -&gt; findRoute(cust, shop));</span><br><span class="line">   </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Route <span class="title">findRoute</span><span class="params">(Customer customer, Shop shop)</span> <span class="comment">//...</span></span></span><br></pre></td></tr></table></figure></p><p>新建customerFuture和shopFuture。那么routeFuture包装它们然后“等待”它们完成。当它们的结果准备好了，它会运行我们提供的函数来结合所有的结果(findRoute())。当两个基本的CompletableFuture实例完成并且findRoute()也完成时，这样routeFuture将会完成。</p><h2>结果记录–CompletableFuture.whenComplete()</h2><p>***CompletableFuture.whenComplete()***的作用是CompletableFuture运行完成时，对结果的记录操作，记录的操作由函数BiConsumer&lt;? super T, ? super Throwable&gt;完成，一般BiConsumer这种消费操作应该是终端操作，但是whenComplete返回的是CompletableFuture的接口的实例，这个实例就是调用whenComplete的原始CompletableFuture对象。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">CompletionStage&lt;T&gt; <span class="title">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>一个使用例子如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"测试一下异常情况"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">     &#125;).whenComplete((s, t) -&gt; &#123;</span><br><span class="line">         System.out.println(s);</span><br><span class="line">         System.out.println(t.getMessage());</span><br><span class="line">     &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">         System.out.println(e.getMessage());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">     &#125;).join();</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">java.lang.RuntimeException: 测试一下异常情况</span><br><span class="line">java.lang.RuntimeException: 测试一下异常情况</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>这里也可以看出，如果使用了exceptionally，就会对最终的结果产生影响，也就证明了whenComplete返回的是原始的CompletableFuture对象。</p><h2>结果处理–CompletableFuture.handle()</h2><p><strong><em>CompletableFuture.handle()</em></strong> 的作用是CompletableFuture运行完成时，对结果的处理。这里的完成时有两种情况，一种是正常执行，返回预期的值。另外一种是遇到异常抛出造成程序的中断。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">handle</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>一个出现异常时的例子：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出现异常</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"测试一下异常情况"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">    &#125;).handle((s, t) -&gt; &#123;   <span class="comment">//这里t的参数类型为Throwable。</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hello world"</span>; <span class="comment">//这里是异常不为null时候的逻辑，可以选择补偿，也可以直接抛出异常t，一旦抛出异常，调用join（）的时候异常会外抛。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;).join();</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>一个未出现异常时的例子：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">    &#125;).handle((s, t) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hello world"</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;   <span class="comment">//未出现异常，实际上走到这一步</span></span><br><span class="line">    &#125;).join();</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">s1</span><br></pre></td></tr></table></figure></p><h2>合并消费–CompletableFuture.thenAcceptBoth()</h2><p><strong><em>CompletableFuture.thenAcceptBoth()</em></strong> 用于连接两个独立的CompletableFuture，它接收名为BiConsumer的第二参数，这个参数定义了当两个CompletableFuture对象完成计算后，结果如何消费，有点像thenCombine，但是对于两个CompletableFuture的计算操作是终端操作，没有返回值(或者说返回结果为Void类型)。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action, Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>一个例子如下，5000毫秒后控制台输出”hello world”：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">     &#125;).thenAcceptBoth(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"world"</span>;</span><br><span class="line">     &#125;), (s1, s2) -&gt; System.out.println(s1 + <span class="string">" "</span> + s2));</span><br></pre></td></tr></table></figure></p><h2>合并执行–CompletableFuture.runAfterBoth()</h2><p><strong><em>CompletableFuture.runAfterBoth()</em></strong> 用于连接两个独立的CompletableFuture，不关心两个CompletableFuture的计算结果，当两个CompletableFuture执行完成后，执行Runnable。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>一个例子如下，5000毫秒后控制台输出”hello world”：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">     &#125;).runAfterBothAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"s2"</span>;</span><br><span class="line">     &#125;), () -&gt; System.out.println(<span class="string">"hello world"</span>));  <span class="comment">//() -&gt; System.out.println("hello world")；就是Runnable的Lambda实现</span></span><br></pre></td></tr></table></figure></p><h2>时间优先度执行</h2><p>CompletableFuture中有部分的API可以等待第一个完成的CompletableFuture再进行后续操作。当你有两个相同类型任务的结果时就显得非常方便，你只要关心响应时间就行了，没有哪个任务是优先的（这类型的方法的好处是只关注响应的时间，除了时间这个优先级限定，没有其他优先级）。</p><h3>时间优先转换–CompletableFuture.applyToEither()</h3><p><strong><em>CompletableFuture.applyToEither()</em></strong> 用于连接两个独立的CompletableFuture，选择计算（返回结果）最快的一个CompletableFuture，进行转换计算操作(Function&lt;? super T, U&gt;)并返回结果。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="keyword">super</span> T, U&gt; fn)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="keyword">super</span> T, U&gt; fn)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="keyword">super</span> T, U&gt; fn,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>我们现实开发场景中，总会碰到有两种渠道完成同一个事情，所以就可以调用这个方法，找一个最快的结果进行处理。一个例子如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">     &#125;).applyToEither(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">     &#125;), s -&gt; s).join();  <span class="comment">//2000毫秒后返回"hello world"</span></span><br></pre></td></tr></table></figure></p><h3>时间优先消费–CompletableFuture.acceptEither()</h3><p><strong><em>CompletableFuture.acceptEither()</em></strong> 用于连接两个独立的CompletableFuture，选择计算（返回结果）最快的一个CompletableFuture，进行消费操作(Consumer&lt;? super T&gt; action)，无返回值。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">acceptEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="keyword">super</span> T&gt; action,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>一个例子如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">     &#125;).acceptEither(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">     &#125;), System.out::println); <span class="comment">//2000毫秒后控制台打印 "hello world"</span></span><br></pre></td></tr></table></figure></p><h3>时间优先执行–CompletableFuture.runAfterEither()</h3><p><strong><em>CompletableFuture.runAfterEither()</em></strong> 用于连接两个独立的CompletableFuture，不关心任何CompletableFuture的返回值，任何一个CompletableFuture执行完毕得到了结果后会马上执行Runable。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>一个例子如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">     &#125;).runAfterEither(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"s2"</span>;</span><br><span class="line">     &#125;), () -&gt; System.out.println(<span class="string">"hello world"</span>)); <span class="comment">//() -&gt; System.out.println("hello world")是Runable的Lambda实现。 2000毫秒后控制台打印 "hello world"</span></span><br></pre></td></tr></table></figure></p><h2>结果赋值</h2><p>CompletableFuture的完计算结果直接赋值方法主要有以下几个：</p><ul><li>boolean complete(T value)，通过CAS赋值计算结果，内部会发送完成状态，再次调用无效。</li><li>boolean completeExceptionally(Throwable ex)，通过CAS赋值计算异常，内部会发送完成状态，再次调用无效。</li><li>void obtrudeValue(T value)，直接赋值计算结果，内部会发送完成状态，再次调用无效。</li><li>obtrudeException(Throwable ex)，直接赋值计算异常，内部会发送完成状态，再次调用无效。</li></ul><p>只要上面四个方法之一被调用，CompletableFuture就会标记为’完结状态’，再次调用其他方法将不会起效，另外，obtrudeXXX方法属于强制赋值，不建议使用，因为它们会直接覆盖当前的值。</p><p>一个例子如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            future.complete(<span class="string">"test success"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            future.completeExceptionally(e);</span><br><span class="line">        &#125;</span><br><span class="line">System.out.println(future.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 test success</span></span><br></pre></td></tr></table></figure></p><h2>结果获取</h2><ul><li><strong><em>T get() throws InterruptedException, ExecutionException</em></strong> ，永久阻塞，直到返回结果值，允许中断，计算过程中所有的异常会包裹为新的ExecutionException实例再抛出。</li><li><strong><em>T get(long timeout, TimeUnit unit)throws InterruptedException, ExecutionException, TimeoutException</em></strong> ，添加超时时间设定，如果超时会抛出TimeoutException，如果获取到结果则释放并返回，允许中断，计算过程中所有的异常会包裹为新的ExecutionException实例再抛出。</li><li><strong><em>T join()</em></strong> ，永久阻塞，直到返回结果值，不允许中断，计算过程中所有的异常会直接抛出。</li><li><strong><em>T getNow(T valueIfAbsent)</em></strong> ，如果当前的计算结果为null，马上返回valueIfAbsent，否则调用join()的逻辑。结果的获取不做举例，因为这个实在太常用，强烈建议使用T get(long timeout, TimeUnit unit)，其他三个方法看场景选择使用。</li></ul><h2>其它</h2><h3>取消–cancel()</h3><p>调用CompletableFuture实例的 <strong><em>cancel()</em></strong> 方法可以取消当前的CompletableFuture，此时该CompletableFuture实例会进入’完结状态’，其结果会传入一个新的CancellationException实例，此时通过上一节的’结果获取’中的Api调用就会按各自的处理模式抛出异常。</p><h3>所有完成</h3><p>调用CompletableFuture的静态方法 <strong><em>CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)</em></strong> ，当所有的传入的CompletableFuture实例都完成的时候，会返回一个新建的CompletableFuture，也就是程序将会阻塞在此方法调用，直到所有传入CompletableFuture都完成，这个时候返回值CompletableFuture实例也完成。举个例子：<strong><em>CompletableFuture.allOf(cf1,cf2).join()</em></strong> ;，其中cf1、cf2是两个独立的CompletableFuture实例。如果你的程序有这么一段代码，那么执行的时候会阻塞在此，直到cf1和cf2都完成了，才会释放。</p><h3>任一完成</h3><p>调用CompletableFuture的静态方法 <strong><em>CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs)</em></strong>， 这个方法和上面的’所有完成’是相对的。当所有的传入的CompletableFuture实例中只要有一个实例完成的时候，会返回一个新建的CompletableFuture，也就是程序将会阻塞在此方法调用，直到有一个传入的CompletableFuture完成，这个时候返回值CompletableFuture实例也完成。举个例子： <strong><em>CompletableFuture.anyOf(cf1,cf2).join();</em></strong> ，其中cf1、cf2是两个独立的CompletableFuture实例。如果你的程序有这么一段代码，那么执行的时候会阻塞在此，直到cf1或cf2其中一个完成了，才会释放。</p><h1>四、实战例子</h1><p>个人认为，CompletableFuture使用在API网关做接口的聚合是什么有优势的(不知道为什么身边很少人使用这个神器)。现在假设有一个API网关，在调用查询用户某个订单详情的时候，需要分别从订单服务的订单信息接口、用户服务的用户信息接口两个接口拉取数据，一般来说，低效的伪代码大概如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这两个参数从外部获得</span></span><br><span class="line">Long userId = <span class="number">10006L</span>;</span><br><span class="line">String orderId = <span class="string">"XXXXXXXXXXXXXXXXXXXXXX"</span>;</span><br><span class="line"><span class="comment">//从用户服务获取用户信息</span></span><br><span class="line">UserInfo userInfo = userService.getUserInfo(userId);</span><br><span class="line"><span class="comment">//从用订单务获取订单信息</span></span><br><span class="line">OrderInfo orderInfo = orderService.getOrderInfo(orderId);</span><br><span class="line"><span class="comment">//返回两者的聚合DTO</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OrderDetailDTO(userInfo,orderInfo);</span><br></pre></td></tr></table></figure></p><p>其实如果微服务设计得足够好，下面三个外部接口的信息一定是不相关联的，也就是可以并行获取，三个接口的结果都获取完毕之后做一次数据聚合到DTO即可，也就是聚合的耗时大致是这三个接口中耗时最长的接口的响应时间。修改后的代码如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDetailService</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建立一个线程池专门交给CompletableFuture使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">20</span>, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>));</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> OrderService orderService;</span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderDetailDTO <span class="title">getOrderDetail</span><span class="params">(Long userId, String orderId)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">CompletableFuture&lt;UserInfo&gt; userInfoCompletableFuture = CompletableFuture.supplyAsync(() -&gt; userService.getUserInfo(userId), executor);</span><br><span class="line">CompletableFuture&lt;OrderInfo&gt; orderInfoCompletableFuture = CompletableFuture.supplyAsync(() -&gt; orderService.getOrderInfo(orderId), executor);</span><br><span class="line">CompletableFuture&lt;OrderDetailDTO&gt; result</span><br><span class="line">= userInfoCompletableFuture.thenCombineAsync(orderInfoCompletableFuture, OrderDetailDTO::<span class="keyword">new</span>, executor);</span><br><span class="line"><span class="keyword">return</span> result.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码还没有考虑到外部的微服务异常的情况，但是相对串行的拉取外部信息的接口的操作方式，这种并行的方式显然是更加高效的，而且CompletableFuture的supplyAsync方法可以传入Supplier接口实例，也就是允许任何参数类型的表达式，这点是什么方便的。当然，其实用ExecutorService的invokeAll方法也可以达到相同的效果.</p><p><a href="http://www.importnew.com/10815.html" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netty入门浅析(2)</title>
      <link href="/2018/07/25/Netty%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90(2)/"/>
      <url>/2018/07/25/Netty%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90(2)/</url>
      <content type="html"><![CDATA[<h1>简介</h1><p>在上一章中我们认识了netty，他有三大优点：并发高，传输快，封装好。在这一章我们来用Netty搭建一个HttpServer，从实际开发中了解netty框架的一些特性和概念。</p><h1>认识Http请求</h1><p>在动手写Netty框架之前，我们先要了解http请求的组成，如下图：</p><p><img src="/2018/07/25/Netty入门浅析(2)/1.jpg" title="图片"></p><ol><li>HTTP Request 第一部分是包含的头信息</li><li>HttpContent 里面包含的是数据，可以后续有多个 HttpContent 部分</li><li>LastHttpContent 标记是 HTTP request 的结束，同时可能包含头的尾部信息</li><li>完整的 HTTP request，由1，2，3组成</li></ol><p><img src="/2018/07/25/Netty入门浅析(2)/2.jpg" title="图片"></p><ol><li>HTTP response 第一部分是包含的头信息</li><li>HttpContent 里面包含的是数据，可以后续有多个 HttpContent 部分</li><li>LastHttpContent 标记是 HTTP response 的结束，同时可能包含头的尾部信息</li><li>完整的 HTTP response，由1，2，3组成</li></ol><p>从request的介绍我们可以看出来，一次http请求并不是通过一次对话完成的，他中间可能有很次的连接。通过上一章我们队netty的了解，每一次对话都会建立一个channel，并且一个ChannelInboundHandler一般是不会同时去处理多个Channel的。如何在一个Channel里面处理一次完整的Http请求？这就要用到我们上图提到的FullHttpRequest，我们只需要在使用netty处理channel的时候，只处理消息是FullHttpRequest的Channel，这样我们就能在一个ChannelHandler中处理一个完整的Http请求了。</p><h1>编写代码</h1><p>搭建一个Netty服务器，我们只需要两个类——一个是启动类，负责启动（BootStrap）和main方法，一个是ChannelHandler，负责具体的业务逻辑，我们先从启动类说起。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpRequestDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpResponseEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by RoyDeng on 17/7/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">            System.err.println(</span><br><span class="line">                    <span class="string">"Usage: "</span> + HttpServer.class.getSimpleName() +</span><br><span class="line">                            <span class="string">" &lt;port&gt;"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">new</span> HttpServer(port).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        b.group(group)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span></span></span><br><span class="line"><span class="function">                            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"initChannel ch:"</span> + ch);</span><br><span class="line">                        ch.pipeline()</span><br><span class="line">                                .addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> HttpRequestDecoder())   <span class="comment">// 1</span></span><br><span class="line">                                .addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> HttpResponseEncoder())  <span class="comment">// 2</span></span><br><span class="line">                                .addLast(<span class="string">"aggregator"</span>, <span class="keyword">new</span> HttpObjectAggregator(<span class="number">512</span> * <span class="number">1024</span>))    <span class="comment">// 3</span></span><br><span class="line">                                .addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HttpHandler());        <span class="comment">// 4</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// determining the number of connections queued</span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">        b.bind(port).sync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个类同上一章中出现的Netty简易封装服务器代码类似，不一样的是这里使用了多个ChannelHandler，在这里一一介绍：</p><ol><li>HttpRequestDecoder，用于解码request</li><li>HttpResponseEncoder，用于编码response</li><li><strong>aggregator</strong>，消息聚合器（重要）。为什么能有FullHttpRequest这个东西，就是因为有他，HttpObjectAggregator，如果没有他，就不会有那个消息是FullHttpRequest的那段Channel，同样也不会有FullHttpResponse。如果我们将z'h</li><li>HttpObjectAggregator(512 * 1024)的参数含义是消息合并的数据大小，如此代表聚合的消息内容长度不超过512kb。添加我们自己的处理接口</li></ol><p>完成启动类之后，接下来就是我们的业务处理类HttpHandler了，先上代码：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.AsciiString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by RoyDeng on 17/7/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">FullHttpRequest</span>&gt; </span>&#123; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsciiString contentType = HttpHeaderValues.TEXT_PLAIN;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"class:"</span> + msg.getClass().getName());</span><br><span class="line">        DefaultFullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1,</span><br><span class="line">                HttpResponseStatus.OK,</span><br><span class="line">                Unpooled.wrappedBuffer(<span class="string">"test"</span>.getBytes())); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        HttpHeaders heads = response.headers();</span><br><span class="line">        heads.add(HttpHeaderNames.CONTENT_TYPE, contentType + <span class="string">"; charset=UTF-8"</span>);</span><br><span class="line">        heads.add(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes()); <span class="comment">// 3</span></span><br><span class="line">        heads.add(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);</span><br><span class="line"></span><br><span class="line">        ctx.write(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channelReadComplete"</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelReadComplete(ctx);</span><br><span class="line">        ctx.flush(); <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"exceptionCaught"</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != cause) cause.printStackTrace();</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != ctx) ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该段代码需要注意的地方如注释所示，有以下四点：</p><ol><li>Handler需要声明泛型为&lt;FullHttpRequest&gt;，声明之后，只有msg为FullHttpRequest的消息才能进来。由于泛型的过滤比较简单，我们就不改代码来验证了，但是在这里我们可以利用泛型的特性另外做个小测试，将泛型去掉，并且将HttpServer中</li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.addLast(<span class="string">"aggregator"</span>, <span class="keyword">new</span> HttpObjectAggregator(<span class="number">512</span> * <span class="number">1024</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>这一行代码注释掉，然后观察注释前后的log。</p><p>注释前:</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initChannel ch:[id: 0xcb9d8e9e, L:/0:0:0:0:0:0:0:1:8888 - R:/0:0:0:0:0:0:0:1:58855]</span><br><span class="line">class:io.netty.handler.codec.http.HttpObjectAggregator$AggregatedFullHttpRequest</span><br><span class="line">channelReadComplete</span><br></pre></td></tr></table></figure></p><p>注释后:</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initChannel ch:[id: 0xc5415409, L:/0:0:0:0:0:0:0:1:8888 - R:/0:0:0:0:0:0:0:1:58567]</span><br><span class="line">class:io.netty.handler.codec.http.DefaultHttpRequest</span><br><span class="line">class:io.netty.handler.codec.http.LastHttpContent$1</span><br><span class="line">channelReadComplete</span><br><span class="line">channelReadComplete</span><br></pre></td></tr></table></figure></p><p>从中可以看出，如果没有aggregator，那么一个http请求就会通过多个Channel被处理，这对我们的业务开发是不方便的，而aggregator的作用就在于此。</p><ol start="2"><li>生成response，这里使用的FullHttpResponse，同FullHttpRequest类似，通过这个我们就不用将response拆分成多个channel返回给请求端了。</li><li>添加header描述length。这一步是很重要的一步，如果没有这一步，你会发现用postman发出请求之后就一直在刷新，因为http请求方不知道返回的数据到底有多长。</li><li>channel读取完成之后需要输出缓冲流。如果没有这一步，你会发现postman同样会一直在刷新</li></ol>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Netty </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netty入门浅析(1)</title>
      <link href="/2018/07/25/Netty%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90(1)/"/>
      <url>/2018/07/25/Netty%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90(1)/</url>
      <content type="html"><![CDATA[<h1>Netty的简单介绍</h1><p>Netty 是一个 NIO client-server(客户端服务器)框架，使用 Netty 可以快速开发网络应用，例如服务器和客户 端协议。 Netty 提供了一种新的方式来使开发网络应用程序，这种新的方式使得它很容易使用和有很强的扩展性。 Netty 的内部实现时很复杂的，但是 Netty 提供了简单易用的 api 从网络处理代码中解耦业务逻辑。 Netty 是完全基 于 NIO 实现的，所以整个 Netty 都是异步的。 简单点说就是Netty提供了一个简单，间接的方法来操作网络之间的通讯。</p><h1>使用 Netty 能够做什么</h1><ul><li>开发异步、非阻塞的 TCP 网络应用程序；</li><li>开发异步、非阻塞的 UDP 网络应用程序；</li><li>开发异步文件传输应用程序；</li><li>开发异步 HTTP 服务端和客户端应用程序；</li><li>提供对多种编解码框架的集成，包括谷歌的 Protobuf、Jbossmarshalling、Java 序列化、压缩编解码、XML 解码、字符串编解码等，这些编解码框架可以被用户直接使用；提供形式多样的编解码基础类库，可以非常方便的实现私有协议栈编解码框架的二次定制和开发；</li><li>基于职责链模式的 Pipeline-Handler 机制，用户可以非常方便的对网络事件进行拦截和定制；所有的 IO 操作都是异步的，用户可以通过 Future-Listener 机制主动 Get 结果或者由 IO 线程操作完成之后主动 Notify 结果，用户的业务线程不需要同步等待；</li><li>IP 黑白名单控制；</li><li>打印消息码流；流量控制和整形；</li><li>性能统计；基于链路空闲事件检测的心跳检测</li><li>……</li></ul><h1>Netty得到的应用</h1><ul><li>阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信。</li><li>淘宝的消息中间件 RocketMQ 的消息生产者和消息消费者之间，也采用 Netty 进行高性能、异步通信。</li></ul><h1>Netty Reactor模式</h1><p>Netty是典型的Reactor模型结构。Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，Boss线程池和Work线程池，其中Boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给Work线程池，其中Work线程池负责请求的read和write事件。<strong>流程图：</strong></p><p><img src="/2018/07/25/Netty入门浅析(1)/1.png" title="图片"></p><h1>Netty核心组件</h1><h2>Channel</h2><p>这里的Channel与Java的Channel不是同一个，是netty自己定义的通道；Netty的Channel是对网络连接处理的抽象，负责与网络进行通讯，支持NIO和OIO两种方式；内部与网络socket连接，通过channel能够进行I/O操作，如读、写、连接和绑定。通过Channel可以执行具体的I/O操作，如read, write, connect, 和bind。在Netty中，所有I/O操作都是异步的；Netty的服务器端处理客户端连接的Channel创建时可以设置父Channel。例如：ServerSocketChannel接收到请求创建SocketChannel，SocketChannel的父为ServerSocketChannel。</p><h2>ChannelHandler与ChannelPipeline</h2><p>ChannelHandler是通道处理器，用来处理I/O事件或拦截I/O操作，ChannelPipeline字如其名，是一个双向流水线，内部维护了多个ChannelHandler，服务器端收到I/O事件后，每次顺着ChannelPipeline依次调用ChannelHandler的相关方法。ChannelHandler是个接口，通常我们在Netty中需要使用下面的子类：</p><ul><li>ChannelInboundHandler 用来处理输入的I/O事件</li><li>ChannelOutboundHandler 用来处理输出的I/O事件</li></ul><p>另外，下面的adapter类提供了:</p><ul><li>ChannelInboundHandlerAdapter 用来处理输入的I/O事件</li><li>ChannelOutboundHandlerAdapter 用来处理输出的I/O事件</li><li>ChannelDuplexHandler 可以用来处理输入和输出的I/O事件</li></ul><p>Netty的ChannelPipeline和ChannelHandler机制类似于Servlet和Filter过滤器/拦截器，每次收到请求会依次调用配置好的拦截器链。Netty服务器收到消息后，将消息在ChannelPipeline中流动和传递，途经的ChannelHandler会对消息进行处理，ChannelHandler分为两种inbound和outbound，服务器read过程中只会调用inbound的方法，write时只寻找链中的outbound的Handler。ChannelPipeline内部维护了一个双向链表，Head和Tail分别代表表头和表尾，Head作为总入口和总出口，负责底层的网络读写操作；用户自己定义的ChannelHandler会被添加到链表中，这样就可以对I/O事件进行拦截和处理；这样的好处在于用户可以方便的通过新增和删除链表中的ChannelHandler来实现不同的业务逻辑，不需要对已有的ChannelHandler进行修改</p><p><img src="/2018/07/25/Netty入门浅析(1)/2.png" title="图片"></p><p>如图所示，在服务器初始化后，ServerSocketChannel的会创建一个Pipeline，内部维护了ChannelHanlder的双向链表，读取数据时，会依次调用ChannelInboundHandler子类的channelRead()方法，例如：读取到客户端数据后，依次调用解码-业务逻辑-直到Tail。而写入数据时，会从用户自定义的ChannelHandler出发查找ChannelOutboundHandler的子类，调用channelWrite()，最终由Head的write()向socket写入数据。例如：写入数据会通过业务逻辑的组装–编码–写入socket（Head的write）</p><h2>EventLoop与EventLoopGroup</h2><p>EventLoop是事件循环，EventLoopGroup是运行在线程池中的事件循环组，Netty使用了Reactor模型，服务器的连接和读写放在线程池之上的事件循环中执行，这是Netty获得高性能的原因之一。事件循环内部会打开selector，并将Channel注册到事件循环中，事件循环不断的进行select()查找准备就绪的描述符；此外，某些系统任务也会被提交到事件循环组中运行。</p><h2>ServerBootstrap</h2><p>ServerBootstrap是辅助启动类，用于服务端的启动，内部维护了很多用于启动和建立连接的属性。包括：</p><ul><li>EventLoopGroup group 线程池组</li><li>channel是通道</li><li>channelFactory 通道工厂，用于创建channel</li><li>localAddress 本地地址</li><li>options 通道的选项，主要是TCP连接的属性</li><li>attrs 用来设置channel的属性，</li><li>handler 通道处理器</li></ul><h1>参考</h1><p><a href="http://blog.leanote.com/post/shawn_yan/Netty%E5%8E%9F%E7%90%86%E6%A6%82%E8%A7%88" target="_blank" rel="noopener">Netty原理浅析</a></p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Netty </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java实现乐观互斥Key锁</title>
      <link href="/2018/07/14/Java%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E4%BA%92%E6%96%A5Key%E9%94%81/"/>
      <url>/2018/07/14/Java%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E4%BA%92%E6%96%A5Key%E9%94%81/</url>
      <content type="html"><![CDATA[<h1>简介</h1><p>java中的几种锁：synchronized，ReentrantLock，ReentrantReadWriteLock已基本可以满足编程需求，但其粒度都太大，同一时刻只有一个线程能进入同步块，加锁后性能受到太大的影响。这对于某些高并发的场景并不适用。本文实现了一个基于KEY（主键）的互斥锁，具有更细的粒度，在缓存或其他基于KEY的场景中有很大的用处。下面将讲解这个锁的设计和实现</p><h1>分段锁</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hhbbz on 2018/7/13.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Explain</span>: key锁（要保证key的hashCode不变,否则无法释放锁。即加锁之后不要手动更改lockMap）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadKeyLock</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//默认分段数量</span></span><br><span class="line">    <span class="keyword">private</span> Integer segments = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, ReentrantLock&gt; lockMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadKeyLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadKeyLock</span><span class="params">(Integer counts, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        init(counts, fair);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Integer counts, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (counts != <span class="keyword">null</span>) &#123;</span><br><span class="line">            segments = counts;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments; i++) &#123;</span><br><span class="line">            lockMap.put(i, <span class="keyword">new</span> ReentrantLock(fair));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = lockMap.get(key.hashCode() % segments);</span><br><span class="line">        lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = lockMap.get(key.hashCode() % segments);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>哈希锁</h1><p>上述分段锁的基础上发展起来的第二种锁策略，目的是实现真正意义上的细粒度锁。每个哈希值不同的对象都能获得自己独立的锁。在测试中，在被锁住的代码执行速度飞快的情况下，效率比分段锁慢 30% 左右。如果有长耗时操作，感觉表现应该会更好。代码如下：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashLock</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isFair = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SegmentLock&lt;T&gt; segmentLock = <span class="keyword">new</span> SegmentLock&lt;&gt;();<span class="comment">//分段锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;T, LockInfo&gt; lockMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        isFair = fair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        LockInfo lockInfo;</span><br><span class="line">        segmentLock.lock(key);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lockInfo = lockMap.get(key);</span><br><span class="line">            <span class="keyword">if</span> (lockInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                lockInfo = <span class="keyword">new</span> LockInfo(isFair);</span><br><span class="line">                lockMap.put(key, lockInfo);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lockInfo.count.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            segmentLock.unlock(key);</span><br><span class="line">        &#125;</span><br><span class="line">        lockInfo.lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        LockInfo lockInfo = lockMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (lockInfo.count.get() == <span class="number">1</span>) &#123;</span><br><span class="line">            segmentLock.lock(key);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lockInfo.count.get() == <span class="number">1</span>) &#123;</span><br><span class="line">                    lockMap.remove(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                segmentLock.unlock(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lockInfo.count.decrementAndGet();</span><br><span class="line">        lockInfo.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LockInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> ReentrantLock lock;</span><br><span class="line">        <span class="keyword">public</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">LockInfo</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>弱引用锁</h1><p>哈希锁因为引入的分段锁来保证锁创建和销毁的同步，总感觉有点瑕疵，所以写了第三个锁来寻求更好的性能和更细粒度的锁。这个锁的思想是借助java的弱引用来创建锁，把锁的销毁交给jvm的垃圾回收，来避免额外的消耗。</p><p>有点遗憾的是因为使用了ConcurrentHashMap作为锁的容器，所以没能真正意义上的摆脱分段锁。这个锁的性能比 HashLock 快10% 左右。锁代码：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 弱引用锁，为每个独立的哈希值提供独立的锁功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashLock</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;T, WeakLockRef&lt;T, ReentrantLock&gt;&gt; lockMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReferenceQueue&lt;ReentrantLock&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReentrantLock <span class="title">get</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lockMap.size() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">            clearEmptyRef();</span><br><span class="line">        &#125;</span><br><span class="line">        WeakReference&lt;ReentrantLock&gt; lockRef = lockMap.get(key);</span><br><span class="line">        ReentrantLock lock = (lockRef == <span class="keyword">null</span> ? <span class="keyword">null</span> : lockRef.get());</span><br><span class="line">        <span class="keyword">while</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lockMap.putIfAbsent(key, <span class="keyword">new</span> WeakLockRef&lt;&gt;(<span class="keyword">new</span> ReentrantLock(), queue, key));</span><br><span class="line">            lockRef = lockMap.get(key);</span><br><span class="line">            lock = (lockRef == <span class="keyword">null</span> ? <span class="keyword">null</span> : lockRef.get());</span><br><span class="line">            <span class="keyword">if</span> (lock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> lock;</span><br><span class="line">            &#125;</span><br><span class="line">            clearEmptyRef();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearEmptyRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Reference&lt;? extends ReentrantLock&gt; ref;</span><br><span class="line">        <span class="keyword">while</span> ((ref = queue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            WeakLockRef&lt;T, ? extends ReentrantLock&gt; weakLockRef = (WeakLockRef&lt;T, ? extends ReentrantLock&gt;) ref;</span><br><span class="line">            lockMap.remove(weakLockRef.key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakLockRef</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">WeakLockRef</span><span class="params">(K referent, ReferenceQueue&lt;? <span class="keyword">super</span> K&gt; q, T key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(referent, q);</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>适合耗时长场景的互斥key锁</h1><p>一个细粒度的锁，在某些场景能比synchronized，ReentrantLock等获得更高的并行度更好的性能</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyLock</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 保存所有锁定的KEY及其信号量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;K, Semaphore&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;K, Semaphore&gt;();</span><br><span class="line">    <span class="comment">// 保存每个线程锁定的KEY及其锁定计数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;K, LockInfo&gt;&gt; local = <span class="keyword">new</span> ThreadLocal&lt;Map&lt;K, LockInfo&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Map&lt;K, LockInfo&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K, LockInfo&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁定key，其他等待此key的线程将进入等待，直到调用&#123;<span class="doctag">@link</span> #unlock(K)&#125;</span></span><br><span class="line"><span class="comment">     * 使用hashcode和equals来判断key是否相同，因此key必须实现&#123;<span class="doctag">@link</span> #hashCode()&#125;和</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #equals(Object)&#125;方法</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        LockInfo info = local.get().get(key);</span><br><span class="line">        <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Semaphore current = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">            current.acquireUninterruptibly();</span><br><span class="line">            Semaphore previous = map.put(key, current);</span><br><span class="line">            <span class="keyword">if</span> (previous != <span class="keyword">null</span>)</span><br><span class="line">                previous.acquireUninterruptibly();</span><br><span class="line">            local.get().put(key, <span class="keyword">new</span> LockInfo(current));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            info.lockCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放key，唤醒其他等待此key的线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        LockInfo info = local.get().get(key);</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span> &amp;&amp; --info.lockCount == <span class="number">0</span>) &#123;</span><br><span class="line">            info.current.release();</span><br><span class="line">            map.remove(key, info.current);</span><br><span class="line">            local.get().remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁定多个key</span></span><br><span class="line"><span class="comment">     * 建议在调用此方法前先对keys进行排序，使用相同的锁定顺序，防止死锁发生</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(K[] keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keys == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (K key : keys) &#123;</span><br><span class="line">            lock(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放多个key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(K[] keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keys == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (K key : keys) &#123;</span><br><span class="line">            unlock(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LockInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Semaphore current;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> lockCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">LockInfo</span><span class="params">(Semaphore current)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.current = current;</span><br><span class="line">            <span class="keyword">this</span>.lockCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Security（2）流程详解</title>
      <link href="/2018/07/07/Spring%20Security%EF%BC%882%EF%BC%89%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/07/07/Spring%20Security%EF%BC%882%EF%BC%89%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1>简介</h1><p>上章记录一点基础的配置，这次结合高级认证灵活使用Spring Security的用户认证。</p><h1>Spring Boot 添加 Spring Security</h1><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1>认证流程</h1><ol><li><p>用户使用用户名和密码登录</p></li><li><p>用户名密码被过滤器（默认为 UsernamePasswordAuthenticationFilter）获取到，配合其他权限信息（自定义），根据UsernamePasswordAuthenticationToken封装成一个未认证的Authentication（处在securityContext中）</p></li><li><p>Token（Authentication实现类）传递给 AuthenticationManager 进行认证。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.getAuthenticationManager().authenticate(token)</span><br></pre></td></tr></table></figure></p></li><li><p>AuthenticationManager管理一系列的AuthenticationProvider，AuthenticationManager会遍历全部AuthenticationProvider去对Authentication进行认证。</p></li><li><p>AuthenticationProvider会调用userDetailService去数据库中验证用户信息 ,返回一个userDetail对象（可自定义），认证成功后返回一个封装了用户权限信息的，以UsernamePasswordAuthenticationToken实现的带用户名和密码以及权限的Authentication 对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//appServer为权限信息</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> UsernamePasswordAuthenticationToken(userDetail,<span class="keyword">null</span>,appServer;</span><br></pre></td></tr></table></figure></p></li><li><p>已经进行认证的Authentication返回到UsernamePasswordAuthenticationFilter中，如果验证失败，则进入unsuccessfulAuthentication;如果验证成功，则进入successfulAuthentication进行生成token.</p></li></ol><h1>Filter</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AjaxLoginAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationProcessingFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthenticationSuccessHandler successHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthenticationFailureHandler failureHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AjaxLoginAuthenticationFilter</span><span class="params">(String defaultProcessUrl, AuthenticationSuccessHandler successHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">            AuthenticationFailureHandler failureHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successHandler = successHandler;</span><br><span class="line">        <span class="keyword">this</span>.failureHandler = failureHandler;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> AuthenticationException, IOException, ServletException </span>&#123;</span><br><span class="line">        AjaxLoginRequest loginRequest;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(secretLogin)&#123;</span><br><span class="line">                SecretFormRequest secretFormRequest = JSONObject.parseObject(request.getInputStream(),SecretFormRequest.class);</span><br><span class="line">                loginRequest = secretFormRequest.build();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                loginRequest = JSONObject.parseObject(request.getInputStream(),AjaxLoginRequest.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            logger.error(e.getMessage(),e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidLoginException(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(loginRequest.getUsername()) || StringUtils.isBlank(loginRequest.getPassword())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(<span class="string">"Username or Password not provided"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//权限标识，信息，用于做权限区分</span></span><br><span class="line">        AppServer appServer; </span><br><span class="line"></span><br><span class="line">        UsernamePasswordAuthenticationAppServerToken token = <span class="keyword">new</span> UsernamePasswordAuthenticationAppServerToken(loginRequest.getUsername(), loginRequest.getPassword(),appServer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">successfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain,</span></span></span><br><span class="line"><span class="function"><span class="params">            Authentication authResult)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">unsuccessfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">            AuthenticationException failed)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        SecurityContextHolder.clearContext();</span><br><span class="line">        failureHandler.onAuthenticationFailure(request, response, failed);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1>Token（Authentication实现类）</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户认证Token</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordAuthenticationAppServerToken</span> <span class="keyword">extends</span> <span class="title">UsernamePasswordAuthenticationToken</span> </span>&#123;</span><br><span class="line">    <span class="comment">//权限标识，信息，用于做权限区分</span></span><br><span class="line">    <span class="keyword">private</span> AppServer appServer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationAppServerToken</span><span class="params">(Object principal, Object credentials,AppServer appServer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(principal,credentials);</span><br><span class="line">        <span class="keyword">this</span>.appServer = appServer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationAppServerToken</span><span class="params">(Object principal, Object credentials)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(principal, credentials);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationAppServerToken</span><span class="params">(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(principal, credentials, authorities);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AppServer <span class="title">getAppServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> appServer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>AuthenticationProvider</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 权限验证对比用户名,密码比较是否相同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AjaxAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BCryptPasswordEncoder encoder;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsServiceImpl userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        Assert.notNull(authentication, <span class="string">"No authentication data provided"</span>);</span><br><span class="line"></span><br><span class="line">        String username = (String) authentication.getPrincipal();</span><br><span class="line">        String password = (String) authentication.getCredentials();</span><br><span class="line"></span><br><span class="line">        JwtUser jwtUser = <span class="keyword">null</span>;</span><br><span class="line">        AppServer appServer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jwtUser = (JwtUser) userService.loadUserByUsername(username);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"获取用户成功！"</span>,jwtUser.getUsername());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(authentication <span class="keyword">instanceof</span> UsernamePasswordAuthenticationAppServerToken)&#123;</span><br><span class="line"></span><br><span class="line">            UsernamePasswordAuthenticationAppServerToken authenticationAppServerToken = (UsernamePasswordAuthenticationAppServerToken) authentication;</span><br><span class="line">            appServer = authenticationAppServerToken.getAppServer();</span><br><span class="line">            jwtUser = userService.loadUserByUsernameInAppServer(username,appServer.getId(),<span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匹配密码</span></span><br><span class="line">        <span class="keyword">if</span> (!encoder.matches(password, jwtUser.getPassword())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="string">"Authentication Failed. Username or Password not valid."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        UsernamePasswordAuthenticationAppServerToken authenticationAppServerToken = <span class="keyword">new</span> UsernamePasswordAuthenticationAppServerToken(jwtUser,<span class="keyword">null</span>,appServer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> authenticationAppServerToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>UserDetailService</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span>, <span class="title">IService</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        User user = userRepository.findByUserName(username);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(String.format(<span class="string">"No user found with username '%s'."</span>, username));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> JwtUserFactory.create(user,<span class="number">0L</span>,<span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>UserDetail</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUser</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> AppServer appServer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>SuccessHandler</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AjaxAwareAuthenticationSuccessHandler</span> <span class="keyword">implements</span> <span class="title">AuthenticationSuccessHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        JwtUser userDetails = (JwtUser) authentication.getPrincipal();</span><br><span class="line">        </span><br><span class="line">        AppServer appServer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (authentication <span class="keyword">instanceof</span> UsernamePasswordAuthenticationAppServerToken) &#123;</span><br><span class="line">            appServer = ((UsernamePasswordAuthenticationAppServerToken) authentication).getAppServer();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成token</span></span><br><span class="line">        JwtToken accessToken = jwtTokenUtil.generateToken(userDetails,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        userCacheManager.cache(accessToken.getToken(),userDetails);</span><br><span class="line">        <span class="keyword">if</span>(userDetails.getLastPasswordResetType() != <span class="keyword">null</span> &amp;&amp; userDetails.getLastPasswordResetType()==<span class="number">0</span> </span><br><span class="line">            &amp;&amp; userDetails.getLastPasswordResetDate() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            userService.updateUserResetDate(<span class="keyword">new</span> Date(), userDetails.getId());  </span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//用于是否需要重置密码判断</span></span><br><span class="line">        accessToken.setLastPasswordResetType(userDetails.getLastPasswordResetType());</span><br><span class="line"></span><br><span class="line">        response.setStatus(HttpStatus.OK.value());</span><br><span class="line">        response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        JSONObject.writeJSONString(response.getWriter(), accessToken);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Security（1）配置说明</title>
      <link href="/2018/07/06/Spring-Security%EF%BC%881%EF%BC%89%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
      <url>/2018/07/06/Spring-Security%EF%BC%881%EF%BC%89%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<h1>Spring Security 模块</h1><ul><li><p><strong>核心模块</strong> - spring-security-core.jar：包含核心验证和访问控制类和接口，远程支 持的基本配置API，是基本模块</p></li><li><p><strong>远程调用</strong> - spring-security-remoting.jar：提供与 Spring Remoting 集成</p></li><li><p><strong>网页</strong> - spring-security-web.jar：包括网站安全的模块，提供网站认证服务和基于URL访问控制</p></li><li><p><strong>配置</strong> - spring-security-config.jar：包含安全命令空间解析代码，若使用XML进行配置则需要</p></li><li><p><strong>LDAP</strong> - spring-security-ldap.jar：LDAP 验证和配置，若需要LDAP验证和管理LDAP用户实体</p></li><li><p><strong>ACL访问控制表</strong> - spring-security-acl.jar：ACL专门领域对象的实现</p></li><li><p><strong>CAS</strong> - spring-security-cas.jar：CAS客户端继承，若想用CAS的SSO服务器网页验证</p></li><li><p><strong>OpenID</strong> - spring-security-openid.jar：OpenID网页验证支持</p></li><li><p><strong>Test</strong> - spring-security-test.jar：支持Spring Security的测试</p></li></ul><h1>默认执行顺序</h1><h2>UsernamePasswordAuthenticationFilter</h2><ol><li>用户通过url：/login 登录，该过滤器接收表单用户名密码</li><li>判断用户名密码是否为空</li><li>生成 UsernamePasswordAuthenticationToken</li><li>将Authentiction 传给 AuthenticationManager接口的 authenticate 方法进行认证处理</li><li>AuthenticationManager 默认是实现类为 ProviderManager ，ProviderManager 委托给 AuthenticationProvider 进行处理</li><li>UsernamePasswordAuthenticationFilter 继承了 AbstractAuthenticationProcessingFilter 抽象类，AbstractAuthenticationProcessingFilter 在 successfulAuthentication 方法中对登录成功进行了处理，通过 SecurityContextHolder.getContext().setAuthentication() 方法将 Authentication 认证信息对象绑定到 SecurityContext</li><li>下次请求时，在过滤器链头的 SecurityContextPersistenceFilter 会从 Session 中取出用户信息并生成 Authentication（默认为 UsernamePasswordAuthenticationToken），并通过 SecurityContextHolder.getContext().setAuthentication() 方法将 Authentication 认证信息对象绑定到 SecurityContext</li><li>需要权限才能访问的请求会从 SecurityContext 中获取用户的权限进行验证DaoAuthenticationProvider （实现了 AuthenticationProvider）：通过 UserDetailsService 获取 UserDetails将 UserDetails 和 UsernamePasswordAuthentionToken 进行认证匹配用户名密码是否正确若正确则通过 UserDetails 中用户的权限、用户名等信息生成一个新的 Authentication 认证对象并返回</li></ol><h2>DaoAuthenticationProvider （实现了 AuthenticationProvider）</h2><ol><li>通过 UserDetailsService 获取 UserDetails</li><li>将 UserDetails 和 UsernamePasswordAuthentionToken 进行认证匹配用户名密码是否正确</li><li>若正确则通过 UserDetails 中用户的权限、用户名等信息生成一个新的 Authentication 认证对象并返回</li></ol><h1>相关类</h1><h2>WebSecurityConfigurerAdapter</h2><ul><li>为创建 WebSecurityConfigurer 实例提供方便的基类，重写它的 configure 方法来设置安全细节<ul><li>configure(HttpSecurity http)：重写该方法，通过 http 对象的 authorizeRequests()方法定义URL访问权限，默认会为 formLogin() 提供一个简单的测试HTML页面</li><li>_configureGlobal(AuthenticationManagerBuilder auth) _：通过 auth 对象的方法添加身份验证</li></ul></li></ul><h2>SecurityContextHolder</h2><ul><li>SecurityContextHolder 用于存储安全上下文信息（如操作用户是谁、用户是否被认证、用户权限有哪些），它用 ThreadLocal 来保存 SecurityContext，者意味着 Spring Security 在用户登录时自动绑定到当前现场，用户退出时，自动清除当前线程认证信息，SecurityContext 中含有正在访问系统用户的详细信息</li></ul><h2>AuthenticationManagerBuilder</h2><ul><li>用于构建认证 AuthenticationManager 认证，允许快速构建内存认证、LDAP身份认证、JDBC身份验证，添加 userDetailsService（获取认证信息数据） 和 AuthenticationProvider's（定义认证方式）</li><li>内存验证：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      auth.inMemoryAuthentication()</span><br><span class="line">            .withUser(<span class="string">"user"</span>).password(<span class="string">"123"</span>).roles(<span class="string">"USER"</span>).and()</span><br><span class="line">            .withUser(<span class="string">"admin"</span>).password(<span class="string">"456"</span>).roles(<span class="string">"USER"</span>,<span class="string">"ADMIN"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>JDBC 验证：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.jdbcAuthentication()</span><br><span class="line">            .dataSource(dataSource)</span><br><span class="line">            .withDefaultSchema()</span><br><span class="line">            .withUser(<span class="string">"linyuan"</span>).password(<span class="string">"123"</span>).roles(<span class="string">"USER"</span>).and()</span><br><span class="line">            .withUser(<span class="string">"linyuan2"</span>).password(<span class="string">"456"</span>).roles(<span class="string">"ADMIN"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>userDetailsService(T userDetailsService)：传入自定义的 UserDetailsService 获取认证信息数据</li><li>authenticationProvider(AuthenticationProvider authenticationProvider) ：传入自定义认证过程</li></ul><h2>UserDetailsService</h2><ul><li>该接口仅有一个方法 loadUserByUsername，Spring Security 通过该方法获取.可自定义。</li></ul><h2>UserDetails</h2><ul><li>我们可以实现该接口来定义自己认证用户的获取方式（如数据库中获取），认证成功后会将 UserDetails 赋给 Authentication 的 principal 属性，然后再把 Authentication 保存到 SecurityContext 中，之后需要实用用户信息时通过 SecurityContextHolder 获取存放在 SecurityContext 中的 Authentication 的 principal。</li></ul><h2>Authentication</h2><ul><li>Authentication 是一个接口，用来表示用户认证信息，在用户登录认证之前相关信息（用户传过来的用户名密码）会封装为一个 Authentication 具体实现类对象，默认情况下为 UsernamePasswordAuthenticationToken，登录之后（通过AuthenticationManager认证）会生成一个更详细的、包含权限的对象，然后把它保存在权限线程本地的 SecurityContext 中，供后续权限鉴定用</li></ul><h2>GrantedAuthority</h2><ul><li>GrantedAuthority 是一个接口，它定义了一个 getAuthorities() 方法返回当前 Authentication 对象的拥有权限字符串，用户有权限是一个 GrantedAuthority 数组，每一个 GrantedAuthority 对象代表一种用户</li><li>通常搭配 SimpleGrantedAuthority 类使用</li></ul><h2>AuthenticationManager</h2><ul><li>AuthenticationManager 是用来处理认证请求的接口，它只有一个方法 authenticate()，该方法接收一个 Authentication 作为对象，如果认证成功则返回一个封装了当前用户权限信息的 Authentication 对象进行返回</li><li>它默认的实现是 ProviderManager，但它不处理认证请求，而是将委托给 AuthenticationProvider 列表，然后依次使用 AuthenticationProvider 进行认证，如果有一个 AuthenticationProvider 认证的结果不为null，则表示成功（否则失败，抛出 ProviderNotFoundException），之后不在进行其它 AuthenticationProvider 认证，并作为结果保存在 ProviderManager</li><li>认证校验时最常用的方式就是通过用户名加载 UserDetails，然后比较 UserDetails 密码与请求认证是否一致，一致则通过，Security 内部的 DaoAuthenticationProvider 就是实用这种方式</li><li>认证成功后加载 UserDetails 来封装要返回的 Authentication 对象，加载的 UserDetails 对象是包含用户权限等信息的。认证成功返回的 Authentication 对象将会保存在当前的 SecurityContext 中</li></ul><h2>AuthenticationProvide</h2><ul><li><p>AuthenticationProvider 是一个身份认证接口，实现该接口来定制自己的认证方式，可通过 UserDetailsSevice 对获取数据库中的数据</p></li><li><p>该接口中有两个需要实现的方法：</p><ul><li>Authentication authenticate(Authentication authentication)：认证处理，返回一个 Authentication 的实现类则代表成功，返回 null 则为认证失败</li><li>supports(Class&lt;?&gt; aClass)：如果该 AuthenticationProvider 支持传入的 Authentication 认证对象，则返回 true ，如：return aClass.equals(UsernamePasswordAuthenticationToken.class);</li></ul></li></ul><h2>AuthorityUtils</h2><ul><li>是一个工具包，用于操作 GrantedAuthority 集合的实用方法：<ul><li>commaSeparatedStringToAuthorityList(String authorityString)：从逗号分隔符中创建 GrantedAuthority 对象数组</li></ul></li></ul><h2>AbstractAuthenticationProcessingFilter</h2><ul><li>该抽象类继承了 GenericFilterBean，是处理 form 登录的过滤器，与 form 登录相关的所有操作都在该抽象类的子类中进行（UsernamePasswordAuthenticationFilter 为其子类），比如获取表单中的用户名、密码，然后进行认证等操作</li><li>该类在 doFilter 方法中通过 attemptAuthentication() 方法进行用户信息逻辑认证，认证成功会将用户信息设置到 Session 中</li></ul><h2>UserDetails</h2><ul><li>代表了Spring Security的用户实体类，带有用户名、密码、权限特性等性质，可以自己实现该接口，供 Spring Security 安全认证使用，Spring Security 默认使用的是内置的 User 类</li><li>将从数据库获取的 User 对象传入实现该接口的类，并获取 User 对象的值来让类实现该接口的方法</li><li>通过 Authentication.getPrincipal() 的返回类型是 Object，但很多情况下其返回的其实是一个 UserDetails 的实例</li></ul><h2>HttpSecurity</h2><ul><li>用于配置全局 Http 请求的权限控制规则，对哪些请求进行验证、不验证等</li><li>常用方法：</li><li>authorizeRequests()：返回一个配置对象用于配置请求的访问限制</li><li>formLogin()：返回表单配置对象，当什么都不指定时会提供一个默认的，如配置登录请求，还有登录成功页面</li><li>logout()：返回登出配置对象，可通过logoutUrl设置退出url</li><li>antMatchers：匹配请求路径或请求动作类型，如：.antMatchers(&quot;/admin/**&quot;)</li><li>addFilterBefore: 在某过滤器之前添加 filter</li><li>addFilterAfter：在某过滤器之后添加 filter</li><li>addFilterAt：在某过滤器相同位置添加 filter，不会覆盖相同位置的 filter</li><li>hasRole：结合 antMatchers 一起使用，设置请求允许访问的角色权限或IP，如：</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.antMatchers(<span class="string">"/admin/**"</span>).hasAnyRole(<span class="string">"ROLE_ADMIN"</span>,<span class="string">"ROLE_USER"</span>)</span><br></pre></td></tr></table></figure></p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">access(String)</td><td style="text-align:left">SpringEL表达式结果为true时可访问</td></tr><tr><td style="text-align:left">anonymous()</td><td style="text-align:left">匿名可访问</td></tr><tr><td style="text-align:left">denyAll()</td><td style="text-align:left">用户不可以访问</td></tr><tr><td style="text-align:left">fullyAuthenticated()</td><td style="text-align:left">用户完全认证访问（非remember me下自动登录）</td></tr><tr><td style="text-align:left">hasAnyAuthority(String…)</td><td style="text-align:left">参数中任意权限可访问</td></tr><tr><td style="text-align:left">hasAnyRole(String…)</td><td style="text-align:left">参数中任意角色可访问</td></tr><tr><td style="text-align:left">hasAuthority(String)</td><td style="text-align:left">某一权限的用户可访问</td></tr><tr><td style="text-align:left">hasRole(String)</td><td style="text-align:left">某一角色的用户可访问</td></tr><tr><td style="text-align:left">permitAll()</td><td style="text-align:left">所有用户可访问</td></tr><tr><td style="text-align:left">rememberMe()</td><td style="text-align:left">允许通过remember me登录的用户访问</td></tr><tr><td style="text-align:left">authenticated()</td><td style="text-align:left">用户登录后可访问</td></tr><tr><td style="text-align:left">hasIpAddress(String)</td><td style="text-align:left">用户来自参数中的IP可访问</td></tr></tbody></table><h2>注解与Spring EL</h2><ul><li><strong>@EnableWebSecurity</strong>：开启 Spring Security 注解</li><li><strong>@EnableGlobalMethodSecurity(prePostEnabled=true)</strong>：开启security方法注解</li><li><strong>@PreAuthorize</strong>：在方法调用前，通过SpringEL表达式限制方法访问</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('ROLE_ADMIN')"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果具有权限 ROLE_ADMIN 访问该方法</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>@PostAuthorize</strong>：允许方法调用，但时如果表达式结果为false抛出异常</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//returnObject可以获取返回对象user，判断user属性username是否和访问该方法的用户对象的用户名一样。不一样则抛出异常。</span></span><br><span class="line"><span class="meta">@PostAuthorize</span>(<span class="string">"returnObject.user.username==principal.username"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line">   <span class="comment">//允许进入</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>@PostFilter</strong>：允许方法调用，但必须按表达式过滤方法结果</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将结果过滤，即选出性别为男的用户</span></span><br><span class="line"><span class="meta">@PostFilter</span>(<span class="string">"returnObject.user.sex=='男' "</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//允许进入</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>@PreFilter</strong>：允许方法调用，但必须在进入方法前过滤输入值</li></ul><h2>Spring EL 表达式</h2><table><thead><tr><th style="text-align:left">表达式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">hasRole ([role])</td><td style="text-align:left">当前用户是否拥有指定角色</td></tr><tr><td style="text-align:left">hasAnyRole([role1,role2])</td><td style="text-align:left">多个角色是一个以逗号进行分隔的字符串。如果当前用户拥有指定角色中的任意一个则返回true</td></tr><tr><td style="text-align:left">hasAuthority ([auth])</td><td style="text-align:left">等同于hasRole</td></tr><tr><td style="text-align:left">hasAnyAuthority([auth1,auth2])</td><td style="text-align:left">等同于 hasAnyRole</td></tr><tr><td style="text-align:left">Principle</td><td style="text-align:left">代表当前用户的 principle对象</td></tr><tr><td style="text-align:left">authentication</td><td style="text-align:left">直接从 Security context获取的当前 Authentication对象</td></tr><tr><td style="text-align:left">permitAll</td><td style="text-align:left">总是返回true,表示允许所有的访问</td></tr><tr><td style="text-align:left">denyAll</td><td style="text-align:left">总是返回false,表示拒绝所有的访问访问</td></tr><tr><td style="text-align:left">isAnonymous()</td><td style="text-align:left">当前用户是否是一个匿名用户</td></tr><tr><td style="text-align:left">isRememberMe</td><td style="text-align:left">表示当前用户是否是通过remember - me自动登录的</td></tr><tr><td style="text-align:left">isAuthenticated()</td><td style="text-align:left">表示当前用户是否已经登录认证成功了</td></tr><tr><td style="text-align:left">isFullAuthenticated()</td><td style="text-align:left">如果当前用户既不是一个匿名用户,同时又不是通过Remember-Me自动登录的,则返回true</td></tr></tbody></table><h2>密码加密（PassWordEncoder）</h2><ul><li>Spring 提供的一个用于对密码加密的接口，首选实现类为 BCryptPasswordEncoder</li><li>通过@Bean注解将它注入到IOC容器：</li></ul><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>过滤器链</h2><h3>SecurityContextPersistenceFilter</h3><ul><li>过滤器链头，是从 SecurityContextRepository 中取出用户认证信息，默认实现为 HttpSessionSecurityContextRepository，它会从 Session 中取出已认证的用户信息，提高效率，避免每次请求都要查询用户认证信息</li><li>取出之后会放入 SecurityContextHolder 中，以便其它 filter 使用，SecurityContextHolder 使用 ThreadLocal 存储用户认证信息，保证线程之间信息隔离，最后再 finally 中清除该信息</li></ul><h3>WebAsyncManagerIntegrationFilter</h3><ul><li>提供了对 SecurityContext 和 WebAsyncManager 的集成，会把 SecurityContext 设置到异步线程，使其也能获取到用户上下文认证信息</li></ul><h3>HanderWriterFilter</h3><ul><li>会往请求的 Header 中添加相应的信息</li></ul><h3>CsrfFilter</h3><ul><li>跨域请求伪造过滤器，通过客户端穿来的 token 与服务端存储的 token 进行对比来判断请求</li></ul><h3>LogoutFilter</h3><ul><li>匹配URL，默认为 /logout，匹配成功后则会用户退出，清除认证信息，若有自己的退出逻辑，该过滤器可以关闭</li></ul><h3>UsernamePasswordAuthenticationFilter</h3><ul><li>登录认证过滤器，默认是对 /login 的 POST 请求进行认证，首先该方法会调用 attemptAuthentication 尝试认证获取一个 Authentication 认证对象，然后通过 sessionStrategy.onAuthentication 执行持久化，也就是保存认证信息，然后转向下一个 Filter，最后调用 successfulAuthentication 执行认证后事件</li><li>attemptAuthentication 该方法是认证的主要方法，认证基本流程为 UserDeatilService 根据用户名获取到用户信息，然后通过 UserDetailsChecker.check 对用户状态进行校验，最后通过 additionalAuthenticationChecks 方法对用户密码进行校验完后认证后，返回一个认证对象</li></ul><h3>DefaultLoginPageGeneratingFilter</h3><ul><li>当请求为登录请求时，生成简单的登录页面，可以关闭</li></ul><h3>BasicAuthenticationFilter</h3><ul><li>Http Basci 认证的支持，该认证会把用户名密码使用 base64 编码后放入 header 中传输，认证成功后会把用户信息放入 SecurityContextHolder 中</li></ul><h3>RequestCacheAwareFilter</h3><ul><li>恢复被打断时的请求</li></ul><h3>SecurityContextHolderAwareRequestFilter</h3><ul><li>针对 Servlet api 不同版本做一些包装</li></ul><h3>AnonymousAuthenticationFIlter</h3><ul><li>SecurityContextHolder 中认证信息为空，则会创建一个匿名用户到 SecurityContextHolder 中</li></ul><h3>SessionManagementFilter</h3><ul><li>与登录认证拦截时作用一样，持久化用户登录信息，可以保存到 Session 中，也可以保存到 cookie 或 redis 中</li></ul><h3>ExceptionTranslationFilter</h3><ul><li>异常拦截，处于 Filter 链条后部，只能拦截其后面的节点并着重处理 AuthenticationException 与 AccessDeniedException 异常</li></ul>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Docker容器部署ELK</title>
      <link href="/2018/07/03/%E4%BD%BF%E7%94%A8Docker%E5%AE%B9%E5%99%A8%E9%83%A8%E7%BD%B2ELK/"/>
      <url>/2018/07/03/%E4%BD%BF%E7%94%A8Docker%E5%AE%B9%E5%99%A8%E9%83%A8%E7%BD%B2ELK/</url>
      <content type="html"><![CDATA[<h1>选择镜像</h1><p>选择docker images(在hub.docker.com 搜索 elk 选择 start或pulls比较多的镜像) 本次安装选择的是 sebp/elk,默认本地已安装docker环境docker pull sebp/elk</p><ol><li><p>选择docker镜像登录 hub.docker.com 搜索 'elk', 选择stars 和 pulls 比较多的镜像</p></li><li><p>下载镜像docker pull sebp/elk</p></li></ol><h1>启动docker容器</h1><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --ulimit nofile=65536:65536 -p 5601:5601 -p 9200:9200 -p 5044:5044 -p 5045:5045 -p 5046:5046 -d --restart=always -v /etc/logstash:/etc/logstash -v /etc/localtime:/etc/localtime --name elk sebp/elk</span><br></pre></td></tr></table></figure></p><h2>参数介绍</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--ulimit  来修改容器的ulimit参数(该镜像默认的ulimit值为4096。 不带该参数，启动容器会出现类似 “max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]” 错误)</span><br><span class="line">    -p  指定容器和宿主机映射端口</span><br><span class="line">        5601：  kibana服务端口 HTTP  (web访问)</span><br><span class="line">        9200： Elasticsearch 开发端口 HTTP,保存数据到Elasticsearch中使用</span><br><span class="line">        5044： logstash  收集日志端口 TCP</span><br><span class="line">    -v  挂载目录 可以将logstash 的配置文件挂载在宿主机的目录上，方便随时修改，修改后的配置文件会同步到容器中。</span><br><span class="line">        挂载 /etc/localtime 该目录是为了保证容器和宿主机的时区相同。</span><br><span class="line">        通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。</span><br><span class="line">        现在镜像内就可以共享宿主机里的文件了。</span><br></pre></td></tr></table></figure></p><h1>配置logstash</h1><p>创建以下路径，并在其中创建logstash配置文件 /etc/logstash/conf.d/logstash.conf</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    beats &#123;</span><br><span class="line">        port =&gt; 5044</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;127.0.0.1:9200&quot;]</span><br><span class="line">        index =&gt; &quot;test&quot; ##对应es索引名</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改完配置文件后，执行如下命令来重启logstash<br>docker exec elk /etc/init.d/logstash restart</p><h1>客户端服务器</h1><ol><li>安装filebeat</li></ol><p>Debian/Ubuntu:</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-5.3.2-amd64.deb</span><br><span class="line">sudo dpkg -i filebeat-5.3.2-amd64.deb</span><br></pre></td></tr></table></figure></p><p>Redhat/Centos/Fedora:</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-5.3.2-x86_64.rpm</span><br><span class="line">sudo rpm -vi filebeat-5.3.2-x86_64.rpm</span><br></pre></td></tr></table></figure></p><ol start="2"><li>配置filebeat （默认文件路径 /etc/filebeat/filebeat.yml）</li></ol><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">filebeat.prospectors:</span></span><br><span class="line"><span class="attr">    - input_type:</span> <span class="string">log</span></span><br><span class="line"><span class="attr">document_type:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/data/logs/info.log</span></span><br><span class="line"><span class="string">output.logstash:</span></span><br><span class="line"><span class="attr">    hosts:</span> <span class="string">["18.18.18.18:5044"]</span></span><br></pre></td></tr></table></figure></p><p>paths 需要收集的日志文件路径<br>hosts: logstash 服务IP和端口</p><ol start="3"><li>测试配置文件语法是否正确</li></ol><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/filebeat.sh -configtest /etc/filebeat/filebeat.yml</span><br></pre></td></tr></table></figure></p><p>修改完成后，重启filebeat</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/filebeat restart</span><br></pre></td></tr></table></figure></p><h1>访问kibana页面</h1><ol><li>在已经安装filebeat的客户端服务器上，测试日志收集</li></ol><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 'nihao' &gt;&gt; /data/logs/info.log</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>在浏览器输入 18.18.18.18:5601（IP修改为ELK所在服务器的IP地址）创建 index pattern，选择刚才创建的“test“索引即可，可以在web上看到输入的测试日志。</p></li><li><p>在 http://localhost:9200/_search?pretty 可看到es中的全部索引数据。</p></li><li><p>在 http://localhost:9200/_cat/indices?v 可看到es中的全部索引。</p></li></ol>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式系统CAP定理及详解</title>
      <link href="/2018/07/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9FCAP%E5%AE%9A%E7%90%86%E5%8F%8A%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/07/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9FCAP%E5%AE%9A%E7%90%86%E5%8F%8A%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1>CAP定理简介</h1><p>C：Consistency，多台机器的数据一致性。</p><p>A：Availability，服务可用性，比如你用一个分布式事务从主同步数据到从，这时候服务不可用。</p><p>P：Partition-tolerance，分区容忍性，如果多台机器间，产生了分区，比如网络不通，服务是否可容忍。 等同于，【如果多台服务器有相同的数据，对于分区是可以容忍的】。</p><p>CA：单服务器。</p><p>CP：多服务器，数据强行同步，比如2PC，导致服务短时间不可用。</p><p>AP：多服务器，数据最终一致，比如异步消息，导致主挂了后，从可能没有完整数据。</p><p>Consistency其实就是数据库系统中提到的ACID的另一种表述：</p><ul><li><p>一个用户请求要么成功、要么失败，不能处于中间状态（Atomic）；</p></li><li><p>一旦一个事务完成，将来的所有事务都必须基于这个完成后的状态（Consistent）；</p></li><li><p>未完成的事务不会互相影响（Isolated）；</p></li><li><p>一旦一个事务完成，就是持久的（Durable）。</p></li></ul><p>对于Availability，其概念没有变化，指的是对于一个系统而言，所有的请求都应该‘成功’并且收到‘返回’。</p><p>对于Partition-tolerance，所指就是分布式系统的容错性。节点crash或者网络分片都不应该导致一个分布式系统停止服务。</p><h1>业界方案</h1><p>由于每台机器都可能挂，所以排除CA，即数据需要备多份，P必须满足。从上面可以看出，CP或者AP都有明显缺点，所以选择一个折衷的方案：2f+1台服务器，如果1是主，同步到f台备后就告诉请求方，已经成功。在可用性与一致性方面折衷。</p><p>如果备挂了，不用管，直到它自己恢复。</p><p>如果主挂了，用Raft等选举算法，选举出新的主。选举过程中，服务不可用，大概几百ms。</p><p><strong>即采取AP，保证分布式高可用，并通过弱一致性或最终一致性来同步数据。系统可以不同时达到CAP，而是分时达到。</strong></p><h1>CAP的证明</h1><p>CAP的证明很简单，假设两个节点集{G1, G2}，由于网络分片导致G1和G2之间所有的通讯都断开了，如果在G1中写，在G2中读刚写的数据， G2中返回的值不可能G1中的写值。由于A的要求，G2一定要返回这次读请求，由于P的存在，导致C一定是不可满足的。</p><h1>流行解释</h1><p>目前流行的、对CAP理论解释的情形是从同一数据在网络环境中存在多个副本出发为前提的。为了保证数据不会丢失，同时也是为了增加并发访问量（读写分离），在企业级的数据管理方案中，一般必须考虑数据的冗余存储问题，而这应该是通过在网络上的其他独立物理存储节点上保留另一份、或多份数据副本来实现的。因为在同一个存储节点上的数据冗余明显不能解决单点故障问题，这与通过多节点集群来提供更好的计算可用性的道理是相同的。</p><p>数据在节点A、B、C上保留了三份，如果对节点A上的数据进行了修改，然后再让客户端通过网络对该数据进行读取。那么，客户端的读取操作什么时候返回呢？</p><p>一种情况是要求节点A、B、C的三份数据完全一致后返回。也就是说，这时从任何一个网络节点读取的数据都是一样的，这就是所谓的强一致性读。很明显，这时数据读取的Latency要高一些（因为要等数据在网络中的复制），同时A、B、C三个节点中任何一个宕机，都会导致数据不可用。也就是说，要保证强一致性，网络中的副本越多，数据的可用性就越差。</p><p>另一种情况是，允许读操作立即返回，容忍B节点的读取与A节点的读取不一致的情况发生。这样一来，可用性显然得到了提高，网络中的副本也可以多一些，唯一得不到保证的是数据一致性。当然，对写操作同样也有多个节点一致性的情况，在此不再赘述。</p><p>可以看出，上述对CAP理论的解释主要是从网络上多个节点之间的读写一致性出发考虑问题的。而这一点，对于关系型数据库意味着什么呢？当然主要是指通常所说的Standby（关于分布式事务，涉及到更多考虑，随后讨论）情况。对此，在实践中我们大多已经采取了弱一致性的异步延时同步方案，以提高可用性。这种情况并不存在关系型数据库为保证C、A而放弃P的情况；而对海量数据管理的需求，关系型数据库扩展过程中所遇到的性能瓶颈，似乎也并不是CAP理论中所描述的那种原因造成的。那么，上述流行的说法中所描述的关系型数据库为保证C、A而牺牲P到底是在指什么呢？ 如果只将CAP当作分布式系统中多个数据副本之间的读写一致性问题的通用理论对待，那么就可以得出结论：CAP既适用于NoSQL数据库，也适用于关系型数据库。它是NoSQL数据库、关系型数据库，乃至一切分布式系统在设计数据多个副本之间读写一致性问题时需要遵循的共同原则。</p><h1>解决CAP</h1><p>根据一些专家的分析，CAP并不是一个严谨的定律，并不是牺牲了Consistency，就一定能同时获得Availability和Partition Tolerance。还有一个很重要的因素是Latency，在CAP中并没有体现。在现在NoSQL以及其他一些大规模设计时，A和P并不是牺牲C或部分牺牲C的借口，因为即使牺牲了C，也不一定A和P，并且C不一定必须要牺牲。</p><p>淘宝一天就处理了1亿零580万，而12306一天处理的交易仅仅166万条 ，如果从并发性上来说，淘宝的并发量远比12306大，但天猫的商品信息，促销数据都可以做缓存，做CDN，而12306的“商品”是一个个座位，这些座位必须通过后端数据库即时查询出来，状态的一致性要求很高。</p><p>从这点上看，12306的商品信息很难利用到缓存，因此12306查看“商品”的代价是比较大的，涉及到一系列的后端数据库操作，从这个角度讲，12306的复杂度是高于天猫的。 淘宝的商品相对独立，而12306商品之间的关联性很大，由于CAP定律限制，如果其商品的一致性要求过高，必然对可用性和分区容错性造成影响。</p><p>因此，业务设计上，如果找到一条降低一致性要求时，还能保证业务的正确性的业务分拆之路。举个例子，火车票查询时，不要显示多少张，而是显示“有”或“无”，或者显示&gt;100张，50~100,小于50等，这样就可以减小状态的更新频率，充分使用缓存数据。</p><p>CAP 理论说在一个系统中对某个数据不存在一个算法同时满足 Consistency, Availability, Partition-tolerance。注意，这里边最重要和最容易被人忽视的是限定词“对某个数据不存在一个算法”。这就是说在一个系统中，可以对某些数据做到 CP, 对另一些数据做到 AP，就算是对同一个数据，调用者可以指定不同的算法，某些算法可以做到 CP，某些算法可以做到 AP。</p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Cloud微服务初步架构设计</title>
      <link href="/2018/04/16/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%9D%E6%AD%A5%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/04/16/Spring-Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%9D%E6%AD%A5%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<h1>什么是微服务</h1><p>微服务的概念源于2014年3月Martin Fowler所写的一篇文章“Microservices”。</p><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</p><p>微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。</p><h1>微服务架构优势</h1><ul><li><p>复杂度可控：在将应用分解的同时，规避了原本复杂度无止境的积累。每一个微服务专注于单一功能，并通过定义良好的接口清晰表述服务边界。由于体积小、复杂度低，每个微服务可由一个小规模开发团队完全掌控，易于保持高可维护性和开发效率。</p></li><li><p>独立部署：由于微服务具备独立的运行进程，所以每个微服务也可以独立部署。当某个微服务发生变更时无需编译、部署整个应用。由微服务组成的应用相当于具备一系列可并行的发布流程，使得发布更加高效，同时降低对生产环境所造成的风险，最终缩短应用交付周期。</p></li><li><p>技术选型灵活：微服务架构下，技术选型是去中心化的。每个团队可以根据自身服务的需求和行业发展的现状，自由选择最适合的技术栈。由于每个微服务相对简单，故需要对技术栈进行升级时所面临的风险就较低，甚至完全重构一个微服务也是可行的。</p></li><li><p>容错：当某一组建发生故障时，在单一进程的传统架构下，故障很有可能在进程内扩散，形成应用全局性的不可用。在微服务架构下，故障会被隔离在单个服务中。若设计良好，其他服务可通过重试、平稳退化等机制实现应用层面的容错。</p></li><li><p>扩展：单块架构应用也可以实现横向扩展，就是将整个应用完整的复制到不同的节点。当应用的不同组件在扩展需求上存在差异时，微服务架构便体现出其灵活性，因为每个服务可以根据实际需求独立进行扩展。</p></li></ul><h1>Spring Cloud都做了哪些事</h1><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包</p><p>以下为Spring Cloud的核心功能：</p><ul><li>分布式/版本化配置</li><li>服务注册和发现</li><li>路由</li><li>服务和服务之间的调用</li><li>负载均衡</li><li>断路器</li><li>分布式消息传递</li></ul><p><img src="/2018/04/16/Spring-Cloud微服务初步架构设计/1.png" title="图片"></p><p>通过这张图，我们来了解一下各组件配置使用运行流程：</p><ol><li>请求统一通过API网关（Zuul）来访问内部服务.</li><li>网关接收到请求后，从注册中心（Eureka）获取可用服务</li><li>由Ribbon进行均衡负载后，分发到后端具体实例</li><li>微服务之间通过Feign进行通信处理业务</li><li>Hystrix负责处理服务超时熔断</li><li>Turbine监控服务间的调用和熔断相关指标</li></ol><h1>微服务的经验和建议</h1><ol><li><p>建议尽量不要使用Jsp，页面开发推荐使用Thymeleaf。Web项目建议独立部署Tomcat，不要使用内嵌的Tomcat，内嵌Tomcat部署Jsp项目会偶现龟速访问的情况。</p></li><li><p>服务编排是个好东西，主要的作用是减少项目中的相互依赖。比如现在有项目a调用项目b，项目b调用项目c…一直到h，是一个调用链，那么项目上线的时候需要先更新最底层的h再更新g…更新c更新b最后是更新项目a。这只是这一个调用链，在复杂的业务中有非常多的调用，如果要记住每一个调用链对开发运维人员来说就是灾难。</p></li></ol><p>有这样一个好办法可以尽量的减少项目的相互依赖，就是服务编排，一个核心的业务处理项目，负责和各个微服务打交道。比如之前是a调用b，b掉用c，c调用d，现在统一在一个核心项目W中来处理，W服务使用a的时候去调用b，使用b的时候W去调用c，举个例子：在第三方支付业务中，有一个核心支付项目是服务编排，负责处理支付的业务逻辑，W项目使用商户信息的时候就去调用“商户系统”，需要校验设备的时候就去调用“终端系统”，需要风控的时候就调用“风控系统”，各个项目需要的依赖参数都由W来做主控。以后项目部署的时候，只需要最后启动服务编排项目即可。</p><ol start="3"><li>不要为了追求技术而追求技术，确定进行微服务架构改造之前，需要考虑以下几方面的因素：</li></ol><ul><li>团队的技术人员是否已经具备相关技术基础。</li><li>公司业务是否适合进行微服务化改造，并不是所有的平台都适合进行微服务化改造，比如：传统行业有很多复杂垂直的业务系统。</li><li>Spring Cloud生态的技术有很多，并不是每一种技术方案都需要用上，适合自己的才是最好的。</li></ul><p>通过以上经验和建议，大体初步设计的微服务架构如下图（省略MQ,服务注册发现），粗略展示。</p><p><img src="/2018/04/16/Spring-Cloud微服务初步架构设计/2.jpg" title="图片"></p><h1><strong><a href="https://github.com/hhbbz/spring-cloud-sample" target="_blank" rel="noopener">项目地址</a></strong></h1>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 分布式 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker文件系统与存储驱动简介</title>
      <link href="/2018/03/28/DockerOverlay2/"/>
      <url>/2018/03/28/DockerOverlay2/</url>
      <content type="html"><![CDATA[<h1>问题描述</h1><p>同事在生产环境中使用Docker去部署ELK日志搜集系统，过程中没有将容器与数据卷挂载。于是持久化的数据都落在了/var/lib/docker/overlay2中。由于服务器需要清理服务器磁盘空间，所以要想无差错清理数据卷中的数据，需要对Docker的文件系统和存储驱动做了解和熟悉。</p><h2>文件系统OverlayFS</h2><p>OverlayFS是一种和AUFS很类似的文件系统，与AUFS相比，OverlayFS有以下特性：　　　1) 更简单地设计；　　　2) 从3.18开始，就进入了Linux内核主线；　　　3) 可能更快一些。　　因此，OverlayFS在Docker社区关注度提高很快，被很多人认为是AUFS的继承者。就像宣称的一样，OverlayFS还很年轻。所以，在生成环境使用它时，还是需要更加当心。&lt;!-- more --&gt;　　Docker的overlay存储驱动利用了很多OverlayFS特性来构建和管理镜像与容器的磁盘结构。　　自从Docker1.12起，Docker也支持overlay2存储驱动，相比于overlay来说，overlay2在inode优化上更加高效。但overlay2驱动只兼容Linux kernel4.0以上的版本。</p><p><strong><code>注意：自从OverlayFS加入kernel主线后，它在kernel模块中的名称就被从overlayfs改为overlay了。但是为了在本文中区别，我们使用OverlayFS代表整个文件系统，而overlay/overlay2表示Docker的存储驱动。</code></strong></p><h2>存储驱动overlay和overlay2</h2><h3>OverlayFS（overlay）的镜像分层与共享</h3><p>OverlayFS使用两个目录，把一个目录置放于另一个之上，并且对外提供单个统一的视角。这两个目录通常被称作层，这个分层的技术被称作union mount。术语上，下层的目录叫做lowerdir，上层的叫做upperdir。对外展示的统一视图称作merged。　　如下图所示，Overlay在主机上用到2个目录，这2个目录被看成是overlay的层。 upperdir为容器层、lowerdir为镜像层使用联合挂载技术将它们挂载在同一目录(merged)下，提供统一视图。<img src="/2018/03/28/DockerOverlay2/overlay_constructs.jpg" title="图片">　　注意镜像层和容器层是如何处理相同的文件的：容器层（upperdir）的文件是显性的，会隐藏镜像层（lowerdir）相同文件的存在。容器映射（merged）显示出统一的视图。　　overlay驱动只能工作在两层之上。也就是说多层镜像不能用多层OverlayFS实现。替代的，每个镜像层在/var/lib/docker/overlay中用自己的目录来实现，使用硬链接这种有效利用空间的方法，来引用底层分享的数据。注意：Docker1.10之后，镜像层ID和/var/lib/docker中的目录名不再一一对应。　　创建一个容器，overlay驱动联合镜像层和一个新目录给容器。镜像顶层是overlay中的只读lowerdir，容器的新目录是可写的upperdir。</p><h4>overlay中镜像和容器的磁盘结构</h4><p>下面的docker pull命令展示了Docker host下载一个由5层组成的镜像。</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker pull ubuntu</span><br><span class="line"></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/ubuntu</span><br><span class="line">c62795f78da9: Pull complete</span><br><span class="line">d4fceeeb758e: Pull complete</span><br><span class="line">5c9125a401ae: Pull complete</span><br><span class="line">0062f774e994: Pull complete</span><br><span class="line">6b33fd031fac: Pull complete</span><br><span class="line">Digest: sha256:c2bbf50d276508d73dd865cda7b4ee9b5243f2648647d21e3a471dd3cc4209a0</span><br><span class="line">Status: Downloaded newer image for ubuntu:latests</span><br></pre></td></tr></table></figure></p><p>此时，在路径/var/lib/docker/overlay/下，每个镜像层都有一个对应的目录，包含了该层镜像的内容，通过tree命令发现，每个镜像层下只包含一个root目录。 (因为docker1.10开始，使用基于内容的寻址，因此目录名和镜像层的id不一致)。</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> /home/hhbbz# tree -L 2 /var/lib/docker/overlay/</span><br><span class="line"></span><br><span class="line">/var/lib/docker/overlay/</span><br><span class="line">├── 3279a41fd358cdda798d99cc2da0425b4836a489083ae9db4aedc834f426915a</span><br><span class="line">│   └── root</span><br><span class="line">├── 33629fe3999e692ecbeb340f855a2d05ddf4e173ea915041be217e1c9cc8a48f</span><br><span class="line">│   └── root</span><br><span class="line">├── 6ab876fcc7ad584dd1eebae0d9304abb22561012f6adb87828f57906d799c33b</span><br><span class="line">│   └── root</span><br><span class="line">├── 77806a4b8257cd5508a1131d4d47c2d4b4d51703a1cc0dd8daddf0e86a68d492</span><br><span class="line">│   └── root</span><br><span class="line">└── ed271f2159e3c9de18ede980e4e2ecb0ef39b96927d446ba93deab0b6ff1a8e3</span><br><span class="line">    └── root</span><br></pre></td></tr></table></figure></p><p>每一层都包含了&quot;该层独有的文件&quot;以及&quot;和其低层共享的数据的硬连接&quot;，如</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ls -i /var/lib/docker/overlay/3279a41fd358cdda798d99cc2da0425b4836a489083ae9db4aedc834f426915a/root/bin/ls</span><br><span class="line"></span><br><span class="line">405241 /var/lib/docker/overlay/3279a41fd358cdda798d99cc2da0425b4836a489083ae9db4aedc834f426915a/root/bin/ls</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> /home/hhbbz# ls -i /var/lib/docker/overlay/33629fe3999e692ecbeb340f855a2d05ddf4e173ea915041be217e1c9cc8a48f/root/bin/ls</span><br><span class="line"></span><br><span class="line">405241 /var/lib/docker/overlay/33629fe3999e692ecbeb340f855a2d05ddf4e173ea915041be217e1c9cc8a48f/root/bin/ls</span><br></pre></td></tr></table></figure></p><p>每一层都使用一个硬链接来指向实际ls命令的inode号(405241)。使用刚刚拉取的ubuntu镜像创建一个容器，用docker ps命令查看：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> /home/hhbbz# docker ps</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">8963ffb422fa        ubuntu              "/bin/bash"         32 minutes ago      Up 52 seconds                           container_1</span><br></pre></td></tr></table></figure></p><p>创建容器时，实际上是在已有的镜像层上创建了一层容器层，容器层在路径/var/lib/docker/overlay下也存在对应的目录：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span> /home/hhbbz# ls /var/lib/docker/overlay/</span><br><span class="line"></span><br><span class="line">3279a41fd358cdda798d99cc2da0425b4836a489083ae9db4aedc834f426915a</span><br><span class="line">33629fe3999e692ecbeb340f855a2d05ddf4e173ea915041be217e1c9cc8a48f</span><br><span class="line">6ab876fcc7ad584dd1eebae0d9304abb22561012f6adb87828f57906d799c33b</span><br><span class="line">6abc47fcf668b6820a2a9a8b0d0c6150f9df61ab5a323783630fac3fd282144d       //创建容器后新增的目录</span><br><span class="line">6abc47fcf668b6820a2a9a8b0d0c6150f9df61ab5a323783630fac3fd282144d-init  //创建容器后新增的目录</span><br><span class="line">77806a4b8257cd5508a1131d4d47c2d4b4d51703a1cc0dd8daddf0e86a68d492</span><br><span class="line">ed271f2159e3c9de18ede980e4e2ecb0ef39b96927d446ba93deab0b6ff1a8e3</span><br></pre></td></tr></table></figure></p><p>“6abc47……”和“6abc47…..-init”为创建容器后新增的目录。查看这两个目录的内容:</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> /home/hhbbz# tree -L 3 /var/lib/docker/overlay/6abc47fcf668b6820a2a9a8b0d0c6150f9df61ab5a323783630fac3fd282144d*/</span><br><span class="line"></span><br><span class="line">/var/lib/docker/overlay/6abc47fcf668b6820a2a9a8b0d0c6150f9df61ab5a323783630fac3fd282144d/</span><br><span class="line">├── lower-id</span><br><span class="line">├── merged</span><br><span class="line">├── upper</span><br><span class="line">│   ├── dev</span><br><span class="line">│   │   └── console</span><br><span class="line">│   ├── etc</span><br><span class="line">│   │   ├── hostname</span><br><span class="line">│   │   ├── hosts</span><br><span class="line">│   │   ├── mtab -&gt; /proc/mounts</span><br><span class="line">│   │   └── resolv.conf</span><br><span class="line">│   └── root</span><br><span class="line">└── work</span><br><span class="line">    └── work</span><br><span class="line"></span><br><span class="line">/var/lib/docker/overlay/6abc47fcf668b6820a2a9a8b0d0c6150f9df61ab5a323783630fac3fd282144d-init/</span><br><span class="line">├── lower-id</span><br><span class="line">├── merged</span><br><span class="line">├── upper</span><br><span class="line">│   ├── dev</span><br><span class="line">│   │   └── console</span><br><span class="line">│   └── etc</span><br><span class="line">│       ├── hostname</span><br><span class="line">│       ├── hosts</span><br><span class="line">│       ├── mtab -&gt; /proc/mounts</span><br><span class="line">│       └── resolv.conf</span><br><span class="line">└── work</span><br><span class="line">    └── work</span><br></pre></td></tr></table></figure></p><p>“6abc47……”为读写层，“6abc47…..-init”为初始层。 初始层中大多是初始化容器环境时，与容器相关的环境信息， 如容器主机名，主机host信息以及域名服务文件等。所有对容器做出的改变都记录在读写层。</p><p>文件lower-id用来索引该容器使用的镜像层，upper目录包含了容器层的内容，每当启动一个容器时，会将lower-id指向的镜像层目录以及upper目录联合挂载到merged目录，因此，容器内的视角就是merged目录下的内容。而work目录则是用来完成如copy-on_write的操作。 看看容器使用到了哪一层镜像层：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> /home/hhbbz# cat /var/lib/docker/overlay/6abc47fcf668b6820a2a9a8b0d0c6150f9df61ab5a323783630fac3fd282144d/lower-id</span><br><span class="line"></span><br><span class="line">ed271f2159e3c9de18ede980e4e2ecb0ef39b96927d446ba93deab0b6ff1a8e3</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> /home/hhbbz# cat /var/lib/docker/overlay/6abc47fcf668b6820a2a9a8b0d0c6150f9df61ab5a323783630fac3fd282144d-init/lower-id</span><br><span class="line"></span><br><span class="line">ed271f2159e3c9de18ede980e4e2ecb0ef39b96927d446ba93deab0b6ff1a8e3</span><br></pre></td></tr></table></figure></p><p>在刚才创建的容器中创建一个文件：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@8963ffb422fa:/# touch file</span><br><span class="line"></span><br><span class="line">root@8963ffb422fa:/# echo "hello world" &gt; file</span><br><span class="line"></span><br><span class="line">root@8963ffb422fa:/# ls</span><br><span class="line">bin   dev  file  lib    media  opt   root  sbin  sys  usr</span><br><span class="line">boot  etc  home  lib64  mnt    proc  run   srv   tmp  var</span><br></pre></td></tr></table></figure></p><p>此时再观察“6abc47……”目录(读写层)：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> /home/hhbbz# tree -L 3 /var/lib/docker/overlay/6abc47fcf668b6820a2a9a8b0d0c6150f9df61ab5a323783630fac3fd282144d/  </span><br><span class="line"></span><br><span class="line">/var/lib/docker/overlay/6abc47fcf668b6820a2a9a8b0d0c6150f9df61ab5a323783630fac3fd282144d/</span><br><span class="line">├── lower-id</span><br><span class="line">├── merged</span><br><span class="line">├── upper</span><br><span class="line">│   ├── dev</span><br><span class="line">│   │   └── console</span><br><span class="line">│   ├── etc</span><br><span class="line">│   │   ├── hostname</span><br><span class="line">│   │   ├── hosts</span><br><span class="line">│   │   ├── mtab -&gt; /proc/mounts</span><br><span class="line">│   │   └── resolv.conf</span><br><span class="line">│   ├── file</span><br><span class="line">│   └── root</span><br><span class="line">└── work</span><br><span class="line">    └── work</span><br></pre></td></tr></table></figure></p><p>发现upper目录下多出了一个file文件，就是刚才在容器中创建的文件。</p><h3>OverlayFS（overlay2）的镜像分层与共享</h3><p>和overlay为了实现“两个目录反映多层镜像“而使用硬链接不同，overlay2驱动天生支持多层。(最多128)</p><p>因此，overlay2在使用docker层相关的命令时，能提供更好的性能(如：docker build、docker commit)。而且overlay2消耗的inode节点更少。</p><h4>overlay2中镜像和容器的磁盘结构</h4><p>docker pull ubuntu拉取完一个5层的Ubuntu镜像后，/var/lib/docker/overlay2下可以看到6个目录:</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> /home/hhbbz# tree -L 2 /var/lib/docker/overlay2</span><br><span class="line"></span><br><span class="line">/var/lib/docker/overlay2</span><br><span class="line">├── 1d18eac18e483e5af46d52673e254cb89996041d91356c6dd1f0ac1518ba130a</span><br><span class="line">│   ├── diff</span><br><span class="line">│   └── link   //文件</span><br><span class="line">├── 28702e0cca9ff9a3245ce7e61326d098788e855ea599bf160465f537756a56a6</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link   //文件</span><br><span class="line">│   ├── lower   //文件</span><br><span class="line">│   ├── merged</span><br><span class="line">│   └── work</span><br><span class="line">├── 299397034eb96f22d544bf544c9ef993fa32571f466bd8a881aec0fc5a94a8df</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link   //文件</span><br><span class="line">│   ├── lower   //文件</span><br><span class="line">│   ├── merged</span><br><span class="line">│   └── work</span><br><span class="line">├── 8c0de7df4581df4787b08a28356cc8d7ba7b420c70dc36cc0615afdafb6ee15a</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link   //文件</span><br><span class="line">│   ├── lower   //文件</span><br><span class="line">│   ├── merged</span><br><span class="line">│   └── work</span><br><span class="line">├── f21a47541026214e519fccdf8b838ac2c4e11a1a2dd6a5febc061381a1972ad7</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link   //文件</span><br><span class="line">│   ├── lower   //文件</span><br><span class="line">│   ├── merged</span><br><span class="line">│   └── work</span><br><span class="line">└── l</span><br><span class="line">    ├── 5DJFQNGXSA5CVOC6NA6HPUCXXB -&gt; ../299397034eb96f22d544bf544c9ef993fa32571f466bd8a881aec0fc5a94a8df/diff</span><br><span class="line">    ├── EGQNS3O24ONBL5BJSGNTX4NP6E -&gt; ../1d18eac18e483e5af46d52673e254cb89996041d91356c6dd1f0ac1518ba130a/diff</span><br><span class="line">    ├── JWB63ZJDZOTK5N22OMR5BKUVMG -&gt; ../8c0de7df4581df4787b08a28356cc8d7ba7b420c70dc36cc0615afdafb6ee15a/diff</span><br><span class="line">    ├── UZHRLLTPQMODQQYBLN6NOT6N2K -&gt; ../28702e0cca9ff9a3245ce7e61326d098788e855ea599bf160465f537756a56a6/diff</span><br><span class="line">    └── X76VPZDDKIW3GLWBFUHKDFBEPE -&gt; ../f21a47541026214e519fccdf8b838ac2c4e11a1a2dd6a5febc061381a1972ad7/diff</span><br><span class="line"></span><br><span class="line">24 directories, 9 files</span><br></pre></td></tr></table></figure></p><p>”l“目录包含一些符号链接作为缩短的层标识符. 这些缩短的标识符用来避免挂载时超出页面大小的限制。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ /home/hhbbz# ls -l /var/lib/docker/overlay2/l/</span><br><span class="line">    </span><br><span class="line">总用量 20</span><br><span class="line">lrwxrwxrwx 1 root root 72  4月 20 17:31 5DJFQNGXSA5CVOC6NA6HPUCXXB -&gt; ../299397034eb96f22d544bf544c9ef993fa32571f466bd8a881aec0fc5a94a8df/diff</span><br><span class="line">lrwxrwxrwx 1 root root 72  4月 20 17:31 EGQNS3O24ONBL5BJSGNTX4NP6E -&gt; ../1d18eac18e483e5af46d52673e254cb89996041d91356c6dd1f0ac1518ba130a/diff</span><br><span class="line">lrwxrwxrwx 1 root root 72  4月 20 17:31 JWB63ZJDZOTK5N22OMR5BKUVMG -&gt; ../8c0de7df4581df4787b08a28356cc8d7ba7b420c70dc36cc0615afdafb6ee15a/diff</span><br><span class="line">lrwxrwxrwx 1 root root 72  4月 20 17:31 UZHRLLTPQMODQQYBLN6NOT6N2K -&gt; ../28702e0cca9ff9a3245ce7e61326d098788e855ea599bf160465f537756a56a6/diff</span><br><span class="line">lrwxrwxrwx 1 root root 72  4月 20 17:31 X76VPZDDKIW3GLWBFUHKDFBEPE -&gt; ../f21a47541026214e519fccdf8b838ac2c4e11a1a2dd6a5febc061381a1972ad7/diff</span><br></pre></td></tr></table></figure></p><p>最底层包含”link”文件(不包含lower文件，因为是最底层)，在上面的结果中“1d8e….”为最底层。 这个文件记录着作为标识符的更短的符号链接的名字、最底层还有一个”diff”目录(包含实际内容)。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ /home/hhbbz# cat /var/lib/docker/overlay2/1d18eac18e483e5af46d52673e254cb89996041d91356c6dd1f0ac1518ba130a/link </span><br><span class="line">    </span><br><span class="line">EGQNS3O24ONBL5BJSGNTX4NP6E</span><br><span class="line">    </span><br><span class="line">root@hhbbz-MS-7823:/home/hhbbz# ls /var/lib/docker/overlay2/1d18eac18e483e5af46d52673e254cb89996041d91356c6dd1f0ac1518ba130a/diff/</span><br><span class="line">    </span><br><span class="line">bin   dev  home  lib64  mnt  proc  run   srv  tmp  var</span><br><span class="line">boot  etc  lib   media  opt  root  sbin  sys  usr</span><br></pre></td></tr></table></figure></p><p>从第二层开始，每层镜像层包含”lower“文件，根据这个文件可以索引构建出整个镜像的层次结构。 ”diff“文件(层的内容)。还包含”merged“和”work”目录，用途和overlay一样。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ /home/hhbbz# cat /var/lib/docker/overlay2/28702e0cca9ff9a3245ce7e61326d098788e855ea599bf160465f537756a56a6/link </span><br><span class="line">    </span><br><span class="line">UZHRLLTPQMODQQYBLN6NOT6N2K</span><br><span class="line">    </span><br><span class="line">$ /home/hhbbz# ls /var/lib/docker/overlay2/28702e0cca9ff9a3245ce7e61326d098788e855ea599bf160465f537756a56a6/diff/</span><br><span class="line">    </span><br><span class="line">etc  sbin  usr  var</span><br><span class="line">    </span><br><span class="line">$ /home/hhbbz# cat /var/lib/docker/overlay2/28702e0cca9ff9a3245ce7e61326d098788e855ea599bf160465f537756a56a6/lower</span><br><span class="line">    </span><br><span class="line">l/EGQNS3O24ONBL5BJSGNTX4NP6E</span><br></pre></td></tr></table></figure></p><p>再来看看容器层，容器层的文件构成和镜像层类似(这点和overlay不同)，使用刚刚拉取的ubuntu镜像创建一个容器，/var/lib/docker/overlay2目录下新增2个目录：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── 2558ed8dd7051c1e78ea980590a228100ec3d299c01b35e9b7fa503723593d19</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link</span><br><span class="line">│   ├── lower</span><br><span class="line">│   ├── merged</span><br><span class="line">│   └── work</span><br><span class="line">├── 2558ed8dd7051c1e78ea980590a228100ec3d299c01b35e9b7fa503723593d19-init</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link</span><br><span class="line">│   ├── lower</span><br><span class="line">│   ├── merged</span><br><span class="line">│   └── work</span><br><span class="line">└── l</span><br><span class="line">    ├── 7H7MUMX4IOAVLIJ2YPLR5MZOO5 -&gt; ../2558ed8dd7051c1e78ea980590a228100ec3d299c01b35e9b7fa503723593d19-init/diff</span><br><span class="line">    ├── EBSBKJBLA2WYBHTMHKSMCEEWNP -&gt; ../2558ed8dd7051c1e78ea980590a228100ec3d299c01b35e9b7fa503723593d19/diff</span><br><span class="line"></span><br><span class="line">$ /home/hhbbz# cat /var/lib/docker/overlay2/2558ed8dd7051c1e78ea980590a228100ec3d299c01b35e9b7fa503723593d19/lower </span><br><span class="line">    </span><br><span class="line">l/7H7MUMX4IOAVLIJ2YPLR5MZOO5:l/5DJFQNGXSA5CVOC6NA6HPUCXXB:l/JWB63ZJDZOTK5N22OMR5BKUVMG:l/X76VPZDDKIW3GLWBFUHKDFBEPE:l/UZHRLLTPQMODQQYBLN6NOT6N2K:l/EGQNS3O24ONBL5BJSGNTX4NP6E</span><br></pre></td></tr></table></figure></p><h3>容器的读写</h3><p>对于读，考虑下列3种场景：</p><ul><li>读的文件不在容器层：如果读的文件不在容器层，则从镜像层进行读</li><li>读的文件只存在在容器层：直接从容器层读</li><li>读的文件在容器层和镜像层：读容器层中的文件，因为容器层隐藏了镜像层同名的文件</li></ul><p>对于写，考虑下列场景：</p><ul><li>写的文件不在容器层，在镜像层：由于文件不在容器层，因此overlay/overlay2存储驱动使用copy_up操作从镜像层拷贝文件到容器层，然后将写入的内容写入到文件新的拷贝中。</li><li>删除文件和目录：删除镜像层的文件，会在容器层创建一个whiteout文件来隐藏它；删除镜像层的目录，会创建opaque目录，它和whiteout文件有相同的效果</li><li>重命名目录：对一个目录调用rename(2)仅仅在资源和目的地路径都在顶层时才被允许，否则返回EXDEV。</li></ul><h2>问题解决</h2><p>最后通过在/var/lib/docker/overlay2目录下执行<code>du -sh *</code>找到占用磁盘空间最大的几个文件夹，进行审查清理。</p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot+RocketMQ做分布式消息队列</title>
      <link href="/2018/03/26/SpringBoot+RocketMQ%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2018/03/26/SpringBoot+RocketMQ%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<h1>项目地址</h1><p><a href="https://github.com/hhbbz/spring-boot-aliRocketMQ-starter" target="_blank" rel="noopener">spring-boot-aliRocketMQ-starter</a></p><h1>application.yml</h1><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mq-config:</span></span><br><span class="line"><span class="attr">producerId:</span> <span class="string">PID_*</span></span><br><span class="line"><span class="attr">consumerId:</span> <span class="string">CID_*</span></span><br><span class="line"><span class="attr">accessKey:</span> <span class="string">*</span></span><br><span class="line"><span class="attr">secretKey:</span> <span class="string">*</span></span><br><span class="line"><span class="attr">onsAddr:</span> <span class="string">*</span></span><br><span class="line"><span class="attr">topic:</span> <span class="string">*</span></span><br></pre></td></tr></table></figure></p><h1>添加启动类用于初始化消费者</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMQRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RocketMQRunner.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MQConfig mqConfig;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"orderConsumer"</span>)</span><br><span class="line">    <span class="keyword">private</span> OrderConsumer orderConsumer;</span><br><span class="line">    <span class="comment">/**消息监听器**/</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConsumerHandler consumerHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化订阅者，生产者信息，启动</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        orderConsumer.subscribe(mqConfig.getTopic(), mqConfig.getTag(), consumerHandler);</span><br><span class="line">        orderConsumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>生产消息</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysMessageProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SysMessageProducer.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MQHelper&lt;SysMessage&gt; mqHelper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MQConfig mqConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此方法用于在消息中心创建消息后调用推送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sysMessage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PushMessageWhenCreate</span><span class="params">(SysMessage sysMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (AssertValue.isNotNull(sysMessage)) &#123;</span><br><span class="line">            <span class="comment">//发送消息到队列中</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ProducerMessage&lt;SysMessage&gt; producerMessage = <span class="keyword">new</span> ProducerMessage&lt;SysMessage&gt;()</span><br><span class="line">                        .setTopic(mqConfig.getTopic())</span><br><span class="line">                        .setTags(<span class="string">"middle"</span>)</span><br><span class="line">                        .setName(MQHandlerType.PUSH_APPMESSAGE_NEWS.getTypeName())</span><br><span class="line">                        .setKey(MQHandlerType.PUSH_APPMESSAGE_NEWS.toString())</span><br><span class="line">                        .setBody(sysMessage)</span><br><span class="line">                        .setShardingKey(String.valueOf(sysMessage.getId()))</span><br><span class="line">                        .setState(<span class="string">"none"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//设置立刻发送消息</span></span><br><span class="line">                producerMessage.setType(RocketMQServiceConstant.SYNCHRONOUS_ORDER_MESSAGE);</span><br><span class="line">                producerMessage.setStartDeliveryTime(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                <span class="comment">//创建消息</span></span><br><span class="line">                Message message = mqHelper</span><br><span class="line">                        .generateMessage(producerMessage);</span><br><span class="line">                <span class="comment">//发送消息</span></span><br><span class="line">                SendResult sendResult = mqHelper.sendMessage(message, producerMessage);</span><br><span class="line">                logger.info(<span class="keyword">new</span> Date() + <span class="string">" 发送成功! Topic:"</span> + mqConfig.getTopic() + <span class="string">" msgId: "</span> + sendResult.getMessageId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                logger.error(<span class="string">"消息生产失败,将进行两次重试"</span>, e.getMessage());</span><br><span class="line">                logger.info(<span class="string">"发送失败"</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RestInternalServerErrorException(ExceptionEnumeration.SYS_NEWS_PUSH_FAIL, <span class="string">"平台消息推送失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RestInternalServerErrorException(ExceptionEnumeration.SYS_NEWS_SELECT_FAIL, <span class="string">"找不到该平台消息"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>监听器消费消息</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerHandler</span> <span class="keyword">implements</span> <span class="title">MessageOrderListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ConsumerHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费消息 handler</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderAction <span class="title">consume</span><span class="params">(Message message, ConsumeOrderContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 分布式 </tag>
            
            <tag> Spring </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十分钟入门RocketMQ</title>
      <link href="/2018/03/20/%E5%8D%81%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8RocketMQ/"/>
      <url>/2018/03/20/%E5%8D%81%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8RocketMQ/</url>
      <content type="html"><![CDATA[<p>本文首先引出消息中间件通常需要解决哪些问题，在解决这些问题当中会遇到什么困难，Apache RocketMQ作为阿里开源的一款高性能、高吞吐量的分布式消息中间件否可以解决，规范中如何定义这些问题。然后本文将介绍RocketMQ的架构设计，以期让读者快速了解RocketMQ。</p><h1>消息中间件需要解决哪些问题？</h1><h2>Publish/Subscribe</h2><p>发布订阅是消息中间件的最基本功能，也是相对于传统RPC通信而言。在此不再详述。</p><h2>Message Priority</h2><p>规范中描述的优先级是指在一个消息队列中，每条消息都有不同的优先级，一般用整数来描述，优先级高的消息先投递，如果消息完全在一个内存队列中，那么在投递前可以按照优先级排序，令优先级高的先投递。由于RocketMQ所有消息都是持久化的，所以如果按照优先级来排序，开销会非常大，因此RocketMQ没有特意支持消息优先级，但是可以通过变通的方式实现类似功能，即单独配置一个优先级高的队列，和一个普通优先级的队列， 将不同优先级发送到不同队列即可。</p><p>对于优先级问题，可以归纳为2类：</p><ol><li>只要达到优先级目的即可，不是严格意义上的优先级，通常将优先级划分为高、中、低，或者再多几个级别。每个优先级可以用不同的topic表示，发消息时，指定不同的topic来表示优先级，这种方式可以解决绝大部分的优先级问题，但是对业务的优先级精确性做了妥协。</li><li>严格的优先级，优先级用整数表示，例如0 ~ 65535，这种优先级问题一般使用不同topic解决就非常不合适。如果要让MQ解决此问题，会对MQ的性能造成非常大的影响。这里要确保一点，业务上是否确实需要这种严格的优先级，如果将优先级压缩成几个，对业务的影响有多大？</li></ol><h2>Message Order</h2><p>消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了3条消息，分别是订单创建，订单付款，订单完成。消费时，要按照这个顺序消费才能有意义。但是同时订单之间是可以并行消费的。RocketMQ可以严格的保证消息有序。</p><h2>Message Filter</h2><h3>Broker端消息过滤</h3><p>在Broker中，按照Consumer的要求做过滤，优点是减少了对于Consumer无用消息的网络传输。缺点是增加了Broker的负担，实现相对复杂。</p><ol><li>淘宝Notify支持多种过滤方式，包含直接按照消息类型过滤，灵活的语法表达式过滤，几乎可以满足最苛刻的过滤需求。</li><li>淘宝RocketMQ支持按照简单的Message Tag过滤，也支持按照Message Header、body进行过滤。</li><li>CORBA Notification规范中也支持灵活的语法表达式过滤</li></ol><h3>Consumer端消息过滤</h3><p>这种过滤方式可由应用完全自定义实现，但是缺点是很多无用的消息要传输到Consumer端。</p><h2>Message Persistence</h2><p>消息中间件通常采用的几种持久化方式：</p><ol><li>持久化到数据库，例如Mysql。</li><li>持久化到KV存储，例如levelDB、伯克利DB等KV存储系统。</li><li>文件记录形式持久化，例如Kafka，RocketMQ</li><li>对内存数据做一个持久化镜像，例如beanstalkd，VisiNotify</li><li>(1)、(2)、(3)三种持久化方式都具有将内存队列Buffer进行扩展的能力，(4)只是一个内存的镜像，作用是当Broker挂掉重启后仍然能将之前内存的数据恢复出来。</li></ol><p>JMS与CORBA Notification规范没有明确说明如何持久化，但是持久化部分的性能直接决定了整个消息中间件的性能。</p><p>RocketMQ充分利用Linux文件系统内存cache来提高性能。</p><h2>Message Reliablity</h2><p>影响消息可靠性的几种情况：</p><ol><li>Broker正常关闭</li><li>Broker异常Crash</li><li>OS Crash</li><li>机器掉电，但是能立即恢复供电情况。</li><li>机器无法开机（可能是cpu、主板、内存等关键设备损坏）</li><li>磁盘设备损坏。</li></ol><p>(1)、(2)、(3)、(4)四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。</p><p>(5)、(6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。</p><p>RocketMQ从3.0版本开始支持同步双写。</p><h2>Low Latency Messaging</h2><p>在消息不堆积情况下，消息到达Broker后，能立刻到达Consumer。RocketMQ使用长轮询Pull方式，可保证消息非常实时，消息实时性不低于Push。</p><h2>At least Once</h2><p>是指每个消息必须投递一次。RocketMQ Consumer先pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持此特性。</p><h2>Exactly Only Once</h2><ol><li>发送消息阶段，不允许发送重复的消息。</li><li>消费消息阶段，不允许消费重复的消息。</li></ol><p>只有以上两个条件都满足情况下，才能认为消息是“Exactly Only Once”，而要实现以上两点，在分布式系统环境下，不可避免要产生巨大的开销。所以RocketMQ为了追求高性能，并不保证此特性，要求在业务上进行去重，也就是说消费消息要做到幂等性。RocketMQ虽然不能严格保证不重复，但是正常情况下很少会出现重复发送、消费情况，只有网络异常，Consumer启停等异常情况下会出现消息重复。</p><h2>Broker的Buffer满了怎么办？</h2><p>Broker的Buffer通常指的是Broker中一个队列的内存Buffer大小，这类Buffer通常大小有限，如果Buffer满了以后怎么办？下面是CORBA Notification规范中处理方式：</p><ol><li>RejectNewEvents 拒绝新来的消息，向Producer返回RejectNewEvents错误码。</li><li>按照特定策略丢弃已有消息<ul><li>AnyOrder - Any event may be discarded on overflow. This is the default setting for this property.</li><li>FifoOrder - The first event received will be the first discarded.</li><li>LifoOrder - The last event received will be the first discarded.</li><li>PriorityOrder - Events should be discarded in priority order, such that lower priority events will be discarded before higher priority events.</li><li>DeadlineOrder - Events should be discarded in the order of shortest expiry deadline first.</li></ul></li></ol><p>RocketMQ没有内存Buffer概念，RocketMQ的队列都是持久化磁盘，数据定期清除。</p><p>对于此问题的解决思路，RocketMQ同其他MQ有非常显著的区别，RocketMQ的内存Buffer抽象成一个无限长度的队列，不管有多少数据进来都能装得下，这个无限是有前提的，Broker会定期删除过期的数据，例如Broker只保存3天的消息，那么这个Buffer虽然长度无限，但是3天前的数据会被从队尾删除。</p><p>此问题的本质原因是网络调用存在不确定性，即既不成功也不失败的第三种状态，所以才产生了消息重复性问题。</p><h2>回溯消费</h2><p>回溯消费是指Consumer已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker在向Consumer投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于Consumer系统故障，恢复后需要重新消费1小时前的数据，那么Broker要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ支持按照时间回溯消费，时间维度精确到毫秒，可以向前回溯，也可以向后回溯。</p><h2>消息堆积</h2><p>消息中间件的主要功能是异步解耦，还有个重要功能是挡住前端的数据洪峰，保证后端系统的稳定性，这就要求消息中间件具有一定的消息堆积能力，消息堆积分以下两种情况：</p><ol><li>消息堆积在内存Buffer，一旦超过内存Buffer，可以根据一定的丢弃策略来丢弃消息，如CORBA Notification规范中描述。适合能容忍丢弃消息的业务，这种情况消息的堆积能力主要在于内存Buffer大小，而且消息堆积后，性能下降不会太大，因为内存中数据多少对于对外提供的访问能力影响有限。</li><li>消息堆积到持久化存储系统中，例如DB，KV存储，文件记录形式。 当消息不能在内存Cache命中时，要不可避免的访问磁盘，会产生大量读IO，读IO的吞吐量直接决定了消息堆积后的访问能力。</li></ol><p>评估消息堆积能力主要有以下四点：</p><ol><li>消息能堆积多少条，多少字节？即消息的堆积容量。</li><li>消息堆积后，发消息的吞吐量大小，是否会受堆积影响？</li><li>消息堆积后，正常消费的Consumer是否会受影响？</li><li>消息堆积后，访问堆积在磁盘的消息时，吞吐量有多大？</li></ol><h2>分布式事务</h2><p>已知的几个分布式事务规范，如XA，JTA等。其中XA规范被各大数据库厂商广泛支持，如Oracle，Mysql等。其中XA的TM实现佼佼者如Oracle Tuxedo，在金融、电信等领域被广泛应用。</p><p>分布式事务涉及到两阶段提交问题，在数据存储方面的方面必然需要KV存储的支持，因为第二阶段的提交回滚需要修改消息状态，一定涉及到根据Key去查找Message的动作。RocketMQ在第二阶段绕过了根据Key去查找Message的问题，采用第一阶段发送Prepared消息时，拿到了消息的Offset，第二阶段通过Offset去访问消息，并修改状态，Offset就是数据的地址。</p><p>RocketMQ这种实现事务方式，没有通过KV存储做，而是通过Offset方式，存在一个显著缺陷，即通过Offset更改数据，会令系统的脏页过多，需要特别关注。</p><h2>定时消息</h2><p>定时消息是指消息发到Broker后，不能立刻被Consumer消费，要到特定的时间点或者等待特定的时间后才能被消费。如果要支持任意的时间精度，在Broker层面，必须要做消息排序，如果再涉及到持久化，那么消息排序要不可避免的产生巨大性能开销。RocketMQ支持定时消息，但是不支持任意时间精度，支持特定的level，例如定时5s，10s，1m等。</p><h2>消息重试</h2><p>Consumer消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer消费消息失败通常可以认为有以下几种情况：</p><ol><li>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其他消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10s秒后再重试。</li><li>由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。</li></ol><h2>RocketMQ Overview</h2><p>RocketMQ是否解决了上述消息中间件面临的问题，接下来让我们一探究竟。</p><h2>RocketMQ 是什么？</h2><p><img src="/2018/03/20/十分钟入门RocketMQ/1.png" title="图片"></p><p>上图是一个典型的消息中间件收发消息的模型，RocketMQ也是这样的设计，简单说来，RocketMQ具有以下特点：</p><ul><li>是一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式特点。</li><li>Producer、Consumer、队列都可以分布式。</li><li>Producer向一些队列轮流发送消息，队列集合称为Topic，Consumer如果做广播消费，则一个consumer实例消费这个Topic对应的所有队列，如果做集群消费，则多个Consumer实例平均消费这个topic对应的队列集合。</li><li>能够保证严格的消息顺序</li><li>提供丰富的消息拉取模式</li><li>高效的订阅者水平扩展能力</li><li>实时的消息订阅机制</li><li>亿级消息堆积能力</li><li>较少的依赖</li></ul><h2>RocketMQ 物理部署结构</h2><p><img src="/2018/03/20/十分钟入门RocketMQ/2.png" title="图片"></p><p>如上图所示， RocketMQ的部署结构有以下特点：</p><ul><li>Name Server是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</li><li>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与Name Server集群中的所有节点建立长连接，定时注册Topic信息到所有Name Server。</li><li>Producer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</li><li>Consumer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。</li></ul><h2>RocketMQ 逻辑部署结构</h2><p><img src="/2018/03/20/十分钟入门RocketMQ/3.png" title="图片"></p><p>如上图所示，RocketMQ的逻辑部署结构有Producer和Consumer两个特点。</p><p>Producer Group</p><p>用来表示一个发送消息应用，一个Producer Group下包含多个Producer实例，可以是多台机器，也可以是一台机器的多个进程，或者一个进程的多个Producer对象。一个Producer Group可以发送多个Topic消息，Producer Group作用如下：</p><ol><li>标识一类Producer</li><li>可以通过运维工具查询这个发送消息应用下有多个Producer实例</li><li>发送分布式事务消息时，如果Producer中途意外宕机，Broker会主动回调Producer Group内的任意一台机器来确认事务状态。</li></ol><p>Consumer Group</p><p>用来表示一个消费消息应用，一个Consumer Group下包含多个Consumer实例，可以是多台机器，也可以是多个进程，或者是一个进程的多个Consumer对象。一个Consumer Group下的多个Consumer以均摊方式消费消息，如果设置为广播方式，那么这个Consumer Group下的每个实例都消费全量数据。</p><h2>RocketMQ 数据存储结构</h2><p><img src="/2018/03/20/十分钟入门RocketMQ/4.png" title="图片"></p><p>如上图所示，RocketMQ采取了一种数据与索引分离的存储方法。有效降低文件资源、IO资源，内存资源的损耗。即便是阿里这种海量数据，高并发场景也能够有效降低端到端延迟，并具备较强的横向扩展能力。</p><p>摘抄于 <a href="http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/" target="_blank" rel="noopener">阿里云中间件团队博客</a></p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>消息队列简介及使用场景</title>
      <link href="/2018/03/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2018/03/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<h1>消息队列的使用场景</h1><p>校验用户名等信息，如果没问题会在数据库中添加一个用户记录如果是用邮箱注册会给你发送一封注册成功的邮件，手机注册则会发送一条短信分析用户的个人信息，以便将来向他推荐一些志同道合的人，或向那些人推荐他发送给用户一个包含操作指南的系统通知</p><h1>消息的重发补偿解决思路</h1><p>可靠消息服务定时查询状态为已发送并超时的消息可靠消息将消息重新投递到 MQ 组件中下游应用监听消息，在满足幂等性的条件下，重新执行业务。下游应用通知可靠消息服务该消息已经成功消费。通过消息状态确认和消息重发两个功能，可以确保上游应用、可靠消息服务和下游应用数据的最终一致性。</p><h1>消息的幂等性解决思路</h1><ol><li>查询操作查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作</li><li>删除操作删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)3.唯一索引，防止新增脏数据比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录</li><li>token机制，防止页面重复提交</li><li>悲观锁获取数据的时候加锁获取select * from table_xxx where id='xxx' for update;注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用</li><li>乐观锁乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。</li><li>分布式锁还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。</li><li>select + insert并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了注意：核心高并发流程不要用这种方法</li><li>状态机幂等在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</li><li>对外提供接口的api如何保证幂等如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)摘抄自： http://825635381.iteye.com/blog/2276077</li></ol><h1>消息的堆积解决思路</h1><p>如果还没开始投入使用kafka，那应该在设计分区数的时候，尽量设置的多点，从而提升生产和消费的并行度，避免消费太慢导致消费堆积。增大批次瓶颈在消费吞吐量的时候，增加批次也可以改善性能增加线程数如果一些消费者组中的消费者线程还是有1个消费者线程消费多个分区的情况，建议增加消费者线程。尽量1个消费者线程对应1个分区，从而发挥现有分区数下的最大并行度。摘抄自： https://kaimingwan.com/post/framworks/kafka/kafkaxiao-xi-dui-ji-chu-li</p><h1>自己如何实现消息队列</h1><p>大体上的设计是由一条线程1执行从等待列表中获取任务插入任务队列再由线程池中的线程从任务队列中取出任务去执行.添加一条线程1主要是防止在执行耗时的任务时阻塞主线程.当执行耗时任务时,添加的任务的操作快于取出任务的操作,当任务队列长度达到最大值时,线程1将被阻塞,等待线程2,3...从任务队列取出任务执行。</p><h1>如何保证消息的有序性</h1><p>通过轮询所有队列的方式来确定消息被发送到哪一个队列（负载均衡策略）。订单号相同的消息会被先后发送到同一个队列中，在获取到路由信息以后，会根据算法来选择一个队列，同一个OrderId获取到的肯定是同一个队列。</p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis缓存穿透、并发、失效</title>
      <link href="/2018/01/26/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%B9%B6%E5%8F%91%E3%80%81%E5%A4%B1%E6%95%88/"/>
      <url>/2018/01/26/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%B9%B6%E5%8F%91%E3%80%81%E5%A4%B1%E6%95%88/</url>
      <content type="html"><![CDATA[<h1>初次谈穿透、并发、失效</h1><h2>缓存穿透</h2><p><img src="/2018/01/26/Redis缓存穿透、并发、失效/1.png" title="图片"></p><p><img src="/2018/01/26/Redis缓存穿透、并发、失效/2.png" title="图片"></p><p><img src="/2018/01/26/Redis缓存穿透、并发、失效/3.png" title="图片"></p><p><strong>注：</strong></p><h3>上面三个图会有什么问题呢？</h3><p>我们在项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回。这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，可能DB就挂掉了。</p><h3>那这种问题有什么好办法解决呢？</h3><p>要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。有一个比较巧妙的作法是，可以将这个不存在的key预先设定一个值。比如，”key” , “&amp;&amp;”。</p><p>在返回这个&amp;&amp;值的时候，我们的应用就可以认为这是不存在的key，那我们的应用就可以决定是否继续等待继续访问，还是放弃掉这次操作。如果继续等待访问，过一个时间轮询点后，再次请求这个key，如果取到的值不再是&amp;&amp;，则可以认为这时候key有值了，从而避免了透传到数据库，从而把大量的类似请求挡在了缓存之中。</p><h2>缓存并发</h2><p>有时候如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。</p><p>我现在的想法是对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。</p><p>这种情况和刚才说的预先设定值问题有些类似，只不过利用锁的方式，会造成部分请求等待。</p><h2>缓存失效</h2><p>引起这个问题的主要原因还是高并发的时候，平时我们设定一个缓存的过期时间时，可能有一些会设置1分钟啊，5分钟这些，并发很高时可能会出在某一个时间同时生成了很多的缓存，并且过期时间都一样，这个时候就可能引发一当过期时间到后，这些缓存同时失效，请求全部转发到DB，DB可能会压力过重。</p><h2>那如何解决这些问题呢？</h2><p>其中的一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><p>我们讨论的第二个问题时针对同一个缓存，第三个问题时针对很多缓存。</p><h2>总结来看</h2><ol><li>缓存穿透：查询一个必然不存在的数据。比如文章表，查询一个不存在的id，每次都会访问DB，如果有人恶意破坏，很可能直接对DB造成影响。</li><li>缓存失效：如果缓存集中在一段时间内失效，DB的压力凸显。这个没有完美解决办法，但可以分析用户行为，尽量让失效时间点均匀分布。</li></ol><p>当发生大量的缓存穿透，例如对某个失效的缓存的大并发访问就造成了缓存雪崩。</p><h1>再谈缓存穿透与并发</h1><p>相信不少朋友之前看过很多类似的文章，但是归根结底就是二个问题：</p><ul><li>如何解决穿透</li><li>如何解决并发</li></ul><p>当并发较高的时候，其实我是不建议使用缓存过期这个策略的，我更希望缓存一直存在，通过后台系统来更新缓存系统中的数据达到数据的一致性目的，有的朋友可能会质疑，如果缓存系统挂了怎么办，这样数据库更新了但是缓存没有更新，没有达到一致性的状态。</p><h2>解决问题的思路是：</h2><p>如果缓存是因为网络问题没有更新成功数据，那么建议重试几次，如果依然没有更新成功则认为缓存系统出错不可用，这时候客户端会将数据的KEY插入到消息系统中，消息系统可以过滤相同的KEY，只需保证消息系统不存在相同的KEY，当缓存系统恢复可用的时候，依次从mq中取出KEY值然后从数据库中读取最新的数据更新缓存。</p><p>**注意：**更新缓存之前，缓存中依然有旧数据，所以不会造成缓存穿透。</p><h2>下图展示了整个思路的过程：</h2><p><img src="/2018/01/26/Redis缓存穿透、并发、失效/4.png" title="图片"></p><p>看完上面的方案以后，又会有不少朋友提出疑问，如果我是第一次使用缓存或者缓存中暂时没有我需要的数据，那又该如何处理呢？</p><h3>解决问题的思路：</h3><p>在这种场景下，客户端从缓存中根据KEY读取数据，如果读到了数据则流程结束，如果没有读到数据（可能会有多个并发都没有读到数据），这时候使用缓存系统中的setNX方法设置一个值（这种方法类似加个锁），没有设置成功的请求则sleep一段时间，设置成功的请求读取数据库获取值，如果获取到则更新缓存，流程结束，之前sleep的请求这时候唤醒后直接再从缓存中读取数据，此时流程结束。</p><p>在看完这个流程后，我想这里面会有一个漏洞，如果数据库中没有我们需要的数据该怎么处理，如果不处理则请求会造成死循环，不断的在缓存和数据库中查询，这时候我们会沿用我之前文章中的如果没有读到数据则往缓存中插入一个NULL字符串的思路，这样其他请求直接就可以根据“NULL”进行处理，直到后台系统在数据库成功插入数据后同步更新清理NULL数据和更新缓存。</p><p>流程图如下所示：</p><p><img src="/2018/01/26/Redis缓存穿透、并发、失效/5.png" title="图片"></p><h2>总结：</h2><p>在实际工作中，我们往往将上面二个方案组合使用才能达到最佳效果，虽然第二种方案也会造成请求阻塞，但是只是在第一次使用或者缓存暂时没有数据的情况下才会产生，在生产中经过检验在TPS没有上万的情况下是不会造成问题的。</p><h1>热点缓存解决方案</h1><h2>缓存使用背景</h2><p>我们拿用户中心的一个案例来说明：每个用户都会首先获取自己的用户信息，然后再进行其他相关的操作，有可能会有如下一些场景情况：</p><ul><li>会有大量相同用户重复访问该项目。</li><li>会有同一用户频繁访问同一模块。</li></ul><h2>思路解析</h2><ul><li>因为用户本身是不固定的而且用户数量也有几百万尤其上千万，我们不可能把所有的用户信息全部缓存起来，通过第一个场景情况可以看到一些规律，那就是有大量的相同用户重复访问，但是究竟是哪些用户重复访问我们也并不知道。</li><li>如果有一个用户频繁刷新读取项目，那么对数据库本身也会造成较大压力，当然我们也会有相关的保护机制来确实恶意攻击，可以从前端控制，也可以有采黑名单等机制，这里不在赘述。如果用缓存的话，我们又该如何控制同一用户繁重读取用户信息呢。</li></ul><p>请看下图：</p><p><img src="/2018/01/26/Redis缓存穿透、并发、失效/6.png" title="图片"></p><p>我们会通过缓存系统做一个排序队列，比如1000个用户，系统会根据用户的访问时间更新用户信息的时间，越是最近访问的用户排名越排前，系统会定期过滤掉排名最后的200个用户，然后再从数据库中随机取出200个用户加入队列，这样请求每次到达的时候，会先从队列中获取用户信息，如果命中则根据userId，再从另一个缓存数据结构中读取用户信息，如果没有命中则说明该用户请求频率不高。</p><h1>实现缓存最终一致性的二种方案</h1><h2>重客户端</h2><h3>写入缓存：</h3><p><img src="/2018/01/26/Redis缓存穿透、并发、失效/7.png" title="图片"></p><ul><li>应用同时更新数据库和缓存</li><li>如果数据库更新成功，则开始更新缓存，否则如果数据库更新失败，则整个更新过程失败。</li><li>判断更新缓存是否成功，如果成功则返回</li><li>如果缓存没有更新成功，则将数据发到MQ中</li><li>应用监控MQ通道，收到消息后继续更新Redis。</li></ul><p>**问题点：**如果更新Redis失败，同时在将数据发到MQ之前的时间，应用重启了，这时候MQ就没有需要更新的数据，如果Redis对所有数据没有设置过期时间，同时在读多写少的场景下，只能通过人工介入来更新缓存。</p><h3>读缓存：</h3><p>如何来解决这个问题？那么在写入Redis数据的时候，在数据中增加一个时间戳插入到Redis中。在从Redis中读取数据的时候，首先要判断一下当前时间有没有过期，如果没有则从缓存中读取，如果过期了则从数据库中读取最新数据覆盖当前Redis数据并更新时间戳。具体过程如下图所示：</p><p><img src="/2018/01/26/Redis缓存穿透、并发、失效/8.png" title="图片"></p><h2>客户端数据库与缓存解耦</h2><p>上述方案对于应用的研发人员来讲比较重，需要研发人员同时考虑数据库和Redis是否成功来做不同方案，如何让研发人员只关注数据库层面，而不用关心缓存层呢？请看下图：</p><p><img src="/2018/01/26/Redis缓存穿透、并发、失效/8.png" title="图片"></p><ul><li>应用直接写数据到数据库中。</li><li>数据库更新binlog日志。</li><li>利用Canal中间件读取binlog日志。</li><li>Canal借助于限流组件按频率将数据发到MQ中。</li><li>应用监控MQ通道，将MQ的数据更新到Redis缓存中。</li></ul><p>可以看到这种方案对研发人员来说比较轻量，不用关心缓存层面，而且这个方案虽然比较重，但是却容易形成统一的解决方案。</p><p>整理于：http://www.spring4all.com</p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis分布式锁及优化</title>
      <link href="/2018/01/17/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
      <url>/2018/01/17/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1>自身业务场景</h1><p>场景一: 我有一个数据服务，每天调用量在3亿，每天按86400秒计算的qps在4000左右，由于服务的白天调用量要明显高于晚上，所以白天下午的峰值qps达到6000的，一共有4台服务器，单台qps要能达到3000以上。<strong>我最终使用了redis的setnx()和expire()的分布式锁解决的问题。</strong></p><p>场景二:场景一变异版。在这个场景中，不涉及支付。但是由于资源分配一次过程中，需要保持涉及一致性的地方增加，而且一期的设计目标要达到峰值qps500，所以需要我们对场景进一步的优化。<strong>我最终使用了redis的setnx()、expire()和基于数据库表的分布式锁来解决的问题。</strong></p><h1>分布式锁的解决方式</h1><ol><li><p>首先明确一点，有人可能会问是否可以考虑采用ReentrantLock来实现，但是实际上去实现的时候是有问题的，ReentrantLock的lock和unlock要求必须是在同一线程进行，而分布式应用中，lock和unlock是两次不相关的请求，因此肯定不是同一线程，因此导致无法使用ReentrantLock。</p></li><li><p>基于数据库表做乐观锁，用于分布式锁。</p></li><li><p>使用memcached的add()方法，用于分布式锁。</p></li><li><p>使用memcached的cas()方法，用于分布式锁。(不常用)</p></li><li><p>使用redis的setnx()、expire()方法，用于分布式锁。</p></li><li><p>使用redis的setnx()、get()、getset()方法，用于分布式锁。</p></li><li><p>使用redis的watch、multi、exec命令，用于分布式锁。(不常用)</p></li><li><p>使用zookeeper，用于分布式锁。(不常用)</p></li></ol><p>这里着重讲Redis的分布式锁。</p><h1>使用redis的setnx()、expire()方法，用于分布式锁</h1><p>对于使用redis的setnx()、expire()来实现分布式锁，这个方案相对于memcached()的add()方案，redis占优势的是，其支持的数据类型更多，而memcached只支持String一种数据类型。除此之外，无论是从性能上来说，还是操作方便性来说，其实都没有太多的差异，完全看你的选择，比如公司中用哪个比较多，你就可以用哪个。</p><p>首先说明一下setnx()命令，setnx的含义就是SET if Not Exists，其主要有两个参数 setnx(key, value)。该方法是原子的，如果key不存在，则设置当前key成功，返回1；如果当前key已经存在，则设置当前key失败，返回0。但是要注意的是setnx命令不能设置key的超时时间，只能通过expire()来对key设置。</p><p>具体的使用步骤如下:</p><ol><li><p>setnx(lockkey, 1)  如果返回0，则说明占位失败；如果返回1，则说明占位成功</p></li><li><p>expire()命令对lockkey设置超时时间，为的是避免死锁问题。</p></li><li><p>执行完业务代码后，可以通过delete命令删除key。</p></li></ol><p>这个方案其实是可以解决日常工作中的需求的，但从技术方案的探讨上来说，可能还有一些可以完善的地方。比如，如果在第一步setnx执行成功后，在expire()命令执行成功前，发生了宕机的现象，那么就依然会出现死锁的问题，所以如果要对其进行完善的话，可以使用redis的setnx()、get()和getset()方法来实现分布式锁。</p><h1>使用redis的setnx()、get()、getset()方法，用于分布式锁</h1><p>这个方案的背景主要是在setnx()和expire()的方案上针对可能存在的死锁问题，做了一版优化。</p><p>那么先说明一下这三个命令，对于setnx()和get()这两个命令，相信不用再多说什么。那么getset()命令？这个命令主要有两个参数 getset(key，newValue)。该方法是原子的，对key设置newValue这个值，并且返回key原来的旧值。假设key原来是不存在的，那么多次执行这个命令，会出现下边的效果：</p><ol><li><p>getset(key, &quot;value1&quot;)  返回nil   此时key的值会被设置为value1</p></li><li><p>getset(key, &quot;value2&quot;)  返回value1   此时key的值会被设置为value2</p></li><li><p>依次类推！</p></li></ol><p>介绍完要使用的命令后，具体的使用步骤如下：</p><ol><li><p>setnx(lockkey, 当前时间+过期超时时间) ，如果返回1，则获取锁成功；如果返回0则没有获取到锁，转向2。</p></li><li><p>get(lockkey)获取值oldExpireTime ，并将这个value值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向3。</p></li><li><p>计算newExpireTime=当前时间+过期超时时间，然后getset(lockkey, newExpireTime) 会返回当前lockkey的值currentExpireTime。</p></li><li><p>判断currentExpireTime与oldExpireTime 是否相等，如果相等，说明当前getset设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。</p></li><li><p>在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行delete释放锁；如果大于锁设置的超时时间，则不需要再锁进行处理。</p></li></ol><p>但这套方案也会存在一些质疑点：</p><ol><li>在“get(lockkey)获取值oldExpireTime ”这个操作与“getset(lockkey, newExpireTime) ”这个操作之间，如果有N个线程在get操作获取到相同的oldExpireTime后，然后都去getset，会不会返回的newExpireTime都是一样的，都会是成功，进而都获取到锁？</li></ol><blockquote><p>我认为这套方案是不存在这个问题的。依据有两条: 第一，redis是单进程单线程模式，串行执行命令。 第二，在串行执行的前提条件下，getset之后会比较返回的currentExpireTime与oldExpireTime 是否相等。</p></blockquote><ol start="2"><li>在“get(lockkey)获取值oldExpireTime ”这个操作与“getset(lockkey, newExpireTime) ”这个操作之间，如果有N个线程在get操作获取到相同的oldExpireTime后，然后都去getset，假设第1个线程获取锁成功，其他锁获取失败，但是获取锁失败的线程它发起的getset命令确实执行了，这样会不会造成第一个获取锁的线程设置的锁超时时间一直在延长？</li></ol><blockquote><p>我认为这套方案确实存在这个问题的可能。但我个人认为这个微小的误差是可以忽略的，不过技术方案上存在缺陷，大家可以自行抉择。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 分布式 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hystrix隔离</title>
      <link href="/2018/01/04/Hystrix%E9%9A%94%E7%A6%BB/"/>
      <url>/2018/01/04/Hystrix%E9%9A%94%E7%A6%BB/</url>
      <content type="html"><![CDATA[<h1>什么是Hystrix</h1><p>Hystrix是Netflix开源的一款容错框架，包含常用的容错方法：线程池隔离、信号量隔离、熔断、降级回退。在高并发访问下，系统所依赖的服务的稳定性对系统的影响非常大，依赖有很多不可控的因素，比如网络连接变慢，资源突然繁忙，暂时不可用，服务脱机等。我们要构建稳定、可靠的分布式系统，就必须要有这样一套容错方法。本文将逐一分析线程池隔离、信号量隔离、熔断、降级回退这四种技术的原理与实践。</p><h2>线程隔离</h2><h3>为什么要做线程隔离</h3><p>比如我们现在有3个业务调用分别是查询订单、查询商品、查询用户，且这三个业务请求都是依赖第三方服务-订单服务、商品服务、用户服务。三个服务均是通过RPC调用。当查询订单服务，假如线程阻塞了，这个时候后续有大量的查询订单请求过来，那么容器中的线程数量则会持续增加直致CPU资源耗尽到100%，整个服务对外不可用，集群环境下就是雪崩。如下图</p><p><img src="/2018/01/04/Hystrix隔离/1.jpg" title="图片"><img src="/2018/01/04/Hystrix隔离/2.jpg" title="图片"></p><h3>线程隔离-线程池</h3><h4>Hystrix是如何通过线程池实现线程隔离的</h4><p>Hystrix通过命令模式，将每个类型的业务请求封装成对应的命令请求，比如查询订单-&gt;订单Command，查询商品-&gt;商品Command，查询用户-&gt;用户Command。每个类型的Command对应一个线程池。创建好的线程池是被放入到ConcurrentHashMap中，比如查询订单：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, HystrixThreadPool&gt; threadPools = <span class="keyword">new</span> ConcurrentHashMap&lt;String, HystrixThreadPool&gt;();</span><br><span class="line"></span><br><span class="line">threadPools.put(“hystrix-order”, <span class="keyword">new</span> HystrixThreadPoolDefault(threadPoolKey, propertiesBuilder));</span><br></pre></td></tr></table></figure></p><p>当第二次查询订单请求过来的时候，则可以直接从Map中获取该线程池。具体流程如下图：</p><p><img src="/2018/01/04/Hystrix隔离/3.jpg" title="图片"></p><h4>线程隔离-线程池小结</h4><p>执行依赖代码的线程与请求线程(比如Tomcat线程)分离，请求线程可以自由控制离开的时间，这也是我们通常说的异步编程，Hystrix是结合RxJava来实现的异步编程。通过设置线程池大小来控制并发访问量，当线程饱和的时候可以拒绝服务，防止依赖问题扩散。</p><p><img src="/2018/01/04/Hystrix隔离/4.jpg" title="图片"></p><h4>线程池隔离的优点</h4><ol><li>应用程序会被完全保护起来，即使依赖的一个服务的线程池满了，也不会影响到应用程序的其他部分。</li><li>我们给应用程序引入一个新的风险较低的客户端lib的时候，如果发生问题，也是在本lib中，并不会影响到其他内容，因此我们可以大胆的引入新lib库。</li><li>当依赖的一个失败的服务恢复正常时，应用程序会立即恢复正常的性能。</li><li>如果我们的应用程序一些参数配置错误了，线程池的运行状况将会很快显示出来，比如延迟、超时、拒绝等。同时可以通过动态属性实时执行来处理纠正错误的参数配置。</li><li>如果服务的性能有变化，从而需要调整，比如增加或者减少超时时间，更改重试次数，就可以通过线程池指标动态属性修改，而且不会影响到其他调用请求。</li><li>除了隔离优势外，hystrix拥有专门的线程池可提供内置的并发功能，使得可以在同步调用之上构建异步的外观模式，这样就可以很方便的做异步编程（Hystrix引入了Rxjava异步框架）。</li></ol><h4>线程池隔离的缺点</h4><ol><li>线程池的主要缺点是它增加了CPU，因为每个命令的执行涉及到排队（默认使用SynchronousQueue避免排队），调度和上下文切换。</li><li>对使用ThreadLocal等依赖线程状态的代码增加复杂性，需要手动传递和清理线程状态（Netflix公司内部认为线程隔离开销足够小，不会造成重大的成本或性能的影响）。</li></ol><blockquote><p>尽管线程池提供了线程隔离，我们的客户端底层代码也必须要有超时设置，不能无限制的阻塞以致线程池一直饱和。</p></blockquote><h3>线程隔离-信号量</h3><h4>线程隔离-信号量小结</h4><p>信号量隔离的方式是限制了总的并发数，每一次请求过来，请求线程和调用依赖服务的线程是同一个线程，那么如果不涉及远程RPC调用（没有网络开销）则使用信号量来隔离，更为轻量，开销更小。</p><h4>信号量隔离的优点</h4><ol><li>不新起线程执行命令，减少上下文切换。</li></ol><h4>信号量隔离的缺点</h4><ol><li>无法配置断路，每次都一定会去尝试获取信号量。</li></ol><h3>线程池和信号量的区别</h3><ol><li>线程隔离是和主线程无关的其他线程来运行的；而信号量隔离是和主线程在同一个线程上做的操作。</li><li>信号量隔离也可以用于限制并发访问，防止阻塞扩散，与线程隔离的最大不同在于执行依赖代码的线程依然是请求线程。</li><li>线程池隔离适用于第三方应用或者接口、并发量大的隔离；信号量隔离适用于内部应用或者中间件；并发需求不是很大的场景。</li></ol>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Hystrix </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>gradle+jenkins+compose自动化集成持续交付</title>
      <link href="/2017/12/06/gradle+jenkins+compose%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9B%86%E6%88%90%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/"/>
      <url>/2017/12/06/gradle+jenkins+compose%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9B%86%E6%88%90%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/</url>
      <content type="html"><![CDATA[<h2>简介</h2><p>本文将介绍如何使用本地搭建的jenkins自动化持续集成工具，配合Docker swarm去为Docker容器进行编排、提供集群服务，线上发布、部署。</p><p>以下操作全部在阿里云容器服务中进行。使用阿里云容器服务的原因是：可以省去一些运维、维护的人力成本。</p><h2>背景</h2><p>公司开发产品使用的是spring cloud微服务技术栈，线上需要使用Docker对各个单独的模块服务进行容器化部署，Docker技术发展为微服务落地提供了更加便利的环境,而Docker Swarm<br>&lt;!--more--&gt;是 Docker 官方三剑客项目之一，提供 Docker 容器集群服务，是 Docker 官方对容器云生态进行支持的核心方案，便于我们日后对应用进行垂直扩展，弹性伸缩。</p><h2>难题</h2><ol><li>部署步骤繁琐。 --&gt;  <strong>jenkins</strong>需要将项目编译打包，构建镜像、登陆Docker仓库，tag镜像，最后再push上去。过程中还会参杂着其他的备份，替换等各种命令。</li></ol><ol start="2"><li>编排时，容器服务中的配置信息的统一/差异化。 --&gt; <strong>Docker Compose</strong>由于我们使用Docker swarm对容器进行编排，集群部署，将多个 Docker 主机封装为单个大型的虚拟 Docker 主机，于是需要根据业务对容器中的配置信息进行统一/差异化。比如一组容器服务由三个容器集群组成，但是我们其中一个容器里面的应用的DataBase配置需要跟其他两个不一样。</li></ol><ol start="3"><li>热更新困难。 --&gt; <strong>蓝绿发布</strong>版本迭代的时候，需要对线上应用进行热发布更新，即更新过程中不能对用户产生影响或影响可忽略。</li></ol><h2>操作步骤</h2><ol start="0"><li><p>在Jenkins中新建项目</p></li><li><p>打开 Jenkins</p><p>进入项目配置页面</p><p><img src="/2017/12/06/gradle+jenkins+compose自动化集成持续交付/1.png" title="图片"></p></li><li><p>更改镜像版本号(如不更改，则原镜像版本会变为null)</p></li></ol><p><img src="/2017/12/06/gradle+jenkins+compose自动化集成持续交付/2.png" title="图片"></p><ol start="3"><li>点击立即构建</li></ol><p><img src="/2017/12/06/gradle+jenkins+compose自动化集成持续交付/3.png" title="图片"></p><ol start="4"><li>进入阿里云容器服务控制台,点击order-service的变更配置</li></ol><p><img src="/2017/12/06/gradle+jenkins+compose自动化集成持续交付/4.png" title="图片"></p><ol start="5"><li>更新前的编排文件：</li></ol><p><img src="/2017/12/06/gradle+jenkins+compose自动化集成持续交付/5.png" title="图片"></p><ol start="6"><li>更新后的编排文件:</li></ol><p><img src="/2017/12/06/gradle+jenkins+compose自动化集成持续交付/6.png" title="图片"></p><ol start="7"><li>点击确定</li></ol><p>进入应用详情。</p><p><img src="/2017/12/06/gradle+jenkins+compose自动化集成持续交付/7.png" title="图片"></p><p>如果发现新发布服务失败，则点击该失败服务的变更配置。勾选restart:always，然后更新即可。</p><p>查看新应用的容器列表里面的端口映射，可在路由列表，将流量全部切换到新版本进行初步测试。</p><p><img src="/2017/12/06/gradle+jenkins+compose自动化集成持续交付/8.png" title="图片"></p><p>查看节点公网ip：</p><p><img src="/2017/12/06/gradle+jenkins+compose自动化集成持续交付/9.png" title="图片"></p><p>测试完成后选择确认蓝绿发布新应用</p><p><img src="/2017/12/06/gradle+jenkins+compose自动化集成持续交付/10.png" title="图片"></p><ol start="8"><li><p>注意事项</p><p>docker相关都在/var/lib/docker</p><p>定期 df -sh *，free一下，关注磁盘和内存状态，及时清理无用的docker挂载数据卷。</p><blockquote><p><code>for i in `find . -name &quot;*.log&quot;`; do cat /dev/null &gt;$i; done</code></p></blockquote><p>清空文件名以log为后缀的日志</p><blockquote><p>docker rm $(docker ps -a -q)</p></blockquote><p>删除所有未运行 Docker 容器</p><blockquote><p>docker images|grep none|awk '{print $3}'|xargs docker rmi</p></blockquote><p>批量删除 tag为none的镜像</p></li></ol><h3>application.yml DEMO</h3><p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="string">$&#123;ADDITIONAL_TOOL_SERVER_PORT&#125;</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="string">$&#123;ADDITIONAL_EUREKA_SERVER_LIST&#125;</span></span><br><span class="line"><span class="string">logging.level.project.user.UserClient:</span> <span class="string">INFO</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">   datasource:</span></span><br><span class="line"><span class="attr">     url:</span> <span class="string">$&#123;DATABASE_URL&#125;</span></span><br><span class="line"><span class="attr">     username:</span>  <span class="string">$&#123;DATABASE_USERNAME&#125;</span></span><br><span class="line"><span class="attr">     password:</span>  <span class="string">$&#123;DATABASE_PASSWORD&#125;</span></span><br><span class="line"><span class="attr">   redis:</span></span><br><span class="line"><span class="attr">    database:</span> <span class="string">$&#123;REDIS_DATABASE&#125;</span></span><br><span class="line"><span class="attr">    host:</span>  <span class="string">$&#123;REDIS_HOST&#125;</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">$&#123;REDIS_PASSWORD&#125;</span></span><br><span class="line"><span class="attr">    port:</span> <span class="string">$&#123;REDIS_PORT&#125;</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="string">$&#123;REDIS_TIMEOUT&#125;</span></span><br><span class="line"><span class="attr">    pool:</span></span><br><span class="line"><span class="attr">      max-idle:</span> <span class="string">$&#123;REDIS_MAX_IDLE&#125;</span></span><br><span class="line"><span class="attr">      min-idle:</span> <span class="string">$&#123;REDIS_MIN_IDLE&#125;</span></span><br><span class="line"><span class="attr">      max-active:</span> <span class="string">$&#123;REDIS_MAX_ACTIVE&#125;</span></span><br><span class="line"><span class="attr">      max-wait:</span> <span class="string">$&#123;REDIS_MAX_WAIT&#125;</span></span><br></pre></td></tr></table></figure></p><h3>docker-compose.yml DEMO</h3><p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  tool-app1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">registry.cn-shenzhen.aliyuncs.com/zwx_cloud/tool-app:1.0.0</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">tool-app1</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"10086:10086"</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line">      <span class="string">aliyun.routing.port_10086:</span> <span class="string">tool-app</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ADDITIONAL_TOOL_SERVER_PORT=10106</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ADDITIONAL_EUREKA_SERVER_LIST=http://eureka1:10011/eureka/,http://eureka2:10012/eureka/,http://eureka3:10013/eureka/</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">DATABASE_URL=jdbc:mysql://123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">DATABASE_USERNAME=123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">DATABASE_PASSWORD=123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_DATABASE=1</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_HOST=123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_PASSWORD=123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_PORT=123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_TIMEOUT=500</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_MAX_IDLE=20</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_MIN_IDLE=8</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_MAX_ACTIVE=20</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_MAX_WAIT=-1</span></span><br><span class="line"><span class="attr">  tool-app2:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">registry.cn-shenzhen.aliyuncs.com/zwx_cloud/tool-app:1.0.0</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">tool-app2</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"10096:10096"</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line">      <span class="string">aliyun.routing.port_10096:</span> <span class="string">tool-app</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ADDITIONAL_TOOL_SERVER_PORT=10106</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ADDITIONAL_EUREKA_SERVER_LIST=http://eureka1:10011/eureka/,http://eureka2:10012/eureka/,http://eureka3:10013/eureka/</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">DATABASE_URL=jdbc:mysql://123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">DATABASE_USERNAME=123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">DATABASE_PASSWORD=123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_DATABASE=1</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_HOST=123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_PASSWORD=123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_PORT=123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_TIMEOUT=500</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_MAX_IDLE=20</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_MIN_IDLE=8</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_MAX_ACTIVE=20</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_MAX_WAIT=-1</span></span><br><span class="line"><span class="attr">  tool-app3:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">registry.cn-shenzhen.aliyuncs.com/zwx_cloud/tool-app:1.0.0</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">tool-app3</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"10106:10106"</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line">      <span class="string">aliyun.routing.port_10106:</span> <span class="string">tool-app</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ADDITIONAL_TOOL_SERVER_PORT=10106</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ADDITIONAL_EUREKA_SERVER_LIST=http://eureka1:10011/eureka/,http://eureka2:10012/eureka/,http://eureka3:10013/eureka/</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">DATABASE_URL=jdbc:mysql://123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">DATABASE_USERNAME=123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">DATABASE_PASSWORD=123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_DATABASE=1</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_HOST=123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_PASSWORD=123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_PORT=123</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_TIMEOUT=500</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_MAX_IDLE=20</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_MIN_IDLE=8</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_MAX_ACTIVE=20</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">REDIS_MAX_WAIT=-1</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
            <tag> 分布式 </tag>
            
            <tag> Gradle </tag>
            
            <tag> Jenkins </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql分库分表、主从复制简介</title>
      <link href="/2017/12/02/Mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/12/02/Mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1>分库分表</h1><p>描述：分库分表是一种水平数据拆分，会按照如ID，用户，时间等维度进行数据拆分，拆分算法可以使取模，hash，区间或者使用数据路由表等。问题：跨库跨表join，排序分页，自增ID，分布式事务等问题解决方案：对于跨库跨表join和排序分页：可以对所有表进行扫描然后做聚合，或者生成全局表、进行查询维度的数据异构（比如，订单库按照查询维度异构出商家订单库，用户订单库），再或者将数据同步到ES搜索。自增ID问题可以通过分布式ID生成器解决。尽量避免分布式事务。</p><h2>ObjectId 规则</h2><p>[0,1,2,3] [4,5,6] [7,8] [9,10,11]时间戳 |机器码 |PID |计数器前四位是时间戳，可以提供秒级别的唯一性。接下来三位是所在主机的唯一标识符，通常是机器主机名的散列值。接下来两位是产生ObjectId的PID，确保同一台机器上并发产生的ObjectId是唯一的。前九位保证了同一秒钟不同机器的不同进程产生的ObjectId时唯一的。最后三位是自增计数器，确保相同进程同一秒钟产生的ObjectId是唯一的。https://github.com/qianjiahao/MongoDB/wiki/MongoDB%E4%B9%8B_id%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99</p><h2>选择合适的分布式主键方案</h2><ol><li>数据库自增长序列或字段</li><li>UUID</li><li>使用UUID to Int64的方法</li><li>Redis生成ID</li><li>Twitter的snowflake算法</li><li>利用zookeeper生成唯一ID</li><li>MongoDB的ObjectId</li></ol><p>因此，业务设计上，如果找到一条降低一致性要求时，还能保证业务的正确性的业务分拆之路。举个例子，火车票查询时，不要显示多少张，而是显示“有”或“无”，或者显示&gt;100张，50~100,小于50等，这样就可以减小状态的更新频率，充分使用缓存数据。</p><h1>说说分库与分表设计</h1><p>垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中。在字段很多的情况下，拆分开确实更便于开发和维护（笔者曾见过某个遗留系统中，一个大表中包含100多列的）。某种意义上也能避免“跨页”的问题（MySQL、MSSQL底层都是通过“数据页”来存储的，“跨页”问题可能会造成额外的性能开销，拆分字段的操作建议在数据库设计阶段就做好。如果是在发展过程中拆分，则需要改写以前的查询语句，会额外带来一定的成本和风险，建议谨慎。垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。系统层面的“服务化”拆分操作，能够解决业务系统层面的耦合和性能瓶颈，有利于系统的扩展维护。而数据库层面的拆分，道理也是相通的。与服务的“治理”和“降级”机制类似，我们也能对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。众所周知，数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。然后，很多人并没有从根本上搞清楚为什么要拆分，也没有掌握拆分的原则和技巧，只是一味的模仿大厂的做法。导致拆分后遇到很多问题（例如：跨库join，分布式事务等）。水平分表也称为横向分表，比较容易理解，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。水平分表，能够降低单表的数据量，一定程度上可以缓解查询性能瓶颈。但本质上这些表还保存在同一个库中，所以库级别还是会有IO瓶颈。所以，一般不建议采用这种做法。水平分库分表与上面讲到的水平分表的思想相同，唯一不同的就是将这些拆分出来的表保存在不同的数据中。这也是很多大型互联网公司所选择的做法。某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）。</p><p>以上摘抄自： http://www.infoq.com/cn/articles/key-steps-and-likely-problems-of-split-table</p><h1>分库与分表带来的分布式困境与应对之策</h1><p>数据迁移与扩容问题前面介绍到水平分表策略归纳总结为随机分表和连续分表两种情况。连续分表有可能存在数据热点的问题，有些表可能会被频繁地查询从而造成较大压力，热数据的表就成为了整个库的瓶颈，而有些表可能存的是历史数据，很少需要被查询到。连续分表的另外一个好处在于比较容易，不需要考虑迁移旧的数据，只需要添加分表就可以自动扩容。随机分表的数据相对比较均匀，不容易出现热点和并发访问的瓶颈。但是，分表扩展需要迁移旧的数据。针对于水平分表的设计至关重要，需要评估中短期内业务的增长速度，对当前的数据量进行容量规划，综合成本因素，推算出大概需要多少分片。对于数据迁移的问题，一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。表关联问题在单库单表的情况下，联合查询是非常容易的。但是，随着分库与分表的演变，联合查询就遇到跨库关联和跨表关系问题。在设计之初就应该尽量避免联合查询，可以通过程序中进行拼装，或者通过反范式化设计进行规避。分页与排序问题一般情况下，列表分页时需要按照指定字段进行排序。在单库单表的情况下，分页和排序也是非常容易的。但是，随着分库与分表的演变，也会遇到跨库排序和跨表排序问题。为了最终结果的准确性，需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。分布式事务问题随着分库与分表的演变，一定会遇到分布式事务问题，那么如何保证数据的一致性就成为一个必须面对的问题。目前，分布式事务并没有很好的解决方案，难以满足数据强一致性，一般情况下，使存储数据尽可能达到用户一致，保证系统经过一段较短的时间的自我恢复和修正，数据最终达到一致。分布式全局唯一ID在单库单表的情况下，直接使用数据库自增特性来生成主键ID，这样确实比较简单。在分库分表的环境中，数据分布在不同的分表上，不能再借助数据库自增长特性。需要使用全局唯一 ID，例如 UUID、GUID等。关于如何选择合适的全局唯一 ID，我会在后面的章节中进行介绍。</p><p>摘抄自：http://blog.csdn.net/jiangpingjiangping/article/details/78069480</p><h1>主从复制/读写分离</h1><ol><li>master数据库将变更记录写入binlog。</li><li>slave数据库订阅binlog日志，通过io线程从binlog的指定位置拉去日志进行主从同步，此时master会有一个Binlog Dump线程来读取binlog日志与slave io线程进行数据同步。</li><li>slave io线程读取到日志后会先写入relay log重放日志中。</li><li>slave数据库会通过一个sql线程读取relay log进行日志重放，这样就实现了主从数据库之间的同步。</li><li>读slave,写master.</li></ol>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql死锁的产生和解决</title>
      <link href="/2017/11/29/Mysql%E6%AD%BB%E9%94%81%E7%9A%84%E4%BA%A7%E7%94%9F%E5%92%8C%E8%A7%A3%E5%86%B3/"/>
      <url>/2017/11/29/Mysql%E6%AD%BB%E9%94%81%E7%9A%84%E4%BA%A7%E7%94%9F%E5%92%8C%E8%A7%A3%E5%86%B3/</url>
      <content type="html"><![CDATA[<h1>产生死锁的四个必要条件：</h1><ol><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。下列方法有助于最大限度地降低死锁：</p><ol><li>按同一顺序访问对象。</li><li>避免事务中的用户交互。</li><li>保持事务简短并在一个批处理中。</li><li>使用低隔离级别。</li><li>使用绑定连接。</li></ol><h1>数据库常见死锁原因及处理</h1><ol><li>事务之间对资源访问顺序的交替</li></ol><p><strong>出现原因：</strong>一个用户A 访问表A（锁住了表A），然后又访问表B；另一个用户B 访问表B（锁住了表B），然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。</p><p><strong>解决方法：</strong>这种死锁比较常见，是由于程序的BUG产生的</p><ol start="2"><li>并发修改同一记录</li></ol><p><strong>出现原因：</strong>用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。这种死锁由于比较隐蔽，但在稍大点的项目中经常发生。</p><p><strong>解决方法：</strong></p><ol><li>使用乐观锁进行控制。(cas:预期值，内存值，新值)</li><li>使用悲观锁进行控制。(mysql:setAutoCommit=0，select...for update)</li></ol>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql索引详解</title>
      <link href="/2017/11/28/Mysql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/11/28/Mysql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1>数据库索引</h1><p>是数据库管理系统中一个排序的数据结构，以协助快速查询，更新数据库表中数据，索引的实现通常使用B树（所有节点的平衡因子均为0的多叉查找树）及其变种B+树 。B+树特点是,只有在最低节点保存数据本身。节点保存主键。</p><h1>存储引擎比较</h1><ul><li><p>InnoDB: 写多读少，支持事务，不加锁读取，支持外键，支持行锁（where对主键的支持，select count(*)和order by 还是会锁表），不支持全文索引，InnoDB把数据核索引存放在表空间里面</p></li><li><p>MyISAM: 读多写少，不支持事务，不支持外键，支持全文搜索，count()查询更快，MyISAM索引和数据是分开的，并且索引是有压缩的，提高内存使用率，能加载更多索引</p></li></ul><ol><li><p>InnoDB 中不保存表的具体行数，也就是说，执行select count() from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含 where条件时，两种表的操作是一样的。</p></li><li><p>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</p></li><li><p>DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。</p></li><li><p>LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</p><p>另外，InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”</p></li></ol><h1>索引在不同存储引擎中的比较</h1><h2>InnoDB</h2><p><img src="/2017/11/28/Mysql索引详解/002.png" title="图片"></p><p><img src="/2017/11/28/Mysql索引详解/003.png" title="图片"></p><h2>MyISAM</h2><p><img src="/2017/11/28/Mysql索引详解/001.png" title="图片"></p><h1>数据库索引的原理</h1><p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p><ul><li>为什么要用 B-tree</li></ul><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。</p><ul><li>聚集索引与非聚集索引的区别</li></ul><ol><li><p>聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个</p></li><li><p>聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续</p></li><li><p>聚集索引:物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序</p><p>非聚集索引:物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序.</p></li><li><p>索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</p></li></ol><h1>索引的数据结构</h1><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。<strong>一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</strong></p><p><img src="/2017/11/28/Mysql索引详解/004.jpg" title="图片"></p><p>上图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。创建索引可以大大提高系统的性能。</p><ol><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ol><h1>为什么不对表中的每一个列创建一个索引呢</h1><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ol><h2>应该在这些列上建立索引</h2><ol><li>在经常需要搜索的列上，可以加快搜索的速度</li><li>在作为主键的列上，强制该列的唯一性和组织表中的排列结构</li><li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度</li><li>在需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的。</li><li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询的时间。</li><li>在经常使用where子句中的列上面创建索引，加快条件的判断速度。</li></ol>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>锁与事务的问答对话</title>
      <link href="/2017/11/27/%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%97%AE%E7%AD%94%E5%AF%B9%E8%AF%9D/"/>
      <url>/2017/11/27/%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%97%AE%E7%AD%94%E5%AF%B9%E8%AF%9D/</url>
      <content type="html"><![CDATA[<h1>简介</h1><p>以通俗的语言和说法，让大家更好的理解锁和事务之间的关系以及相关概念。</p><h1>描述</h1><ul><li>什么是锁?（先发制人）</li></ul><p>一种保护机制，在多线程的情况下，保证操作数据的正确性/一致性，</p><ul><li>眼镜男：有哪几种分类？</li></ul><p>悲观锁，乐观锁，独占锁，共享锁，公平锁，非公平锁，分布式锁，自旋锁</p><ul><li>讲讲乐观锁悲观锁吧（顺藤摸瓜）</li></ul><p>一般喜欢放在数据库来讲(其实这两个概念是属于计算机的，不要被误导)，就说mysql吧，悲观锁，主要是表锁，行锁还有间隙锁，叶锁，读锁，因为这些锁在被触发的时候势必引起线程阻塞，所以叫悲观另外乐观锁其实在mysql本身中不存在的，但是mysql提供了种mvcc的机制，支持乐观锁机制，</p><ul><li>mvcc是咋回事？（诱敌深入）</li></ul><p>只是在innodb引擎下存在，mvcc是为了满足事务的隔离，通过版本号的方式，避免同一数据不同事务间的竞争，所说的乐观锁只在事务级别为读未提交读提交，才会生效。</p><ul><li>具体mvcc机制有什么？（穷追不舍）</li></ul><p>多版本并发控制，保证数据操作在多线程过程中，保证事务隔离的机制，可以降低锁竞争的压力，保证比较高并发量，这个过程。在每开启一个事务时，会生成一个事务的版本号，被操作的数据会生成一条新的数据行（临时），但是在提交前对其他事务是不可见的，对于数据的更新操作成功，会将这个版本号更新到数据的行中,事务提交成功，将新的版本号，更新到此数据行（永久）中，这样保证了每个事务操作的数据，都是相互不影响的，也不存在锁的问题；</p><ul><li>那么在多个事务（操作同一条数据）并发过程中，谁先成功?</li></ul><p>mysql判断，其实就是谁先提交成功算谁的</p><ul><li>说到事务了，聊聊事务，</li></ul><p>事务常说一系列操作作为一个整体要么都成功要么都失败，主要特性acid，事务的的实现主要依赖两个log redo-log,undo-log,每次事务都会记录数据修改前的数据undo-log，修改后的数据放入redo-log,提出成功则使用redo-log 更新到磁盘，失败则使用undo-log将数据恢复到事务之前的数据</p><p>眼镜男，嗯，再说说独占锁，共享锁吧（转移阵地）（嗯，独占，共享，公平，非公平，自旋锁这些都是广泛的概念，很多语言都有，包括操作系统，js的同学请回避）独占锁很明显就是持锁的线程只能有一个，共享锁则可以有多个</p><ul><li>独占可以理解，共享的意义在哪里？</li></ul><p>共享锁是为了提高程序的效率，举个例子数据的操作有读写之分，对于写的操作加锁，保证数据正确性，而对于读的操作如果不加锁，在写读操作同时进行时，读的数据有可能不是最新数据，如果对读操作加独占锁，面对读多写少的程序肯定效率很低，所有就出现了共享锁，对于读的的操作就使用共享的概念，但是对于写的操作则是互斥的，保证了读写的数据操作都一致，在java中上述的锁叫读写锁</p><ul><li>读写锁的机制是什么呢？（佯攻）</li></ul><p>在java中读写锁（ReadWritelock）的机制是基于AQS的一种实现，保证读读共享，读写互斥，写写互斥，如果要说机制的话，还要从AQS说起，这是java实现的一种锁机制，互斥锁，读者写锁，条件产量，信号量，栅栏的都是它的衍生物，主要工作基于CHL队列，voliate关键字修饰的状态符stat，线程去修改状态符成功了就是获取成功，失败了就进队列等待，等待唤醒，AQS中还有很重要的一个概念是自旋，在等待唤醒的时候，很多时候会使用自旋（while（!cas()））的方式，不停的尝试获取锁，直到被其他线程获取成功共享与独占的区别就在于，CHL队列中的节点的模式是EXCLUSIVE还是SHARED，当一个线程成功修改了stat状态，表示获取了锁，如果线程所在的节点为SHARED，将开始一个读锁传递的过程，从头结点，向队列后续节点传递唤醒，直到队列结束或者遇到了EXCLUSIVE的节点，等待所有激活的读操作完成，然后进入到独享模式（这部分尽力了，大家还是看源码）公平与非公平的区别就在于线程第一次获取锁时，也就是执行修改stat操作时，是进队列还是直接修改状态，这是基本的工作机制，详细的估计可以再聊好几集</p><ul><li>java 除了AQS 还有其他的锁支持么（佯攻未遂，寻找突破）</li></ul><p>在java中，synchronized关键字，是语言自带的，也叫内置锁，synchronized关键字，我们都知道被synchronized修饰的方法或者代码块，在同一时间内，只允许一个线程执行，是明显的独享锁，synchronized的实现机制？可以参考AQS的实现方式，只是AQS使用显示的用lock.lock()调用，而sync作为关键字修饰，你可以认为在synchronized修饰的地方，自动添加了lock方法，结束的地方进行了unlock释放锁的方法，只是被隐藏了，我们看不到。它本身实现有两部分：monitor对象，线程，工作机制还是线程抢占对象使用权，对象都有自己的对象头，存储了对象的很多信息，其中有一个是标识被哪个线程持有，对比AQS，线程从修改stat，变为修改monitor的对象头，线程的等待区域动 AQS中的队列，变为monitor对象中的某个区域，</p><ul><li>能细说么？（贴脸）</li></ul><p>锁一直是围绕线程安全来实现的，比如独占锁，它在内存里面的操作是怎么样的这个地方涉及到一个概念，内存模型（这个和jvm不要混淆，The Java memory model used internally in the JVM divides memory between thread stacks and the heap. This diagram illustrates the Java memory model from a logic perspective），是JVM用来区别线程栈和堆的内存方式，每个线程在运行的时候，所操作的数据存储空间有两个，一个是主内存 一个是工作内存，主内存其实就是jvm中堆，工作内存就是线程的栈，每次的数据操作，都是从主内存中把数据读到工作内存中，然后在工作内存中进行各种处理，如果进行了修改，会把数据回写到主内存，然后其他线程又进行同样的操作，就这样数据在工作内存和主内存，进进出出，不亦乐乎，在多次的情况下，就是因为进进出出的顺序乱了，不是按照线程预期的访问顺序，就出现了数据不一致的问题，导致了多线程的不安全性；整个操作过程还牵涉到CPU，高速缓存等概念，略过。。。。</p><ul><li>内存模型 还有哪些可以聊聊的（我们是抱着学习的心态）</li></ul><p>happen-befor 原则，Volatile 关键字（线程的可见性），内存屏障</p><ul><li>哦（怂了怂了）</li></ul><p>happen-befor原则定义了内存模型执行过程中的定律，就像1+1 = 2，不可能被打破的jvm的运行机制都依赖于这个原则，是jvm的宪法！！！Volatile关键字就有点叼了，Volatile修饰的数据，在被某个线程修改后，会被及时的回写到主内存，然后其他线程再获取时，就是新的数据，听起来很美好，但是Volatile没有办法控制线程的顺序，当一个数据（新数据）即将被修改到主内存时，刚好，另外一个线程从主内存读了数据（老数据），并又进行了一波操作，又将数据(更新的数据)回写到了主内存，整个过程（新数据）完全没有起到一毛钱作用，最终导致了数据的错误，呼呼打完收工！！！！</p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql索引注意事项以及关键字优化</title>
      <link href="/2017/11/25/Mysql%E7%B4%A2%E5%BC%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%BB%A5%E5%8F%8A%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%98%E5%8C%96/"/>
      <url>/2017/11/25/Mysql%E7%B4%A2%E5%BC%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%BB%A5%E5%8F%8A%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1>MySQL 索引使用的注意事项</h1><ol><li><p>索引不会包含有NULL的列只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的。</p></li><li><p>使用短索引对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</p></li><li><p>索引列排序mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。</p></li><li><p>like语句操作一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。like ‘%aaa%’不会使用索引，而like ‘aaa%’可以使用索引。</p></li><li><p>不要在列上进行运算</p></li><li><p>不使用NOT IN 、&lt;&gt;、！=操作，但&lt;,&lt;=，=，&gt;,&gt;=,BETWEEN,IN是可以用到索引的</p></li><li><p>索引要建立在经常进行select操作的字段上。</p></li></ol><blockquote><p>这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p></blockquote><ol start="8"><li>索引要建立在值比较唯一的字段上。</li><li>对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少。</li><li>在where和join中出现的列需要建立索引。</li><li>where的查询条件里有不等号(where column != …),mysql将无法使用索引。</li><li>如果where字句的查询条件里使用了函数(如：where DAY(column)=…),mysql将无法使用索引。</li><li>在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用。</li></ol><h1>关键字优化</h1><h2>In关键字原理</h2><p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`user`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> <span class="string">`order`</span>)</span><br></pre></td></tr></table></figure></p><ul><li>in()语句只会执行一次，它查出order表中的所有user_id字段并且缓存起来，之后，检查user表的id是否和order表中的user_id相当，如果相等则加入结果期，直到遍历完user的所有记录。</li><li>in的查询过程类似于以下过程</li></ul><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>result = [];</span><br><span class="line"><span class="meta">$</span>users = "SELECT * FROM `user`";</span><br><span class="line"><span class="meta">$</span>orders = "SELECT user_id FROM `order`";</span><br><span class="line"><span class="meta">for($</span>i = 0;$i &lt; $users.length;$i++)&#123;</span><br><span class="line">    for($j = 0;$j &lt; $orders.length;$j++)&#123;</span><br><span class="line">    // 此过程为内存操作，不涉及数据库查询。</span><br><span class="line">        if($users[$i].id == $orders[$j].user_id)&#123;</span><br><span class="line">            $result[] = $users[$i];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>我想你已经看出来了，当order表数据很大的时候不适合用in，因为它最多会将order表数据全部遍历一次。</p><p>如：user表有10000条记录,order表有1000000条记录,那么最多有可能遍历10000*1000000次,效率很差.</p><p>再如：user表有10000条记录,order表有100条记录,那么最多有可能遍历10000*100次,遍历次数大大减少,效率大大提升.</p></li></ul><h2>exists关键字原理</h2><p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`user`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">exists</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`order`</span> <span class="keyword">WHERE</span> user.id = order.user_id)</span><br></pre></td></tr></table></figure></p><ul><li>在这里，exists语句会执行user.length次，它并不会去缓存exists的结果集，因为这个结果集并不重要，你只需要返回真假即可。</li><li>exists的查询过程类似于以下过程</li></ul><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>result = [];</span><br><span class="line"><span class="meta">$</span>users = "SELECT * FROM `user`";</span><br><span class="line"><span class="meta">for($</span>i=0;$i&lt;$users.length;$i++)&#123;</span><br><span class="line">    if(exists($users[$i].id))&#123;// 执行SELECT * FROM `order` WHERE user.id = order.user_id</span><br><span class="line">        $result[] = $users[$i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>你看到了吧，当order表比user表大很多的时候，使用exists是再恰当不过了，它没有那么多遍历操作,只需要再执行一次查询就行。</p><p>如:user表有10000条记录,order表有1000000条记录,那么exists()会执行10000次去判断user表中的id是否与order表中的user_id相等.</p><p>如:user表有10000条记录,order表有100000000条记录,那么exists()还是执行10000次,因为它只执行user.length次,可见B表数据越多,越适合exists()发挥效果.</p><p><strong>但是</strong>：user表有10000条记录,order表有100条记录,那么exists()还是执行10000次,还不如使用in()遍历10000*100次,因为in()是在内存里遍历,而exists()需要查询数据库,我们都知道查询数据库所消耗的性能更高,而内存比较很快.</p><p>因此我们只需要记住口诀：“外层查询表小于子查询表，则用exists，外层查询表大于子查询表，则用in，如果外层和子查询表差不多，则爱用哪个用哪个。”</p></li></ul><h1>说说 SQL 优化之道</h1><h2>一些常见的SQL实践</h2><ol><li>负向条件查询不能使用索引</li></ol><blockquote><p>select from order where status!=0 and stauts!=1not in/not exists都不是好习惯</p></blockquote><p>可以优化为in查询：</p><blockquote><p>select from order where status in(2,3)</p></blockquote><ol start="2"><li>前导模糊查询不能使用索引</li></ol><blockquote><p>select from order where desc like '%XX'</p></blockquote><p>而非前导模糊查询则可以：</p><blockquote><p>select from order where desc like 'XX%'</p></blockquote><ol start="3"><li>数据区分度不大的字段不宜使用索引</li></ol><blockquote><p>select from user where sex=1</p></blockquote><p>原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。<br>经验上，能过滤80%数据时就可以使用索引。对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，则应该建立索引。</p><ol start="4"><li>在属性上进行计算不能命中索引</li></ol><blockquote><p>select from order where YEAR(date) &lt; = '2017'</p></blockquote><p>即使date上建立了索引，也会全表扫描，可优化为值计算：</p><blockquote><p>select from order where date &lt; = CURDATE()</p></blockquote><p>或者：</p><blockquote><p>select from order where date &lt; = '2017-01-01'</p></blockquote><h2>并非周知的SQL实践</h2><ol start="5"><li>如果业务大部分是单条查询，使用Hash索引性能更好，例如用户中心</li></ol><blockquote><p>select from user where uid=?select from user where login_name=?</p></blockquote><p>原因：B-Tree索引的时间复杂度是O(log(n))；Hash索引的时间复杂度是O(1)</p><ol start="6"><li>允许为null的列，查询有潜在大坑单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集</li></ol><blockquote><p>select from user where name != 'shenjian'</p></blockquote><p>如果name允许为null，索引不存储null值，结果集中不会包含这些记录。所以，请使用not null约束以及默认值。</p><ol start="7"><li>复合索引最左前缀，并不是值SQL语句的where顺序要和复合索引一致用户中心建立了(login_name, passwd)的复合索引</li></ol><blockquote><p>select from user where login_name=? and passwd=?select from user where passwd=? and login_name=?</p></blockquote><p>都能够命中索引</p><blockquote><p>select from user where login_name=?</p></blockquote><p>也能命中索引，满足复合索引最左前缀</p><blockquote><p>select from user where passwd=?</p></blockquote><p>不能命中索引，不满足复合索引最左前缀</p><ol start="8"><li>使用ENUM而不是字符串ENUM保存的是TINYINT，别在枚举中搞一些“中国”“北京”“技术部”这样的字符串，字符串空间又大，效率又低。</li></ol><h2>小众但有用的SQL实践</h2><ol start="9"><li>如果明确知道只有一条结果返回，limit 1能够提高效率</li></ol><blockquote><p>select from user where login_name=?</p></blockquote><p>可以优化为：</p><blockquote><p>select from user where login_name=? limit 1</p></blockquote><p>原因：你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动</p><ol start="10"><li>把计算放到业务层而不是数据库层，除了节省数据的CPU，还有意想不到的查询缓存优化效果</li></ol><blockquote><p>select from order where date &lt; = CURDATE()</p></blockquote><p>这不是一个好的SQL实践，应该优化为：</p><blockquote><p>$curDate = date('Y-m-d');$res = mysqlquery('select from order where date &lt; = $curDate');</p></blockquote><p>原因：释放了数据库的CPU多次调用，传入的SQL相同，才可以利用查询缓存</p><ol start="11"><li>强制类型转换会全表扫描</li></ol><blockquote><p>select from user where phone=13800001234</p></blockquote><p>你以为会命中phone索引么？大错特错了，这个语句究竟要怎么改？末了，再加一条，不要使用select *（潜台词，文章的SQL都不合格 ==），只返回需要的列，能够大大的节省数据传输量，与数据库的内存使用量哟。</p><p>整理自：https://cloud.tencent.com/developer/article/1054203</p><h2>limit 20000 加载很慢怎么解决</h2><p>mysql的性能低是因为数据库要去扫描N+M条记录，然后又要放弃之前N条记录，开销很大解决思略：</p><ol><li>前端加缓存，或者其他方式，减少落到库的查询操作，例如某些系统中数据在搜索引擎中有备份的，可以用es等进行搜索</li><li>使用延迟关联，即先通用limit得到需要数据的索引字段，然后再通过原表和索引字段关联获得需要数据</li></ol><blockquote><p>select a.* from a,(select id from table_1 where is_deleted='N' limit 100000,20) b where a.id = b.id</p></blockquote><ol start="3"><li>从业务上实现，不分页如此多，例如只能分页前100页，后面的不允许再查了</li><li>不使用limit N,M,而是使用limit N，即将offset转化为where条件。</li></ol>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>gradle-distDocker插件构建SpringBoot的Docker镜像</title>
      <link href="/2017/11/07/gradle-distDocker%E6%8F%92%E4%BB%B6%E6%9E%84%E5%BB%BASpringBoot%E7%9A%84Docker%E9%95%9C%E5%83%8F/"/>
      <url>/2017/11/07/gradle-distDocker%E6%8F%92%E4%BB%B6%E6%9E%84%E5%BB%BASpringBoot%E7%9A%84Docker%E9%95%9C%E5%83%8F/</url>
      <content type="html"><![CDATA[<p>通常我们使用 Dockerfile 来构建项目的Docker 镜像，但是也有需求希望使用 gralde 在编译项目的时候一起把镜像给构建并上传，所以该教程讲解了在 gradle中 编写配置 Dockerfile 并生成镜像的过程。</p><h4><strong>1. 添加依赖</strong></h4><p>教程使用<a href="https://github.com/Transmode/gradle-docker" target="_blank" rel="noopener">gradle-docker</a>插件来实现，在 Gradle 的脚本里配置 dockerfile 的构建镜像功能。</p><p>只需要在dependencies添加依赖就能使用 docker 插件。&lt;!-- more --&gt;build.gradle中的配置如下，其他配置省略：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">   ...</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        //添加gradle-docker 依赖，版本1.2</span><br><span class="line">        classpath &apos;se.transmode.gradle:gradle-docker:1.2&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4><strong>2. 加入插件</strong></h4><p>将插件加入配置文件build.gradle<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;application&apos; //可选</span><br><span class="line">apply plugin: &apos;docker&apos;</span><br></pre></td></tr></table></figure></p><p>如果添加了application插件的话，默认gradle-docker插件会添加一个distDocker的 gralde task，用来构建一个包含所有程序文件的 docker 镜像。</p><h4><strong>3. 指定Dockerfile所需</strong></h4><p>Dockerfiles 包含一些有关image相应的指令要求。</p><table><thead><tr><th style="text-align:center">Dockerfile关键词</th><th style="text-align:center">gradle-task方法</th></tr></thead><tbody><tr><td style="text-align:center">ADD</td><td style="text-align:center">addFile(Closure copySpec)</td></tr><tr><td style="text-align:center"> </td><td style="text-align:center">addFile(String source, String dest)</td></tr><tr><td style="text-align:center"> </td><td style="text-align:center">addFile(File source, String dest)</td></tr><tr><td style="text-align:center">CMD</td><td style="text-align:center">defaultCommand(List cmd)</td></tr><tr><td style="text-align:center">ENTRYPOINT</td><td style="text-align:center">entryPoint(List entryPoint)</td></tr><tr><td style="text-align:center">ENV</td><td style="text-align:center">setEnvironment(String key, String val)</td></tr><tr><td style="text-align:center">EXPOSE</td><td style="text-align:center">exposePort(Integer port)</td></tr><tr><td style="text-align:center"> </td><td style="text-align:center">exposePort(String port)</td></tr><tr><td style="text-align:center">RUN</td><td style="text-align:center">runCommand(String cmd)</td></tr><tr><td style="text-align:center">USER</td><td style="text-align:center">switchUser(String userNameOrUid)</td></tr><tr><td style="text-align:center">VOLUME</td><td style="text-align:center">volume(String... paths)</td></tr><tr><td style="text-align:center">WORKDIR</td><td style="text-align:center">workingDir(String dir)</td></tr></tbody></table><p>这里的springBoot项目只需要指定字符编码和时区：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">distDocker &#123;</span><br><span class="line">    runCommand(&quot;echo \&quot;Asia/shanghai\&quot; &gt; /etc/timezone;&quot;)</span><br><span class="line">    setEnvironment(&quot;LANG&quot;, &quot;zh_CN.UTF-8;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>依次可以想象，在插件中加入addFile实际是Docker的ADD指令，而runCommand会对应aRUN，而setEnvironment会创建一个ENV指令。</p><h4><strong>4. 构建运行</strong></h4><p>控制台中执行命令：gradle distDocker等待出现BUILD SUCCESSFUL就证明编译成功了。使用docker images命令就可以看到新生成的镜像了。</p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Java </tag>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis简介以及使用场景</title>
      <link href="/2017/09/06/Redis%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2017/09/06/Redis%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<h1>一、概述</h1><p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。</p><p>键的类型只能为字符串，值支持的五种类型数据类型为：字符串、列表、集合、有序集合、散列表。</p><p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p><h1>二、数据类型</h1><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">可以存储的值</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center">STRING</td><td style="text-align:center">字符串、整数或者浮点数</td><td style="text-align:center">对整个字符串或者字符串的其中一部分执行操作&lt;/br&gt; 对整数和浮点数执行自增或者自减操作</td></tr><tr><td style="text-align:center">LIST</td><td style="text-align:center">列表</td><td style="text-align:center">从两端压入或者弹出元素&lt;/br&gt; 读取单个或者多个元素&lt;/br&gt; 进行修剪，只保留一个范围内的元素</td></tr><tr><td style="text-align:center">SET</td><td style="text-align:center">无序集合</td><td style="text-align:center">添加、获取、移除单个元素&lt;/br&gt; 检查一个元素是否存在于集合中&lt;/br&gt; 计算交集、并集、差集&lt;/br&gt; 从集合里面随机获取元素</td></tr><tr><td style="text-align:center">HASH</td><td style="text-align:center">包含键值对的无序散列表</td><td style="text-align:center">添加、获取、移除单个键值对&lt;/br&gt; 获取所有键值对&lt;/br&gt; 检查某个键是否存在</td></tr><tr><td style="text-align:center">ZSET</td><td style="text-align:center">有序集合</td><td style="text-align:center">添加、获取、删除元素&lt;/br&gt; 根据分值范围或者成员来获取元素&lt;/br&gt; 计算一个键的排名</td></tr></tbody></table><blockquote><p><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/" target="_blank" rel="noopener">What Redis data structures look like</a></p></blockquote><h2>STRING</h2><p><img src="/2017/09/06/Redis简介以及使用场景/6019b2db-bc3e-4408-b6d8-96025f4481d6.png" title="图片"></p><p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">&gt; get hello</span><br><span class="line">"world"</span><br><span class="line">&gt; del hello</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></p><h2>LIST</h2><p><img src="/2017/09/06/Redis简介以及使用场景/fb327611-7e2b-4f2f-9f5b-38592d408f07.png" title="图片"></p><p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush list-key item2</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) "item"</span><br><span class="line">2) "item2"</span><br><span class="line">3) "item"</span><br><span class="line"></span><br><span class="line">&gt; lindex list-key 1</span><br><span class="line">"item2"</span><br><span class="line"></span><br><span class="line">&gt; lpop list-key</span><br><span class="line">"item"</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) "item2"</span><br><span class="line">2) "item"</span><br></pre></td></tr></table></figure></p><h2>SET</h2><p><img src="/2017/09/06/Redis简介以及使用场景/cd5fbcff-3f35-43a6-8ffa-082a93ce0f0e.png" title="图片"></p><p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item3</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) "item"</span><br><span class="line">2) "item2"</span><br><span class="line">3) "item3"</span><br><span class="line"></span><br><span class="line">&gt; sismember set-key item4</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sismember set-key item</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) "item"</span><br><span class="line">2) "item3"</span><br></pre></td></tr></table></figure></p><h2>HASH</h2><p><img src="/2017/09/06/Redis简介以及使用场景/7bd202a7-93d4-4f3a-a878-af68ae25539a.png" title="图片"></p><p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key2 value2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) "sub-key1"</span><br><span class="line">2) "value1"</span><br><span class="line">3) "sub-key2"</span><br><span class="line">4) "value2"</span><br><span class="line"></span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hget hash-key sub-key1</span><br><span class="line">"value1"</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) "sub-key1"</span><br><span class="line">2) "value1"</span><br></pre></td></tr></table></figure></p><h2>ZSET</h2><p><img src="/2017/09/06/Redis简介以及使用场景/1202b2d6-9469-4251-bd47-ca6034fb6116.png" title="图片"></p><p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd zset-key 728 member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) "member1"</span><br><span class="line">2) "728"</span><br><span class="line">3) "member0"</span><br><span class="line">4) "982"</span><br><span class="line"></span><br><span class="line">&gt; zrangebyscore zset-key 0 800 withscores</span><br><span class="line">1) "member1"</span><br><span class="line">2) "728"</span><br><span class="line"></span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) "member0"</span><br><span class="line">2) "982"</span><br></pre></td></tr></table></figure></p><h1>三、数据结构</h1><h2>字典</h2><p>以下是 Redis 字典的主要数据结构，从上往下分析，一个 dict 有两个 dictht，一个 dictht 有一个 dictEntry 数组，每个 dictEntry 有 next 指针因此是一个链表结构。从上面的分析可以看出 Redis 的字典是一个基于拉链法解决冲突的哈希表结构。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure></p><p>哈希表需要具备扩容能力，在扩容时就需要对每个键值对进行 rehash。dict 有两个 dictht，在 rehash 的时候会将一个 dictht 上的键值对重新插入另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。</p><p>rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。</p><p>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。</p><p>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。</p><p>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的操作也需要到对应的 dictht 去执行。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n * <span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span> (d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>跳跃表</h2><p>是有序集合的底层实现之一。</p><p>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。</p><p><img src="/2017/09/06/Redis简介以及使用场景/beba612e-dc5b-4fc2-869d-0b23408ac90a.png"></p><p>在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。例如下图演示了查找 22 的过程。</p><p><img src="/2017/09/06/Redis简介以及使用场景/0ea37ee2-c224-4c79-b895-e131c6805c40.png"></p><p>与红黑树等平衡树相比，跳跃表具有以下优点：</p><ul><li>插入速度非常快速，因为不需要平衡树的旋转操作；</li><li>更容易实现；</li><li>支持无锁操作。</li></ul><h1>四、使用场景</h1><h2>计数器</h2><p>可以对 String 进行自增自减运算，从而实现计数器功能。</p><p>例如对于网站访问量，如果使用 MySQL 数据库进行存储，那么每访问一次网站就要对磁盘进行读写操作。而对 Redis 这种内存型数据库的读写性能非常高，很适合存储这种频繁读写的计数量。</p><h2>缓存</h2><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p><h2>查找表</h2><p>例如 DNS 记录就很适合使用 Redis 进行存储。</p><p>查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效。</p><h2>消息队列</h2><p>List 是一个双向链表，可以通过 lpop 和 lpush 写入和读取消息。</p><p>不过最好使用 Kafka、RabbitMQ 等消息中间件。</p><h2>会话缓存</h2><p>在分布式场景下具有多个应用服务器，可以使用 Redis 来统一存储这些应用服务器的会话信息，使得某个应用服务器宕机时不会丢失会话信息，从而保证高可用。</p><h2>分布式锁实现</h2><p>在分布式场景下，无法使用单机环境下的锁实现。当多个节点上的进程都需要获取同一个锁时，就需要使用分布式锁来进行同步。</p><p>除了可以使用 Redis 自带的 SETNX 命令实现分布式锁之外，还可以使用官方提供的 RedLock 分布式锁实现。</p><h2>其它</h2><p>Set 可以实现交集、并集等操作，例如共同好友功能。</p><p>ZSet 可以实现有序性操作，例如排行榜功能。</p><h1>五、Redis 与 Memcached</h1><p>两者都是非关系型内存键值数据库。有以下主要不同：</p><h2>数据类型</h2><p>Memcached 仅支持字符串类型，而 Redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。</p><h2>数据持久化</h2><p>Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。</p><h2>分布式</h2><p>Memcached 不支持分布式，只能通过在客户端使用一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</p><p>Redis Cluster 实现了分布式的支持。</p><h2>内存管理机制</h2><p>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 Memcached 的数据则会一直在内存中。</p><p>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</p><h1>六、键的过期时间</h1><p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。</p><p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</p><h1>七、数据淘汰策略</h1><p>可以设置内存最大使用量，当内存使用量超过时施行淘汰策略，具体有 6 种淘汰策略。</p><table><thead><tr><th style="text-align:center">策略</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">volatile-lru</td><td style="text-align:center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td style="text-align:center">volatile-ttl</td><td style="text-align:center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td style="text-align:center">volatile-random</td><td style="text-align:center">从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td style="text-align:center">allkeys-lru</td><td style="text-align:center">从所有数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td style="text-align:center">allkeys-random</td><td style="text-align:center">从所有数据集中任意选择数据进行淘汰</td></tr><tr><td style="text-align:center">noeviction</td><td style="text-align:center">禁止驱逐数据</td></tr></tbody></table><p>如果使用 Redis 来缓存数据时，要保证所有数据都是热点数据，可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p><p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法（LRU、TTL）实际实现上并非针对所有 key，而是抽样一小部分 key 从中选出被淘汰 key。</p><h1>八、持久化</h1><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p><h2>快照持久化</h2><p>将某个时间点的所有数据都存放到硬盘上。</p><p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p><p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p><p>如果数据量很大，保存快照的时间会很长。</p><h2>AOF 持久化</h2><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p><p>对硬盘的文件进行写入时，写入的内容首先会被存储到缓冲区，然后由操作系统决定什么时候将该内容同步到硬盘，用户可以调用 file.flush() 方法请求操作系统尽快将缓冲区存储的数据同步到硬盘。可以看出写入文件的数据不会立即同步到硬盘上，在将写命令添加到 AOF 文件时，要根据需求来保证何时同步到硬盘上。</p><p>有以下同步选项：</p><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">同步频率</th></tr></thead><tbody><tr><td style="text-align:center">always</td><td style="text-align:center">每个写命令都同步</td></tr><tr><td style="text-align:center">everysec</td><td style="text-align:center">每秒同步一次</td></tr><tr><td style="text-align:center">no</td><td style="text-align:center">让操作系统来决定何时同步</td></tr></tbody></table><ul><li>always 选项会严重减低服务器的性能；</li><li>everysec 选项比较合适，可以保证系统奔溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li><li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统奔溃时数据丢失的数量。</li></ul><p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p><h1>九、发布与订阅</h1><p>订阅者订阅了频道之后，发布者向频道发送字符串消息会被所有订阅者接收到。</p><p>某个客户端使用 SUBSCRIBE 订阅一个频道，其它客户端可以使用 PUBLISH 向这个频道发送消息。</p><p>发布与订阅模式和观察者模式有以下不同：</p><ul><li>观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，发布者与订阅者不知道对方的存在，它们之间通过频道进行通信。</li><li>观察者模式是同步的，当事件触发时，主题会去调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，发布者向频道发送一个消息之后，就不需要关心订阅者何时去订阅这个消息。</li></ul><p><img src="/2017/09/06/Redis简介以及使用场景/bee1ff1d-c80f-4b3c-b58c-7073a8896ab2.jpg" title="图片"></p><h1>十、事务</h1><p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p><p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p><p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p><h1>十一、事件</h1><p>Redis 服务器是一个事件驱动程序。</p><h2>文件事件</h2><p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。</p><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</p><p><img src="/2017/09/06/Redis简介以及使用场景/c0a9fa91-da2e-4892-8c9f-80206a6f7047.png" class="9ea86eb5-000a-4281-b948-7b567bd6f1d8.png"> <br> ## 时间事件 服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。 时间事件又分为： - 定时事件：是让一段程序在指定的时间之内执行一次； - 周期性事件：是让一段程序每隔指定时间就执行一次。 Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。 ## 事件的调度与执行 服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。 事件调度与执行由 aeProcessEvents 函数负责，伪代码如下： undefined 将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下： undefined 从事件处理的角度来看，服务器运行流程如下： {% asset_img" title="图片"></p><h1>十二、复制</h1><p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p><p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p><h2>连接过程</h2><ol><li><p>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</p></li><li><p>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</p></li><li><p>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</p></li></ol><h2>主从链</h2><p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p><p><img src="/2017/09/06/Redis简介以及使用场景/395a9e83-b1a1-4a1d-b170-d081e7bb5bab.png"></p><h1>十三、Sentinel</h1><p>Sentinel（哨兵）可以监听主服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p><h1>十四、分片</h1><p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，也可以从多台机器里面获取数据，这种方法在解决某些问题时可以获得线性级别的性能提升。</p><p>假设有 4 个 Reids 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... 等等，有不同的方式来选择一个指定的键存储在哪个实例中。最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</p><p>根据执行分片的位置，可以分为三种分片方式：</p><ul><li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li><li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li><li>服务器分片：Redis Cluster。</li></ul><h1>十五、一个简单的论坛系统分析</h1><p>该论坛系统功能如下：</p><ul><li>可以发布文章；</li><li>可以对文章进行点赞；</li><li>在首页可以按文章的发布时间或者文章的点赞数进行排序显示。</li></ul><h2>文章信息</h2><p>文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。</p><p>Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。</p><p><img src="/2017/09/06/Redis简介以及使用场景/7c54de21-e2ff-402e-bc42-4037de1c1592.png" title="图片"></p><h2>点赞功能</h2><p>当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。</p><p>为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。</p><p><img src="/2017/09/06/Redis简介以及使用场景/485fdf34-ccf8-4185-97c6-17374ee719a0.png" title="图片"></p><h2>对文章进行排序</h2><p>为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的）</p><p><img src="/2017/09/06/Redis简介以及使用场景/f7d170a3-e446-4a64-ac2d-cb95028f81a8.png"></p><h1>参考资料</h1><ul><li>Carlson J L. Redis in Action[J]. Media.johnwiley.com.au, 2013.</li><li><a href="http://redisbook.com/index.html" target="_blank" rel="noopener">黄健宏. Redis 设计与实现 [M]. 机械工业出版社, 2014.</a></li><li><a href="https://redislabs.com/ebook/foreword/" target="_blank" rel="noopener">REDIS IN ACTION</a></li><li><a href="http://ticki.github.io/blog/skip-lists-done-right/" target="_blank" rel="noopener">Skip Lists: Done Right</a></li><li><a href="http://www.cnblogs.com/loveincode/p/7411911.html" target="_blank" rel="noopener">论述 Redis 和 Memcached 的差异</a></li><li><a href="http://wiki.jikexueyuan.com/project/redis-guide" target="_blank" rel="noopener">Redis 3.0 中文版- 分片</a></li><li><a href="http://www.scienjus.com/redis-use-case/" target="_blank" rel="noopener">Redis 应用场景</a></li><li><a href="http://developers-club.com/posts/270339/" target="_blank" rel="noopener">Observer vs Pub-Sub</a></li></ul>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>springBoot-AOP的使用</title>
      <link href="/2017/07/03/springBoot-AOP%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/07/03/springBoot-AOP%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1>添加aop starter依赖</h1><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hhbbz.springboot.aop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- spring boot aop starter依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--druid --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1>配置文件中开启支持</h1><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.aop.auto=true</span><br></pre></td></tr></table></figure></p><h1>编写切面</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hhbbz.springboot.aop.aop;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.json.JSONUtils;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 注册到Spring容器，必须加入这个注解</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 该注解标示该类为切面类，切面是由通知和切点组成的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger =  LoggerFactory.getLogger(ApiAspect.class);</span><br><span class="line"> </span><br><span class="line">    ThreadLocal&lt;Long&gt; startTime = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.hhbbz.springboot.aop.controller.HelloController.*(..))"</span>)<span class="comment">// 定义切点表达式</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">controllerPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.hhbbz.springboot.aop.annotation.RedisCache)"</span>)<span class="comment">// 定义注解类型的切点，只要方法上有该注解，都会匹配</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotationPoint</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义前置通知</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"annotationPoint()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"方法执行前执行.....before"</span>);</span><br><span class="line">ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        logger.info(<span class="string">"&lt;===================================================================="</span>);</span><br><span class="line">        logger.info(<span class="string">"请求来源:  =&gt; "</span> + request.getRemoteAddr());</span><br><span class="line">        logger.info(<span class="string">"请求URL: "</span> + request.getRequestURL().toString());</span><br><span class="line">        logger.info(<span class="string">"请求方式: "</span> + request.getMethod());</span><br><span class="line">        logger.info(<span class="string">"响应方法: "</span> + joinPoint.getSignature().getDeclaringTypeName() + <span class="string">"."</span> + joinPoint.getSignature().getName());</span><br><span class="line">        logger.info(<span class="string">"请求参数 : "</span> + Arrays.toString(joinPoint.getArgs()));</span><br><span class="line">        logger.info(<span class="string">"---------------------------------------------------------------------"</span>);</span><br><span class="line">        startTime.set(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Around</span>(<span class="string">"controllerPoint() &amp;&amp; args(arg)"</span>)<span class="comment">// 需要匹配切点表达式，同时需要匹配参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp, String arg)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"name:"</span>+arg);</span><br><span class="line">System.out.println(<span class="string">"方法环绕start....around."</span>);</span><br><span class="line">String result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">result = (String) pjp.proceed()+<span class="string">" aop String"</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"方法环绕end.....around"</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@After</span>(<span class="string">"within(com.hhbbz.springboot.aop.controller.*Controller)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"方法之后执行....after."</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@AfterReturning</span>(pointcut=<span class="string">"controllerPoint()"</span>, returning=<span class="string">"rst"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(JoinPoint joinPoint, Object rst)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"方法执行完执行.....afterReturning"</span>);</span><br><span class="line">logger.info(<span class="string">"耗时（毫秒） : "</span> + (System.currentTimeMillis() - startTime.get()));</span><br><span class="line">        logger.info(<span class="string">"返回数据: &#123;&#125;"</span>, JSONUtils.toJSONString(rst));</span><br><span class="line">        logger.info(<span class="string">"====================================================================&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@AfterThrowing</span>(<span class="string">"within(com.hhbbz.springboot.aop.controller.*Controller)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"异常出现之后.....afterThrowing"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>定义注解</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hhbbz.springboot.aop.annotation;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：加入查询结果的缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hhbbz</span></span><br><span class="line"><span class="comment"> * 创建时间：2017年7月1日 上午10:30:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RedisCache &#123;</span><br><span class="line">    Class&lt;?&gt; type();<span class="comment">//被代理类的全类名，在之后会做为redis hash 的key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>编写Controller</h1><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hhbbz.springboot.aop.controller;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.hhbbz.springboot.aop.annotation.RedisCache;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>, required = <span class="keyword">true</span>)</span> String name) </span>&#123;</span><br><span class="line">    String result = <span class="string">"hello  "</span> + name;</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/world"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">world</span><span class="params">(@RequestParam(value = <span class="string">"arg"</span>, required = <span class="keyword">true</span>)</span> String arg)</span>&#123;</span><br><span class="line">  String result = <span class="string">"world  "</span> + arg;</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@RequestMapping</span>(value=<span class="string">"/annotation"</span>)</span><br><span class="line">  <span class="meta">@RedisCache</span>(type=String.class)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">annotation</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"annotation"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>测试</h1><ol><li><p>启动服务</p></li><li><p>在浏览器中输入：http://localhost:8080/annotation</p></li><li><p>测试结果如下</p></li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">方法执行前执行.....before</span><br><span class="line">2017-07-06 18:40:23.273  INFO 2208 --- [nio-8080-exec-1] com.hhbbz.springboot.aop.aop.ApiAspect  : &lt;====================================================================</span><br><span class="line">2017-07-06 18:40:23.274  INFO 2208 --- [nio-8080-exec-1] com.hhbbz.springboot.aop.aop.ApiAspect  : 请求来源:  =&gt; 127.0.0.1</span><br><span class="line">2017-07-06 18:40:23.274  INFO 2208 --- [nio-8080-exec-1] com.hhbbz.springboot.aop.aop.ApiAspect  : 请求URL: http://localhost:8080/annotation</span><br><span class="line">2017-07-06 18:40:23.274  INFO 2208 --- [nio-8080-exec-1] com.hhbbz.springboot.aop.aop.ApiAspect  : 请求方式: GET</span><br><span class="line">2017-07-06 18:40:23.276  INFO 2208 --- [nio-8080-exec-1] com.hhbbz.springboot.aop.aop.ApiAspect  : 响应方法: com.hhbbz.springboot.aop.controller.HelloController.annotation</span><br><span class="line">2017-07-06 18:40:23.276  INFO 2208 --- [nio-8080-exec-1] com.hhbbz.springboot.aop.aop.ApiAspect  : 请求参数 : []</span><br><span class="line">2017-07-06 18:40:23.276  INFO 2208 --- [nio-8080-exec-1] com.hhbbz.springboot.aop.aop.ApiAspect  : ---------------------------------------------------------------------</span><br><span class="line">方法之后执行....after.</span><br><span class="line">方法执行完执行.....afterReturning</span><br><span class="line">2017-07-06 18:40:23.286  INFO 2208 --- [nio-8080-exec-1] com.hhbbz.springboot.aop.aop.ApiAspect  : 耗时（毫秒） : 10</span><br><span class="line">2017-07-06 18:40:23.289  INFO 2208 --- [nio-8080-exec-1] com.hhbbz.springboot.aop.aop.ApiAspect  : 返回数据: &quot;annotation&quot;</span><br><span class="line">2017-07-06 18:40:23.291  INFO 2208 --- [nio-8080-exec-1] com.hhbbz.springboot.aop.aop.ApiAspect  : ====================================================================&gt;</span><br></pre></td></tr></table></figure></p><p>由于Around环绕通知不匹配，所以没有切入进去.</p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从Dubbo浅谈RPC和HTTP</title>
      <link href="/2017/06/25/%E4%BB%8EDubbo%E6%B5%85%E8%B0%88RPC%E5%92%8CHTTP/"/>
      <url>/2017/06/25/%E4%BB%8EDubbo%E6%B5%85%E8%B0%88RPC%E5%92%8CHTTP/</url>
      <content type="html"><![CDATA[<h1>Dubbo协议</h1><p>Dubbo是阿里集团开源的一个极为出名的RPC框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是及其鲜明的特色。同样 的远程接口是基于Java Interface，并且依托于spring框架方便开发。可以方便的打包成单一文件，独立进程运行，和现在的微服务概念一致。</p><p>dubbo提供了多种协议，而协议本身不同有个几个指标</p><ol><li>连接个数：1 or n</li><li>连接方式: 长连接 or 短连接</li><li>传输协议：tcp or http</li><li>传输方式： 同步 or nio异步</li><li>序列化格式：hessian or Java二进制 or 类json表单序列化</li></ol><p>好了，现在有了指标，你的需求按照这些指标来选择</p><ul><li>你消费者和服务提供者 对比</li><li>传输数据大小</li><li>传输数据的格式</li><li>消费者和提供者 是否有防火墙</li><li>服务提供实现是 cpu密集型还是内存密集型.</li></ul><h1>RPC架构</h1><p>先说说RPC服务的基本架构吧。允许我可耻地盗一幅图哈~我们可以很清楚地看到，一个完整的RPC架构里面包含了四个核心的组件，分别是Client ,Server,Client Stub以及Server Stub，这个Stub大家可以理解为存根。分别说说这几个组件：</p><ul><li>客户端（Client），服务的调用方。</li><li>服务端（Server），真正的服务提供者。</li><li>客户端存根，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。</li><li>服务端存根，接收客户端发送过来的消息，将消息解包，并调用本地的方法。</li></ul><p><img src="/2017/06/25/从Dubbo浅谈RPC和HTTP/1.jpg" title="图片"></p><p>RPC主要是用在大型企业里面，因为大型企业里面系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候RPC的优势就比较明显了。实际的开发当中是这么做的，项目一般使用maven来管理。比如我们有一个处理订单的系统服务，先声明它的所有的接口（这里就是具体指Java中的interface），然后将整个项目打包为一个jar包，服务端这边引入这个二方库，然后实现相应的功能，客户端这边也只需要引入这个二方库即可调用了。为什么这么做？主要是为了减少客户端这边的jar包大小，因为每一次打包发布的时候，jar包太多总是会影响效率。另外也是将客户端和服务端解耦，提高代码的可移植性。</p><h1>HTTP服务</h1><p>其实在很久以前，我对于企业开发的模式一直定性为HTTP接口开发，也就是我们常说的RESTful风格的服务接口。的确，对于在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议进行传输。我们记得之前本科实习在公司做后台开发的时候，主要就是进行接口的开发，还要写一大份接口文档，严格地标明输入输出是什么？说清楚每一个接口的请求方法，以及请求参数需要注意的事项等。比如下面这个例子：</p><p>POST http://www.httpexample.com/restful/buyer/info/share</p><p>接口可能返回一个JSON字符串或者是XML文档。然后客户端再去处理这个返回的信息，从而可以比较快速地进行开发。但是对于大型企业来说，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。</p><h1>HTTP和RPC对比</h1><ul><li>一般HTTP协议的REST请求都需要穿过防火墙的，提供服务器调用可能是外网地址。</li><li>而RPC内网调用基本都是同机房内网ip，不需要防火墙，性能也会很好。</li><li>REST都是消费者远远大于服务提供者的，都是数据量小的输入、输出参数。本地调用，可能用二进制的好点。 REST可能用类json表单序列化好点。</li><li>长连接使用HTTP而不是RPC</li><li>传输格式可以二进制</li><li>Nio多路复用，支持并发会高很多</li><li>传统HTTP线程池实现，线程开销太大</li></ul><h1>总结</h1><p>http是依赖于tcp的，http属于应用层。http协议自带默认的tcp报文协议，然而http1.1的报文协议解析效率过慢。而rpc框架是基于tcp协议的，相当于自定义了tcp的报文协议，提供者和消费者有统一的解析方式，且都是基于Netty去作为基础通信组件，用于实现各进程节点之间的内部通信，所以效率就起来了。</p><p>RPC服务和HTTP服务还是存在很多的不同点的，一般来说，RPC服务主要是针对大型企业的，而HTTP服务主要是针对小企业的，因为RPC效率更高，而HTTP服务开发迭代会更快。总之，选用什么样的框架不是按照市场上流行什么而决定的，而是要对整个项目进行完整地评估，从而在仔细比较两种开发框架对于整个项目的影响，最后再决定什么才是最适合这个项目的。一定不要为了使用RPC而每个项目都用RPC，而是要因地制宜，具体情况具体分析。</p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h1>about</h1><p>博客中只是用作日常的摘抄和记录，希望能将知识和经验更好的分享出去。</p><h1>social</h1><p><a href="https://github.com/hhbbz" target="_blank" rel="noopener">github:@hhbbz</a></p><p><a href="https://www.zhihu.com/people/hhbbz/activities" target="_blank" rel="noopener">zhihu:@hhbbz</a></p>]]></content>
    </entry>
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>时间轴</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
